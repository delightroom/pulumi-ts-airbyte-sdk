// *** WARNING: this file was generated by pulumi-language-nodejs. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface ConnectionConfigurations {
    streams?: pulumi.Input<pulumi.Input<inputs.ConnectionConfigurationsStream>[]>;
}

export interface ConnectionConfigurationsStream {
    /**
     * Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default.
     */
    cursorFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to move raw files from the source to the destination during the sync.
     */
    includeFiles?: pulumi.Input<boolean>;
    /**
     * Mappers that should be applied to the stream before writing to the destination.
     */
    mappers?: pulumi.Input<pulumi.Input<inputs.ConnectionConfigurationsStreamMapper>[]>;
    /**
     * Not Null
     */
    name?: pulumi.Input<string>;
    /**
     * Namespace of the stream.
     */
    namespace?: pulumi.Input<string>;
    /**
     * Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema.
     */
    primaryKeys?: pulumi.Input<pulumi.Input<pulumi.Input<string>[]>[]>;
    /**
     * Paths to the fields that will be included in the configured catalog.
     */
    selectedFields?: pulumi.Input<pulumi.Input<inputs.ConnectionConfigurationsStreamSelectedField>[]>;
    /**
     * must be one of ["full_refresh_overwrite", "full_refresh_overwrite_deduped", "full_refresh_append", "incremental_append", "incremental_deduped_history"]
     */
    syncMode?: pulumi.Input<string>;
}

export interface ConnectionConfigurationsStreamMapper {
    id?: pulumi.Input<string>;
    /**
     * The values required to configure the mapper. Not Null
     */
    mapperConfiguration?: pulumi.Input<inputs.ConnectionConfigurationsStreamMapperMapperConfiguration>;
    /**
     * Not Null; must be one of ["hashing", "field-renaming", "row-filtering", "encryption"]
     */
    type?: pulumi.Input<string>;
}

export interface ConnectionConfigurationsStreamMapperMapperConfiguration {
    encryption?: pulumi.Input<inputs.ConnectionConfigurationsStreamMapperMapperConfigurationEncryption>;
    fieldRenaming?: pulumi.Input<inputs.ConnectionConfigurationsStreamMapperMapperConfigurationFieldRenaming>;
    hashing?: pulumi.Input<inputs.ConnectionConfigurationsStreamMapperMapperConfigurationHashing>;
    rowFiltering?: pulumi.Input<inputs.ConnectionConfigurationsStreamMapperMapperConfigurationRowFiltering>;
}

export interface ConnectionConfigurationsStreamMapperMapperConfigurationEncryption {
    aes?: pulumi.Input<inputs.ConnectionConfigurationsStreamMapperMapperConfigurationEncryptionAes>;
    rsa?: pulumi.Input<inputs.ConnectionConfigurationsStreamMapperMapperConfigurationEncryptionRsa>;
}

export interface ConnectionConfigurationsStreamMapperMapperConfigurationEncryptionAes {
    /**
     * Not Null; must be one of ["RSA", "AES"]
     */
    algorithm?: pulumi.Input<string>;
    /**
     * Not Null
     */
    fieldNameSuffix?: pulumi.Input<string>;
    /**
     * Not Null
     */
    key?: pulumi.Input<string>;
    /**
     * Not Null; must be one of ["CBC", "CFB", "OFB", "CTR", "GCM", "ECB"]
     */
    mode?: pulumi.Input<string>;
    /**
     * Not Null; must be one of ["NoPadding", "PKCS5Padding"]
     */
    padding?: pulumi.Input<string>;
    /**
     * Not Null
     */
    targetField?: pulumi.Input<string>;
}

export interface ConnectionConfigurationsStreamMapperMapperConfigurationEncryptionRsa {
    /**
     * Not Null; must be one of ["RSA", "AES"]
     */
    algorithm?: pulumi.Input<string>;
    /**
     * Not Null
     */
    fieldNameSuffix?: pulumi.Input<string>;
    /**
     * Not Null
     */
    publicKey?: pulumi.Input<string>;
    /**
     * Not Null
     */
    targetField?: pulumi.Input<string>;
}

export interface ConnectionConfigurationsStreamMapperMapperConfigurationFieldRenaming {
    /**
     * The new name for the field after renaming. Not Null
     */
    newFieldName?: pulumi.Input<string>;
    /**
     * The current name of the field to rename. Not Null
     */
    originalFieldName?: pulumi.Input<string>;
}

export interface ConnectionConfigurationsStreamMapperMapperConfigurationHashing {
    /**
     * The suffix to append to the field name after hashing. Not Null
     */
    fieldNameSuffix?: pulumi.Input<string>;
    /**
     * The hashing algorithm to use. Not Null; must be one of ["MD2", "MD5", "SHA-1", "SHA-224", "SHA-256", "SHA-384", "SHA-512"]
     */
    method?: pulumi.Input<string>;
    /**
     * The name of the field to be hashed. Not Null
     */
    targetField?: pulumi.Input<string>;
}

export interface ConnectionConfigurationsStreamMapperMapperConfigurationRowFiltering {
    /**
     * Not Null; Parsed as JSON.
     */
    conditions?: pulumi.Input<string>;
}

export interface ConnectionConfigurationsStreamSelectedField {
    fieldPaths?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ConnectionSchedule {
    basicTiming?: pulumi.Input<string>;
    cronExpression?: pulumi.Input<string>;
    /**
     * Not Null; must be one of ["manual", "cron"]
     */
    scheduleType?: pulumi.Input<string>;
}

export interface ConnectionTag {
    /**
     * Not Null
     */
    color?: pulumi.Input<string>;
    /**
     * Not Null
     */
    name?: pulumi.Input<string>;
    /**
     * Not Null
     */
    tagId?: pulumi.Input<string>;
    /**
     * Not Null
     */
    workspaceId?: pulumi.Input<string>;
}

export interface DestinationAstraConfiguration {
    /**
     * Embedding configuration
     */
    embedding: pulumi.Input<inputs.DestinationAstraConfigurationEmbedding>;
    /**
     * Astra DB gives developers the APIs, real-time data and ecosystem integrations to put accurate RAG and Gen AI apps with fewer hallucinations in production.
     */
    indexing: pulumi.Input<inputs.DestinationAstraConfigurationIndexing>;
    /**
     * Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
     */
    omitRawText?: pulumi.Input<boolean>;
    processing: pulumi.Input<inputs.DestinationAstraConfigurationProcessing>;
}

export interface DestinationAstraConfigurationEmbedding {
    /**
     * Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    azureOpenAi?: pulumi.Input<inputs.DestinationAstraConfigurationEmbeddingAzureOpenAi>;
    /**
     * Use the Cohere API to embed text.
     */
    cohere?: pulumi.Input<inputs.DestinationAstraConfigurationEmbeddingCohere>;
    /**
     * Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
     */
    fake?: pulumi.Input<inputs.DestinationAstraConfigurationEmbeddingFake>;
    /**
     * Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    openAi?: pulumi.Input<inputs.DestinationAstraConfigurationEmbeddingOpenAi>;
    /**
     * Use a service that's compatible with the OpenAI API to embed text.
     */
    openAiCompatible?: pulumi.Input<inputs.DestinationAstraConfigurationEmbeddingOpenAiCompatible>;
}

export interface DestinationAstraConfigurationEmbeddingAzureOpenAi {
    /**
     * The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    apiBase: pulumi.Input<string>;
    /**
     * The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    deployment: pulumi.Input<string>;
    /**
     * The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    openaiKey: pulumi.Input<string>;
}

export interface DestinationAstraConfigurationEmbeddingCohere {
    cohereKey: pulumi.Input<string>;
}

export interface DestinationAstraConfigurationEmbeddingFake {
}

export interface DestinationAstraConfigurationEmbeddingOpenAi {
    openaiKey: pulumi.Input<string>;
}

export interface DestinationAstraConfigurationEmbeddingOpenAiCompatible {
    /**
     * Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The base URL for your OpenAI-compatible service
     */
    baseUrl: pulumi.Input<string>;
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * The name of the model to use for embedding. Default: "text-embedding-ada-002"
     */
    modelName?: pulumi.Input<string>;
}

export interface DestinationAstraConfigurationIndexing {
    /**
     * The application token authorizes a user to connect to a specific Astra DB database. It is created when the user clicks the Generate Token button on the Overview tab of the Database page in the Astra UI.
     */
    astraDbAppToken: pulumi.Input<string>;
    /**
     * The endpoint specifies which Astra DB database queries are sent to. It can be copied from the Database Details section of the Overview tab of the Database page in the Astra UI.
     */
    astraDbEndpoint: pulumi.Input<string>;
    /**
     * Keyspaces (or Namespaces) serve as containers for organizing data within a database. You can create a new keyspace uisng the Data Explorer tab in the Astra UI. The keyspace default_keyspace is created for you when you create a Vector Database in Astra DB.
     */
    astraDbKeyspace: pulumi.Input<string>;
    /**
     * Collections hold data. They are analagous to tables in traditional Cassandra terminology. This tool will create the collection with the provided name automatically if it does not already exist. Alternatively, you can create one thorugh the Data Explorer tab in the Astra UI.
     */
    collection: pulumi.Input<string>;
}

export interface DestinationAstraConfigurationProcessing {
    /**
     * Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
     */
    chunkOverlap?: pulumi.Input<number>;
    /**
     * Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
     */
    chunkSize: pulumi.Input<number>;
    /**
     * List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
     */
    fieldNameMappings?: pulumi.Input<pulumi.Input<inputs.DestinationAstraConfigurationProcessingFieldNameMapping>[]>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Split text fields into chunks based on the specified method.
     */
    textSplitter?: pulumi.Input<inputs.DestinationAstraConfigurationProcessingTextSplitter>;
}

export interface DestinationAstraConfigurationProcessingFieldNameMapping {
    /**
     * The field name in the source
     */
    fromField: pulumi.Input<string>;
    /**
     * The field name to use in the destination
     */
    toField: pulumi.Input<string>;
}

export interface DestinationAstraConfigurationProcessingTextSplitter {
    /**
     * Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
     */
    byMarkdownHeader?: pulumi.Input<inputs.DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader>;
    /**
     * Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
     */
    byProgrammingLanguage?: pulumi.Input<inputs.DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguage>;
    /**
     * Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
     */
    bySeparator?: pulumi.Input<inputs.DestinationAstraConfigurationProcessingTextSplitterBySeparator>;
}

export interface DestinationAstraConfigurationProcessingTextSplitterByMarkdownHeader {
    /**
     * Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
     */
    splitLevel?: pulumi.Input<number>;
}

export interface DestinationAstraConfigurationProcessingTextSplitterByProgrammingLanguage {
    /**
     * Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
     */
    language: pulumi.Input<string>;
}

export interface DestinationAstraConfigurationProcessingTextSplitterBySeparator {
    /**
     * Whether to keep the separator in the resulting chunks. Default: false
     */
    keepSeparator?: pulumi.Input<boolean>;
    /**
     * List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
     */
    separators?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationAstraResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationAstraResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationAstraResourceAllocationJobSpecific>[]>;
}

export interface DestinationAstraResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationAstraResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationAstraResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationAstraResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationAwsDatalakeConfiguration {
    /**
     * target aws account id
     */
    awsAccountId?: pulumi.Input<string>;
    /**
     * The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
     */
    bucketName: pulumi.Input<string>;
    /**
     * S3 prefix
     */
    bucketPrefix?: pulumi.Input<string>;
    /**
     * Choose How to Authenticate to AWS.
     */
    credentials: pulumi.Input<inputs.DestinationAwsDatalakeConfigurationCredentials>;
    /**
     * Format of the data output.
     */
    format?: pulumi.Input<inputs.DestinationAwsDatalakeConfigurationFormat>;
    /**
     * Cast float/double as decimal(38,18). This can help achieve higher accuracy and represent numbers correctly as received from the source. Default: false
     */
    glueCatalogFloatAsDecimal?: pulumi.Input<boolean>;
    /**
     * Add a default tag key to databases created by this destination
     */
    lakeformationDatabaseDefaultTagKey?: pulumi.Input<string>;
    /**
     * Add default values for the `Tag Key` to databases created by this destination. Comma separate for multiple values.
     */
    lakeformationDatabaseDefaultTagValues?: pulumi.Input<string>;
    /**
     * The default database this destination will use to create tables in per stream. Can be changed per connection by customizing the namespace.
     */
    lakeformationDatabaseName: pulumi.Input<string>;
    /**
     * Whether to create tables as LF governed tables. Default: false
     */
    lakeformationGovernedTables?: pulumi.Input<boolean>;
    /**
     * Partition data by cursor fields when a cursor field is a date. Default: "NO PARTITIONING"; must be one of ["NO PARTITIONING", "DATE", "YEAR", "MONTH", "DAY", "YEAR/MONTH", "YEAR/MONTH/DAY"]
     */
    partitioning?: pulumi.Input<string>;
    /**
     * The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. Default: ""; must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
     */
    region?: pulumi.Input<string>;
}

export interface DestinationAwsDatalakeConfigurationCredentials {
    iamRole?: pulumi.Input<inputs.DestinationAwsDatalakeConfigurationCredentialsIamRole>;
    iamUser?: pulumi.Input<inputs.DestinationAwsDatalakeConfigurationCredentialsIamUser>;
}

export interface DestinationAwsDatalakeConfigurationCredentialsIamRole {
    /**
     * Will assume this role to write data to s3
     */
    roleArn: pulumi.Input<string>;
}

export interface DestinationAwsDatalakeConfigurationCredentialsIamUser {
    /**
     * AWS User Access Key Id
     */
    awsAccessKeyId: pulumi.Input<string>;
    /**
     * Secret Access Key
     */
    awsSecretAccessKey: pulumi.Input<string>;
}

export interface DestinationAwsDatalakeConfigurationFormat {
    jsonLinesNewlineDelimitedJson?: pulumi.Input<inputs.DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson>;
    parquetColumnarStorage?: pulumi.Input<inputs.DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage>;
}

export interface DestinationAwsDatalakeConfigurationFormatJsonLinesNewlineDelimitedJson {
    /**
     * The compression algorithm used to compress data. Default: "UNCOMPRESSED"; must be one of ["UNCOMPRESSED", "GZIP"]
     */
    compressionCodec?: pulumi.Input<string>;
    /**
     * Default: "JSONL"; must be "JSONL"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationAwsDatalakeConfigurationFormatParquetColumnarStorage {
    /**
     * The compression algorithm used to compress data. Default: "SNAPPY"; must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "ZSTD"]
     */
    compressionCodec?: pulumi.Input<string>;
    /**
     * Default: "Parquet"; must be "Parquet"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationAwsDatalakeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationAwsDatalakeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationAwsDatalakeResourceAllocationJobSpecific>[]>;
}

export interface DestinationAwsDatalakeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationAwsDatalakeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationAwsDatalakeResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationAwsDatalakeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationAzureBlobStorageConfiguration {
    /**
     * The Azure blob storage account key. If you set this value, you must not set the Shared Access Signature.
     */
    azureBlobStorageAccountKey?: pulumi.Input<string>;
    /**
     * The name of the Azure Blob Storage Account. Read more <a href="https://learn.microsoft.com/en-gb/azure/storage/blobs/storage-blobs-introduction#storage-accounts">here</a>.
     */
    azureBlobStorageAccountName: pulumi.Input<string>;
    /**
     * The name of the Azure Blob Storage Container. Read more <a href="https://learn.microsoft.com/en-gb/azure/storage/blobs/storage-blobs-introduction#containers">here</a>.
     */
    azureBlobStorageContainerName: pulumi.Input<string>;
    /**
     * This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
     */
    azureBlobStorageEndpointDomainName?: pulumi.Input<string>;
    /**
     * The amount of megabytes after which the connector should spill the records in a new blob object. Make sure to configure size greater than individual records. Enter 0 if not applicable. Default: 500
     */
    azureBlobStorageSpillSize?: pulumi.Input<number>;
    /**
     * Format of the data output.
     */
    format: pulumi.Input<inputs.DestinationAzureBlobStorageConfigurationFormat>;
    /**
     * A shared access signature (SAS) provides secure delegated access to resources in your storage account. Read more <a href="https://learn.microsoft.com/en-gb/azure/storage/common/storage-sas-overview?toc=%2Fazure%2Fstorage%2Fblobs%2Ftoc.json&bc=%2Fazure%2Fstorage%2Fblobs%2Fbreadcrumb%2Ftoc.json">here</a>. If you set this value, you must not set the account key.
     */
    sharedAccessSignature?: pulumi.Input<string>;
}

export interface DestinationAzureBlobStorageConfigurationFormat {
    csvCommaSeparatedValues?: pulumi.Input<inputs.DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValues>;
    jsonLinesNewlineDelimitedJson?: pulumi.Input<inputs.DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJson>;
}

export interface DestinationAzureBlobStorageConfigurationFormatCsvCommaSeparatedValues {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "No flattening"; must be one of ["No flattening", "Root level flattening"]
     */
    flattening?: pulumi.Input<string>;
    /**
     * Default: "CSV"; must be "CSV"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationAzureBlobStorageConfigurationFormatJsonLinesNewlineDelimitedJson {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "No flattening"; must be one of ["No flattening", "Root level flattening"]
     */
    flattening?: pulumi.Input<string>;
    /**
     * Default: "JSONL"; must be "JSONL"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationAzureBlobStorageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationAzureBlobStorageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationAzureBlobStorageResourceAllocationJobSpecific>[]>;
}

export interface DestinationAzureBlobStorageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationAzureBlobStorageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationAzureBlobStorageResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationAzureBlobStorageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationBigqueryConfiguration {
    /**
     * Google BigQuery client's chunk (buffer) size (MIN=1, MAX = 15) for each table. The size that will be written by a single RPC. Written data will be buffered and only flushed upon reaching this size or closing the channel. The default 15MB value is used if not set explicitly. Read more <a href="https://googleapis.dev/python/bigquery/latest/generated/google.cloud.bigquery.client.Client.html">here</a>. Default: 15
     */
    bigQueryClientBufferSizeMb?: pulumi.Input<number>;
    /**
     * The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/bigquery#service-account-key">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson?: pulumi.Input<string>;
    /**
     * The default BigQuery Dataset ID that tables are replicated to if the source does not specify a namespace. Read more <a href="https://cloud.google.com/bigquery/docs/datasets#create-dataset">here</a>.
     */
    datasetId: pulumi.Input<string>;
    /**
     * The location of the dataset. Warning: Changes made after creation will not be applied. Read more <a href="https://cloud.google.com/bigquery/docs/locations">here</a>. must be one of ["US", "EU", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "europe-central1", "europe-central2", "europe-north1", "europe-north2", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "europe-west7", "europe-west8", "europe-west9", "europe-west12", "me-central1", "me-central2", "me-west1", "northamerica-northeast1", "northamerica-northeast2", "southamerica-east1", "southamerica-west1", "us-central1", "us-east1", "us-east2", "us-east3", "us-east4", "us-east5", "us-south1", "us-west1", "us-west2", "us-west3", "us-west4"]
     */
    datasetLocation: pulumi.Input<string>;
    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
     */
    disableTypeDedupe?: pulumi.Input<boolean>;
    /**
     * The way data will be uploaded to BigQuery.
     */
    loadingMethod?: pulumi.Input<inputs.DestinationBigqueryConfigurationLoadingMethod>;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset. Read more <a href="https://cloud.google.com/resource-manager/docs/creating-managing-projects#identifying_projects">here</a>.
     */
    projectId: pulumi.Input<string>;
    /**
     * The dataset to write raw tables into (default: airbyte_internal)
     */
    rawDataDataset?: pulumi.Input<string>;
    /**
     * Interactive run type means that the query is executed as soon as possible, and these queries count towards concurrent rate limit and daily limit. Read more about interactive run type <a href="https://cloud.google.com/bigquery/docs/running-queries#queries">here</a>. Batch queries are queued and started as soon as idle resources are available in the BigQuery shared resource pool, which usually occurs within a few minutes. Batch queries donâ€™t count towards your concurrent rate limit. Read more about batch queries <a href="https://cloud.google.com/bigquery/docs/running-queries#batch">here</a>. The default "interactive" value is used if not set explicitly. Default: "interactive"; must be one of ["interactive", "batch"]
     */
    transformationPriority?: pulumi.Input<string>;
}

export interface DestinationBigqueryConfigurationLoadingMethod {
    /**
     * Direct loading using batched SQL INSERT statements. This method uses the BigQuery driver to convert large INSERT statements into file uploads automatically.
     */
    batchedStandardInserts?: pulumi.Input<inputs.DestinationBigqueryConfigurationLoadingMethodBatchedStandardInserts>;
    /**
     * Writes large batches of records to a file, uploads the file to GCS, then uses COPY INTO to load your data into BigQuery.
     */
    gcsStaging?: pulumi.Input<inputs.DestinationBigqueryConfigurationLoadingMethodGcsStaging>;
}

export interface DestinationBigqueryConfigurationLoadingMethodBatchedStandardInserts {
}

export interface DestinationBigqueryConfigurationLoadingMethodGcsStaging {
    /**
     * An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
     */
    credential: pulumi.Input<inputs.DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential>;
    /**
     * The name of the GCS bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
     */
    gcsBucketName: pulumi.Input<string>;
    /**
     * Directory under the GCS bucket where data will be written.
     */
    gcsBucketPath: pulumi.Input<string>;
    /**
     * This upload method is supposed to temporary store records in GCS bucket. By this select you can chose if these records should be removed from GCS when migration has finished. The default "Delete all tmp files from GCS" value is used if not set explicitly. Default: "Delete all tmp files from GCS"; must be one of ["Delete all tmp files from GCS", "Keep all tmp files in GCS"]
     */
    keepFilesInGcsBucket?: pulumi.Input<string>;
}

export interface DestinationBigqueryConfigurationLoadingMethodGcsStagingCredential {
    hmacKey?: pulumi.Input<inputs.DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey>;
}

export interface DestinationBigqueryConfigurationLoadingMethodGcsStagingCredentialHmacKey {
    /**
     * HMAC key access ID. When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long.
     */
    hmacKeyAccessId: pulumi.Input<string>;
    /**
     * The corresponding secret for the access ID. It is a 40-character base-64 encoded string.
     */
    hmacKeySecret: pulumi.Input<string>;
}

export interface DestinationBigqueryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationBigqueryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationBigqueryResourceAllocationJobSpecific>[]>;
}

export interface DestinationBigqueryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationBigqueryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationBigqueryResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationBigqueryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationClickhouseConfiguration {
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * HTTP port of the database. Default: 8123
     */
    port?: pulumi.Input<number>;
    /**
     * The schema to write raw tables into (default: airbyte_internal)
     */
    rawDataSchema?: pulumi.Input<string>;
    /**
     * Encrypt data using SSL. Default: false
     */
    ssl?: pulumi.Input<boolean>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationClickhouseConfigurationTunnelMethod>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationClickhouseConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationClickhouseConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationClickhouseConfigurationTunnelMethodNoTunnel {
}

export interface DestinationClickhouseConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationClickhouseConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationClickhouseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationClickhouseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationClickhouseResourceAllocationJobSpecific>[]>;
}

export interface DestinationClickhouseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationClickhouseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationClickhouseResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationClickhouseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationCobraConfiguration {
    /**
     * Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>
     */
    clientId: pulumi.Input<string>;
    /**
     * Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>. Default: false
     */
    isSandbox?: pulumi.Input<boolean>;
    /**
     * If enabled, the records content will be printed as part of the log in case of failure which allows for easier debugging. Default: false
     */
    printRecordContentOnError?: pulumi.Input<boolean>;
    /**
     * Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
     */
    refreshToken: pulumi.Input<string>;
    streamMappings?: pulumi.Input<pulumi.Input<inputs.DestinationCobraConfigurationStreamMapping>[]>;
    /**
     * The order in which the streams should be synced. Streams are synced in the order they are listed. Only those streams will be synced so make sure all the input streams are configured here.
     */
    streamOrders?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationCobraConfigurationStreamMapping {
    /**
     * The name for the table to update the data in the destination.
     */
    destinationTable: pulumi.Input<string>;
    /**
     * The name for the input stream.
     */
    sourceStream: pulumi.Input<string>;
    /**
     * How to update the data in the destination. must be one of ["INSERT", "UPDATE", "UPSERT", "DELETE"]
     */
    updateMode: pulumi.Input<string>;
    /**
     * Given the operation is an upsert, a field representing an external ID needs to be provided
     */
    upsertKey?: pulumi.Input<string>;
}

export interface DestinationCobraResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationCobraResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationCobraResourceAllocationJobSpecific>[]>;
}

export interface DestinationCobraResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationCobraResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationCobraResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationCobraResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationConvexConfiguration {
    /**
     * API access key used to send data to a Convex deployment.
     */
    accessKey: pulumi.Input<string>;
    /**
     * URL of the Convex deployment that is the destination
     */
    deploymentUrl: pulumi.Input<string>;
}

export interface DestinationConvexResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationConvexResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationConvexResourceAllocationJobSpecific>[]>;
}

export interface DestinationConvexResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationConvexResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationConvexResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationConvexResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationCustomResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationCustomResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationCustomResourceAllocationJobSpecific>[]>;
}

export interface DestinationCustomResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationCustomResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationCustomResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationCustomResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDatabricksConfiguration {
    /**
     * You must agree to the Databricks JDBC Driver <a href="https://databricks.com/jdbc-odbc-driver-license">Terms & Conditions</a> to use this connector. Default: false
     */
    acceptTerms?: pulumi.Input<boolean>;
    /**
     * Authentication mechanism for Staging files and running queries
     */
    authentication: pulumi.Input<inputs.DestinationDatabricksConfigurationAuthentication>;
    /**
     * The name of the unity catalog for the database
     */
    database: pulumi.Input<string>;
    /**
     * Databricks Cluster Server Hostname.
     */
    hostname: pulumi.Input<string>;
    /**
     * Databricks Cluster HTTP Path.
     */
    httpPath: pulumi.Input<string>;
    /**
     * Databricks Cluster Port. Default: "443"
     */
    port?: pulumi.Input<string>;
    /**
     * Default to 'true'. Switch it to 'false' for debugging purpose. Default: true
     */
    purgeStagingData?: pulumi.Input<boolean>;
    /**
     * The schema to write raw tables into (default: airbyte_internal). Default: "airbyte_internal"
     */
    rawSchemaOverride?: pulumi.Input<string>;
    /**
     * The default schema tables are written. If not specified otherwise, the "default" will be used. Default: "default"
     */
    schema?: pulumi.Input<string>;
}

export interface DestinationDatabricksConfigurationAuthentication {
    oAuth2Recommended?: pulumi.Input<inputs.DestinationDatabricksConfigurationAuthenticationOAuth2Recommended>;
    personalAccessToken?: pulumi.Input<inputs.DestinationDatabricksConfigurationAuthenticationPersonalAccessToken>;
}

export interface DestinationDatabricksConfigurationAuthenticationOAuth2Recommended {
    clientId: pulumi.Input<string>;
    secret: pulumi.Input<string>;
}

export interface DestinationDatabricksConfigurationAuthenticationPersonalAccessToken {
    personalAccessToken: pulumi.Input<string>;
}

export interface DestinationDatabricksResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationDatabricksResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationDatabricksResourceAllocationJobSpecific>[]>;
}

export interface DestinationDatabricksResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDatabricksResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationDatabricksResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationDatabricksResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDeepsetConfiguration {
    /**
     * Your deepset cloud API key
     */
    apiKey: pulumi.Input<string>;
    /**
     * URL of deepset Cloud API (e.g. https://api.cloud.deepset.ai, https://api.us.deepset.ai, etc). Defaults to https://api.cloud.deepset.ai. Default: "https://api.cloud.deepset.ai"
     */
    baseUrl?: pulumi.Input<string>;
    /**
     * Number of times to retry an action before giving up. Default: 5
     */
    retries?: pulumi.Input<number>;
    /**
     * Name of workspace to which to sync the data.
     */
    workspace: pulumi.Input<string>;
}

export interface DestinationDeepsetResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationDeepsetResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationDeepsetResourceAllocationJobSpecific>[]>;
}

export interface DestinationDeepsetResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDeepsetResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationDeepsetResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationDeepsetResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDevNullConfiguration {
    /**
     * The type of destination to be used
     */
    testDestination: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestination>;
}

export interface DestinationDevNullConfigurationTestDestination {
    failing?: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationFailing>;
    logging?: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationLogging>;
    silent?: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationSilent>;
    throttled?: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationThrottled>;
}

export interface DestinationDevNullConfigurationTestDestinationFailing {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Number of messages after which to fail.
     */
    numMessages: pulumi.Input<number>;
    /**
     * Default: "FAILING"; must be "FAILING"
     */
    testDestinationType?: pulumi.Input<string>;
}

export interface DestinationDevNullConfigurationTestDestinationLogging {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Configurate how the messages are logged.
     */
    loggingConfig: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationLoggingLoggingConfig>;
    /**
     * Default: "LOGGING"; must be "LOGGING"
     */
    testDestinationType?: pulumi.Input<string>;
}

export interface DestinationDevNullConfigurationTestDestinationLoggingLoggingConfig {
    /**
     * For each stream, log every N-th entry with a maximum cap.
     */
    everyNThEntry?: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationLoggingLoggingConfigEveryNThEntry>;
    /**
     * Log first N entries per stream.
     */
    firstNEntries?: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationLoggingLoggingConfigFirstNEntries>;
    /**
     * For each stream, randomly log a percentage of the entries with a maximum cap.
     */
    randomSampling?: pulumi.Input<inputs.DestinationDevNullConfigurationTestDestinationLoggingLoggingConfigRandomSampling>;
}

export interface DestinationDevNullConfigurationTestDestinationLoggingLoggingConfigEveryNThEntry {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "EveryNth"; must be "EveryNth"
     */
    loggingType?: pulumi.Input<string>;
    /**
     * Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries. Default: 100
     */
    maxEntryCount?: pulumi.Input<number>;
    /**
     * The N-th entry to log for each stream. N starts from 1. For example, when N = 1, every entry is logged; when N = 2, every other entry is logged; when N = 3, one out of three entries is logged.
     */
    nthEntryToLog: pulumi.Input<number>;
}

export interface DestinationDevNullConfigurationTestDestinationLoggingLoggingConfigFirstNEntries {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "FirstN"; must be "FirstN"
     */
    loggingType?: pulumi.Input<string>;
    /**
     * Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries. Default: 100
     */
    maxEntryCount?: pulumi.Input<number>;
}

export interface DestinationDevNullConfigurationTestDestinationLoggingLoggingConfigRandomSampling {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "RandomSampling"; must be "RandomSampling"
     */
    loggingType?: pulumi.Input<string>;
    /**
     * Number of entries to log. This destination is for testing only. So it won't make sense to log infinitely. The maximum is 1,000 entries. Default: 100
     */
    maxEntryCount?: pulumi.Input<number>;
    /**
     * A positive floating number smaller than 1. Default: 0.001
     */
    samplingRatio?: pulumi.Input<number>;
    /**
     * When the seed is unspecified, the current time millis will be used as the seed.
     */
    seed?: pulumi.Input<number>;
}

export interface DestinationDevNullConfigurationTestDestinationSilent {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "SILENT"; must be "SILENT"
     */
    testDestinationType?: pulumi.Input<string>;
}

export interface DestinationDevNullConfigurationTestDestinationThrottled {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The number of milliseconds to wait between each record.
     */
    millisPerRecord: pulumi.Input<number>;
    /**
     * Default: "THROTTLED"; must be "THROTTLED"
     */
    testDestinationType?: pulumi.Input<string>;
}

export interface DestinationDevNullResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationDevNullResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationDevNullResourceAllocationJobSpecific>[]>;
}

export interface DestinationDevNullResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDevNullResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationDevNullResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationDevNullResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDuckdbConfiguration {
    /**
     * Path to the .duckdb file, or the text 'md:' to connect to MotherDuck. The file will be placed inside that local mount. For more information check out our <a href="https://docs.airbyte.io/integrations/destinations/duckdb">docs</a>
     */
    destinationPath: pulumi.Input<string>;
    /**
     * API key to use for authentication to a MotherDuck database.
     */
    motherduckApiKey?: pulumi.Input<string>;
    /**
     * Database schema name, default for duckdb is 'main'.
     */
    schema?: pulumi.Input<string>;
}

export interface DestinationDuckdbResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationDuckdbResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationDuckdbResourceAllocationJobSpecific>[]>;
}

export interface DestinationDuckdbResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDuckdbResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationDuckdbResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationDuckdbResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDynamodbConfiguration {
    /**
     * The access key id to access the DynamoDB. Airbyte requires Read and Write permissions to the DynamoDB.
     */
    accessKeyId: pulumi.Input<string>;
    /**
     * This is your DynamoDB endpoint url.(if you are working with AWS DynamoDB, just leave empty). Default: ""
     */
    dynamodbEndpoint?: pulumi.Input<string>;
    /**
     * The region of the DynamoDB. Default: ""; must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
     */
    dynamodbRegion?: pulumi.Input<string>;
    /**
     * The prefix to use when naming DynamoDB tables.
     */
    dynamodbTableNamePrefix: pulumi.Input<string>;
    /**
     * The corresponding secret to the access key id.
     */
    secretAccessKey: pulumi.Input<string>;
}

export interface DestinationDynamodbResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationDynamodbResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationDynamodbResourceAllocationJobSpecific>[]>;
}

export interface DestinationDynamodbResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationDynamodbResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationDynamodbResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationDynamodbResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationElasticsearchConfiguration {
    /**
     * The type of authentication to be used
     */
    authenticationMethod?: pulumi.Input<inputs.DestinationElasticsearchConfigurationAuthenticationMethod>;
    /**
     * CA certificate
     */
    caCertificate?: pulumi.Input<string>;
    /**
     * The full url of the Elasticsearch server
     */
    endpoint: pulumi.Input<string>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationElasticsearchConfigurationTunnelMethod>;
    /**
     * If a primary key identifier is defined in the source, an upsert will be performed using the primary key value as the elasticsearch doc id. Does not support composite primary keys. Default: true
     */
    upsert?: pulumi.Input<boolean>;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethod {
    /**
     * Use a api key and secret combination to authenticate
     */
    apiKeySecret?: pulumi.Input<inputs.DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret>;
    /**
     * No authentication will be used
     */
    none?: pulumi.Input<inputs.DestinationElasticsearchConfigurationAuthenticationMethodNone>;
    /**
     * Basic auth header with a username and password
     */
    usernamePassword?: pulumi.Input<inputs.DestinationElasticsearchConfigurationAuthenticationMethodUsernamePassword>;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethodApiKeySecret {
    /**
     * The Key ID to used when accessing an enterprise Elasticsearch instance.
     */
    apiKeyId: pulumi.Input<string>;
    /**
     * The secret associated with the API Key ID.
     */
    apiKeySecret: pulumi.Input<string>;
}

export interface DestinationElasticsearchConfigurationAuthenticationMethodNone {
}

export interface DestinationElasticsearchConfigurationAuthenticationMethodUsernamePassword {
    /**
     * Basic auth password to access a secure Elasticsearch server
     */
    password: pulumi.Input<string>;
    /**
     * Basic auth username to access a secure Elasticsearch server
     */
    username: pulumi.Input<string>;
}

export interface DestinationElasticsearchConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationElasticsearchConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationElasticsearchConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationElasticsearchConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationElasticsearchConfigurationTunnelMethodNoTunnel {
}

export interface DestinationElasticsearchConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationElasticsearchConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationElasticsearchResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationElasticsearchResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationElasticsearchResourceAllocationJobSpecific>[]>;
}

export interface DestinationElasticsearchResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationElasticsearchResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationElasticsearchResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationElasticsearchResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationFireboltConfiguration {
    /**
     * Firebolt account to login.
     */
    account: pulumi.Input<string>;
    /**
     * Firebolt service account ID.
     */
    clientId: pulumi.Input<string>;
    /**
     * Firebolt secret, corresponding to the service account ID.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The database to connect to.
     */
    database: pulumi.Input<string>;
    /**
     * Engine name to connect to.
     */
    engine: pulumi.Input<string>;
    /**
     * The host name of your Firebolt database.
     */
    host?: pulumi.Input<string>;
    /**
     * Loading method used to select the way data will be uploaded to Firebolt
     */
    loadingMethod?: pulumi.Input<inputs.DestinationFireboltConfigurationLoadingMethod>;
}

export interface DestinationFireboltConfigurationLoadingMethod {
    externalTableViaS3?: pulumi.Input<inputs.DestinationFireboltConfigurationLoadingMethodExternalTableViaS3>;
    sqlInserts?: pulumi.Input<inputs.DestinationFireboltConfigurationLoadingMethodSqlInserts>;
}

export interface DestinationFireboltConfigurationLoadingMethodExternalTableViaS3 {
    /**
     * AWS access key granting read and write access to S3.
     */
    awsKeyId: pulumi.Input<string>;
    /**
     * Corresponding secret part of the AWS Key
     */
    awsKeySecret: pulumi.Input<string>;
    /**
     * The name of the S3 bucket.
     */
    s3Bucket: pulumi.Input<string>;
    /**
     * Region name of the S3 bucket.
     */
    s3Region: pulumi.Input<string>;
}

export interface DestinationFireboltConfigurationLoadingMethodSqlInserts {
}

export interface DestinationFireboltResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationFireboltResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationFireboltResourceAllocationJobSpecific>[]>;
}

export interface DestinationFireboltResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationFireboltResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationFireboltResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationFireboltResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationFirestoreConfiguration {
    /**
     * The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/firestore">docs</a> if you need help generating this key. Default credentials will be used if this field is left empty.
     */
    credentialsJson?: pulumi.Input<string>;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset.
     */
    projectId: pulumi.Input<string>;
}

export interface DestinationFirestoreResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationFirestoreResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationFirestoreResourceAllocationJobSpecific>[]>;
}

export interface DestinationFirestoreResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationFirestoreResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationFirestoreResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationFirestoreResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationGcsConfiguration {
    /**
     * An HMAC key is a type of credential and can be associated with a service account or a user account in Cloud Storage. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys">here</a>.
     */
    credential: pulumi.Input<inputs.DestinationGcsConfigurationCredential>;
    /**
     * Output data format. One of the following formats must be selected - <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-avro#advantages_of_avro">AVRO</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-parquet#parquet_schemas">PARQUET</a> format, <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-csv#loading_csv_data_into_a_table">CSV</a> format, or <a href="https://cloud.google.com/bigquery/docs/loading-data-cloud-storage-json#loading_json_data_into_a_new_table">JSONL</a> format.
     */
    format: pulumi.Input<inputs.DestinationGcsConfigurationFormat>;
    /**
     * You can find the bucket name in the App Engine Admin console Application Settings page, under the label Google Cloud Storage Bucket. Read more <a href="https://cloud.google.com/storage/docs/naming-buckets">here</a>.
     */
    gcsBucketName: pulumi.Input<string>;
    /**
     * GCS Bucket Path string Subdirectory under the above bucket to sync the data into.
     */
    gcsBucketPath: pulumi.Input<string>;
    /**
     * Select a Region of the GCS Bucket. Read more <a href="https://cloud.google.com/storage/docs/locations">here</a>. Default: "us"; must be one of ["northamerica-northeast1", "northamerica-northeast2", "us-central1", "us-east1", "us-east4", "us-west1", "us-west2", "us-west3", "us-west4", "southamerica-east1", "southamerica-west1", "europe-central2", "europe-north1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west6", "asia-east1", "asia-east2", "asia-northeast1", "asia-northeast2", "asia-northeast3", "asia-south1", "asia-south2", "asia-southeast1", "asia-southeast2", "australia-southeast1", "australia-southeast2", "asia", "eu", "us", "asia1", "eur4", "nam4"]
     */
    gcsBucketRegion?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationCredential {
    hmacKey?: pulumi.Input<inputs.DestinationGcsConfigurationCredentialHmacKey>;
}

export interface DestinationGcsConfigurationCredentialHmacKey {
    /**
     * Default: "HMAC_KEY"; must be "HMAC_KEY"
     */
    credentialType?: pulumi.Input<string>;
    /**
     * When linked to a service account, this ID is 61 characters long; when linked to a user account, it is 24 characters long. Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#overview">here</a>.
     */
    hmacKeyAccessId: pulumi.Input<string>;
    /**
     * The corresponding secret for the access ID. It is a 40-character base-64 encoded string.  Read more <a href="https://cloud.google.com/storage/docs/authentication/hmackeys#secrets">here</a>.
     */
    hmacKeySecret: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormat {
    avroApacheAvro?: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvro>;
    csvCommaSeparatedValues?: pulumi.Input<inputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValues>;
    jsonLinesNewlineDelimitedJson?: pulumi.Input<inputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson>;
    parquetColumnarStorage?: pulumi.Input<inputs.DestinationGcsConfigurationFormatParquetColumnarStorage>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvro {
    /**
     * The compression algorithm used to compress data. Default to no compression.
     */
    compressionCodec: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec>;
    /**
     * Default: "Avro"; must be "Avro"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodec {
    bzip2?: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2>;
    deflate?: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate>;
    noCompression?: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompression>;
    snappy?: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappy>;
    xz?: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz>;
    zstandard?: pulumi.Input<inputs.DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecBzip2 {
    /**
     * Default: "bzip2"; must be "bzip2"
     */
    codec?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecDeflate {
    /**
     * Default: "Deflate"; must be "Deflate"
     */
    codec?: pulumi.Input<string>;
    /**
     * 0: no compression & fastest, 9: best compression & slowest. Default: 0
     */
    compressionLevel?: pulumi.Input<number>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecNoCompression {
    /**
     * Default: "no compression"; must be "no compression"
     */
    codec?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecSnappy {
    /**
     * Default: "snappy"; must be "snappy"
     */
    codec?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecXz {
    /**
     * Default: "xz"; must be "xz"
     */
    codec?: pulumi.Input<string>;
    /**
     * The presets 0-3 are fast presets with medium compression. The presets 4-6 are fairly slow presets with high compression. The default preset is 6. The presets 7-9 are like the preset 6 but use bigger dictionaries and have higher compressor and decompressor memory requirements. Unless the uncompressed size of the file exceeds 8 MiB, 16 MiB, or 32 MiB, it is waste of memory to use the presets 7, 8, or 9, respectively. Read more <a href="https://commons.apache.org/proper/commons-compress/apidocs/org/apache/commons/compress/compressors/xz/XZCompressorOutputStream.html#XZCompressorOutputStream-java.io.OutputStream-int-">here</a> for details. Default: 6
     */
    compressionLevel?: pulumi.Input<number>;
}

export interface DestinationGcsConfigurationFormatAvroApacheAvroCompressionCodecZstandard {
    /**
     * Default: "zstandard"; must be "zstandard"
     */
    codec?: pulumi.Input<string>;
    /**
     * Negative levels are 'fast' modes akin to lz4 or snappy, levels above 9 are generally for archival purposes, and levels above 18 use a lot of memory. Default: 3
     */
    compressionLevel?: pulumi.Input<number>;
    /**
     * If true, include a checksum with each data block. Default: false
     */
    includeChecksum?: pulumi.Input<boolean>;
}

export interface DestinationGcsConfigurationFormatCsvCommaSeparatedValues {
    /**
     * Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".csv.gz").
     */
    compression?: pulumi.Input<inputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression>;
    /**
     * Whether the input JSON data should be normalized (flattened) in the output CSV. Please refer to docs for details. Default: "No flattening"; must be one of ["No flattening", "Root level flattening"]
     */
    flattening?: pulumi.Input<string>;
    /**
     * Default: "CSV"; must be "CSV"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompression {
    gzip?: pulumi.Input<inputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip>;
    noCompression?: pulumi.Input<inputs.DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression>;
}

export interface DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionGzip {
    /**
     * Default: "GZIP"; must be "GZIP"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression {
    /**
     * Default: "No Compression"; must be "No Compression"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJson {
    /**
     * Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
     */
    compression?: pulumi.Input<inputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression>;
    /**
     * Default: "JSONL"; must be "JSONL"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompression {
    gzip?: pulumi.Input<inputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip>;
    noCompression?: pulumi.Input<inputs.DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression>;
}

export interface DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    /**
     * Default: "GZIP"; must be "GZIP"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    /**
     * Default: "No Compression"; must be "No Compression"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationGcsConfigurationFormatParquetColumnarStorage {
    /**
     * This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
     */
    blockSizeMb?: pulumi.Input<number>;
    /**
     * The compression algorithm used to compress data pages. Default: "UNCOMPRESSED"; must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]
     */
    compressionCodec?: pulumi.Input<string>;
    /**
     * Default: true. Default: true
     */
    dictionaryEncoding?: pulumi.Input<boolean>;
    /**
     * There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
     */
    dictionaryPageSizeKb?: pulumi.Input<number>;
    /**
     * Default: "Parquet"; must be "Parquet"
     */
    formatType?: pulumi.Input<string>;
    /**
     * Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
     */
    maxPaddingSizeMb?: pulumi.Input<number>;
    /**
     * The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
     */
    pageSizeKb?: pulumi.Input<number>;
}

export interface DestinationGcsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationGcsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationGcsResourceAllocationJobSpecific>[]>;
}

export interface DestinationGcsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationGcsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationGcsResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationGcsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationGoogleSheetsConfiguration {
    /**
     * Authentication method to access Google Sheets
     */
    credentials: pulumi.Input<inputs.DestinationGoogleSheetsConfigurationCredentials>;
    /**
     * The link to your spreadsheet. See <a href='https://docs.airbyte.com/integrations/destinations/google-sheets#sheetlink'>this guide</a> for more details.
     */
    spreadsheetId: pulumi.Input<string>;
}

export interface DestinationGoogleSheetsConfigurationCredentials {
    authenticateViaGoogleOAuth?: pulumi.Input<inputs.DestinationGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth>;
    serviceAccountKeyAuthentication?: pulumi.Input<inputs.DestinationGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication>;
}

export interface DestinationGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth {
    /**
     * The Client ID of your Google Sheets developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Google Sheets developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The token for obtaining new access token.
     */
    refreshToken: pulumi.Input<string>;
}

export interface DestinationGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication {
    /**
     * Enter your service account key in JSON format. See the <a href='https://docs.airbyte.com/integrations/destinations/google-sheets#service-account'>docs</a> for more information on how to generate this key.
     */
    serviceAccountInfo: pulumi.Input<string>;
}

export interface DestinationGoogleSheetsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationGoogleSheetsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationGoogleSheetsResourceAllocationJobSpecific>[]>;
}

export interface DestinationGoogleSheetsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationGoogleSheetsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationGoogleSheetsResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationGoogleSheetsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMilvusConfiguration {
    /**
     * Embedding configuration
     */
    embedding: pulumi.Input<inputs.DestinationMilvusConfigurationEmbedding>;
    /**
     * Indexing configuration
     */
    indexing: pulumi.Input<inputs.DestinationMilvusConfigurationIndexing>;
    /**
     * Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
     */
    omitRawText?: pulumi.Input<boolean>;
    processing: pulumi.Input<inputs.DestinationMilvusConfigurationProcessing>;
}

export interface DestinationMilvusConfigurationEmbedding {
    /**
     * Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    azureOpenAi?: pulumi.Input<inputs.DestinationMilvusConfigurationEmbeddingAzureOpenAi>;
    /**
     * Use the Cohere API to embed text.
     */
    cohere?: pulumi.Input<inputs.DestinationMilvusConfigurationEmbeddingCohere>;
    /**
     * Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
     */
    fake?: pulumi.Input<inputs.DestinationMilvusConfigurationEmbeddingFake>;
    /**
     * Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    openAi?: pulumi.Input<inputs.DestinationMilvusConfigurationEmbeddingOpenAi>;
    /**
     * Use a service that's compatible with the OpenAI API to embed text.
     */
    openAiCompatible?: pulumi.Input<inputs.DestinationMilvusConfigurationEmbeddingOpenAiCompatible>;
}

export interface DestinationMilvusConfigurationEmbeddingAzureOpenAi {
    /**
     * The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    apiBase: pulumi.Input<string>;
    /**
     * The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    deployment: pulumi.Input<string>;
    /**
     * The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    openaiKey: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationEmbeddingCohere {
    cohereKey: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationEmbeddingFake {
}

export interface DestinationMilvusConfigurationEmbeddingOpenAi {
    openaiKey: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationEmbeddingOpenAiCompatible {
    /**
     * Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The base URL for your OpenAI-compatible service
     */
    baseUrl: pulumi.Input<string>;
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * The name of the model to use for embedding. Default: "text-embedding-ada-002"
     */
    modelName?: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationIndexing {
    /**
     * Authentication method
     */
    auth: pulumi.Input<inputs.DestinationMilvusConfigurationIndexingAuth>;
    /**
     * The collection to load data into
     */
    collection: pulumi.Input<string>;
    /**
     * The database to connect to. Default: ""
     */
    db?: pulumi.Input<string>;
    /**
     * The public endpoint of the Milvus instance.
     */
    host: pulumi.Input<string>;
    /**
     * The field in the entity that contains the embedded text. Default: "text"
     */
    textField?: pulumi.Input<string>;
    /**
     * The field in the entity that contains the vector. Default: "vector"
     */
    vectorField?: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationIndexingAuth {
    /**
     * Authenticate using an API token (suitable for Zilliz Cloud)
     */
    apiToken?: pulumi.Input<inputs.DestinationMilvusConfigurationIndexingAuthApiToken>;
    /**
     * Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
     */
    noAuth?: pulumi.Input<inputs.DestinationMilvusConfigurationIndexingAuthNoAuth>;
    /**
     * Authenticate using username and password (suitable for self-managed Milvus clusters)
     */
    usernamePassword?: pulumi.Input<inputs.DestinationMilvusConfigurationIndexingAuthUsernamePassword>;
}

export interface DestinationMilvusConfigurationIndexingAuthApiToken {
    /**
     * API Token for the Milvus instance
     */
    token: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationIndexingAuthNoAuth {
}

export interface DestinationMilvusConfigurationIndexingAuthUsernamePassword {
    /**
     * Password for the Milvus instance
     */
    password: pulumi.Input<string>;
    /**
     * Username for the Milvus instance
     */
    username: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationProcessing {
    /**
     * Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
     */
    chunkOverlap?: pulumi.Input<number>;
    /**
     * Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
     */
    chunkSize: pulumi.Input<number>;
    /**
     * List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
     */
    fieldNameMappings?: pulumi.Input<pulumi.Input<inputs.DestinationMilvusConfigurationProcessingFieldNameMapping>[]>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Split text fields into chunks based on the specified method.
     */
    textSplitter?: pulumi.Input<inputs.DestinationMilvusConfigurationProcessingTextSplitter>;
}

export interface DestinationMilvusConfigurationProcessingFieldNameMapping {
    /**
     * The field name in the source
     */
    fromField: pulumi.Input<string>;
    /**
     * The field name to use in the destination
     */
    toField: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationProcessingTextSplitter {
    /**
     * Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
     */
    byMarkdownHeader?: pulumi.Input<inputs.DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader>;
    /**
     * Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
     */
    byProgrammingLanguage?: pulumi.Input<inputs.DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguage>;
    /**
     * Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
     */
    bySeparator?: pulumi.Input<inputs.DestinationMilvusConfigurationProcessingTextSplitterBySeparator>;
}

export interface DestinationMilvusConfigurationProcessingTextSplitterByMarkdownHeader {
    /**
     * Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
     */
    splitLevel?: pulumi.Input<number>;
}

export interface DestinationMilvusConfigurationProcessingTextSplitterByProgrammingLanguage {
    /**
     * Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
     */
    language: pulumi.Input<string>;
}

export interface DestinationMilvusConfigurationProcessingTextSplitterBySeparator {
    /**
     * Whether to keep the separator in the resulting chunks. Default: false
     */
    keepSeparator?: pulumi.Input<boolean>;
    /**
     * List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
     */
    separators?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationMilvusResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationMilvusResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationMilvusResourceAllocationJobSpecific>[]>;
}

export interface DestinationMilvusResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMilvusResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationMilvusResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationMilvusResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMongodbConfiguration {
    /**
     * Authorization type.
     */
    authType: pulumi.Input<inputs.DestinationMongodbConfigurationAuthType>;
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * MongoDb instance to connect to. For MongoDB Atlas and Replica Set TLS connection is used by default.
     */
    instanceType?: pulumi.Input<inputs.DestinationMongodbConfigurationInstanceType>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationMongodbConfigurationTunnelMethod>;
}

export interface DestinationMongodbConfigurationAuthType {
    /**
     * Login/Password.
     */
    loginPassword?: pulumi.Input<inputs.DestinationMongodbConfigurationAuthTypeLoginPassword>;
    /**
     * None.
     */
    none?: pulumi.Input<inputs.DestinationMongodbConfigurationAuthTypeNone>;
}

export interface DestinationMongodbConfigurationAuthTypeLoginPassword {
    /**
     * Password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationMongodbConfigurationAuthTypeNone {
}

export interface DestinationMongodbConfigurationInstanceType {
    mongoDbAtlas?: pulumi.Input<inputs.DestinationMongodbConfigurationInstanceTypeMongoDbAtlas>;
    replicaSet?: pulumi.Input<inputs.DestinationMongodbConfigurationInstanceTypeReplicaSet>;
    standaloneMongoDbInstance?: pulumi.Input<inputs.DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstance>;
}

export interface DestinationMongodbConfigurationInstanceTypeMongoDbAtlas {
    /**
     * URL of a cluster to connect to.
     */
    clusterUrl: pulumi.Input<string>;
    /**
     * Default: "atlas"; must be "atlas"
     */
    instance?: pulumi.Input<string>;
}

export interface DestinationMongodbConfigurationInstanceTypeReplicaSet {
    /**
     * Default: "replica"; must be "replica"
     */
    instance?: pulumi.Input<string>;
    /**
     * A replica set name.
     */
    replicaSet?: pulumi.Input<string>;
    /**
     * The members of a replica set. Please specify `host`:`port` of each member seperated by comma.
     */
    serverAddresses: pulumi.Input<string>;
}

export interface DestinationMongodbConfigurationInstanceTypeStandaloneMongoDbInstance {
    /**
     * The Host of a Mongo database to be replicated.
     */
    host: pulumi.Input<string>;
    /**
     * Default: "standalone"; must be "standalone"
     */
    instance?: pulumi.Input<string>;
    /**
     * The Port of a Mongo database to be replicated. Default: 27017
     */
    port?: pulumi.Input<number>;
    /**
     * Indicates whether TLS encryption protocol will be used to connect to MongoDB. It is recommended to use TLS connection if possible. For more information see <a href="https://docs.airbyte.com/integrations/sources/mongodb-v2">documentation</a>. Default: false
     */
    tls?: pulumi.Input<boolean>;
}

export interface DestinationMongodbConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationMongodbConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationMongodbConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationMongodbConfigurationTunnelMethodNoTunnel {
}

export interface DestinationMongodbConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationMongodbConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationMongodbResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationMongodbResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationMongodbResourceAllocationJobSpecific>[]>;
}

export interface DestinationMongodbResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMongodbResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationMongodbResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationMongodbResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMotherduckConfiguration {
    /**
     * Path to a .duckdb file or 'md:<DATABASE_NAME>' to connect to a MotherDuck database. If 'md:' is specified without a database name, the default MotherDuck database name ('my_db') will be used. Default: "md:"
     */
    destinationPath?: pulumi.Input<string>;
    /**
     * API access token to use for authentication to a MotherDuck database.
     */
    motherduckApiKey: pulumi.Input<string>;
    /**
     * Database schema name, defaults to 'main' if not specified.
     */
    schema?: pulumi.Input<string>;
}

export interface DestinationMotherduckResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationMotherduckResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationMotherduckResourceAllocationJobSpecific>[]>;
}

export interface DestinationMotherduckResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMotherduckResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationMotherduckResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationMotherduckResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMssqlConfiguration {
    /**
     * The name of the MSSQL database.
     */
    database: pulumi.Input<string>;
    /**
     * The host name of the MSSQL database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Specifies the type of load mechanism (e.g., BULK, INSERT) and its associated configuration.
     */
    loadType: pulumi.Input<inputs.DestinationMssqlConfigurationLoadType>;
    /**
     * The password associated with this username.
     */
    password?: pulumi.Input<string>;
    /**
     * The port of the MSSQL database.
     */
    port: pulumi.Input<number>;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
     */
    schema?: pulumi.Input<string>;
    /**
     * The encryption method which is used to communicate with the database.
     */
    sslMethod: pulumi.Input<inputs.DestinationMssqlConfigurationSslMethod>;
    /**
     * The username which is used to access the database.
     */
    user: pulumi.Input<string>;
}

export interface DestinationMssqlConfigurationLoadType {
    /**
     * Configuration details for using the BULK loading mechanism.
     */
    bulkLoad?: pulumi.Input<inputs.DestinationMssqlConfigurationLoadTypeBulkLoad>;
    /**
     * Configuration details for using the INSERT loading mechanism.
     */
    insertLoad?: pulumi.Input<inputs.DestinationMssqlConfigurationLoadTypeInsertLoad>;
}

export interface DestinationMssqlConfigurationLoadTypeBulkLoad {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The Azure blob storage account key. Mutually exclusive with a Shared Access Signature
     */
    azureBlobStorageAccountKey?: pulumi.Input<string>;
    /**
     * The name of the Azure Blob Storage account. See: https://learn.microsoft.com/azure/storage/blobs/storage-blobs-introduction#storage-accounts
     */
    azureBlobStorageAccountName: pulumi.Input<string>;
    /**
     * The name of the Azure Blob Storage container. See: https://learn.microsoft.com/azure/storage/blobs/storage-blobs-introduction#containers
     */
    azureBlobStorageContainerName: pulumi.Input<string>;
    /**
     * Specifies the external data source name configured in MSSQL, which references the Azure Blob container. See: https://learn.microsoft.com/sql/t-sql/statements/bulk-insert-transact-sql
     */
    bulkLoadDataSource: pulumi.Input<string>;
    /**
     * When enabled, Airbyte will validate all values before loading them into the destination table. This provides stronger data integrity guarantees but may significantly impact performance. Default: false
     */
    bulkLoadValidateValuesPreLoad?: pulumi.Input<boolean>;
    /**
     * Default: "BULK"; must be "BULK"
     */
    loadType?: pulumi.Input<string>;
    /**
     * A shared access signature (SAS) provides secure delegated access to resources in your storage account. See: https://learn.microsoft.com/azure/storage/common/storage-sas-overview.Mutually exclusive with an account key
     */
    sharedAccessSignature?: pulumi.Input<string>;
}

export interface DestinationMssqlConfigurationLoadTypeInsertLoad {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "INSERT"; must be "INSERT"
     */
    loadType?: pulumi.Input<string>;
}

export interface DestinationMssqlConfigurationSslMethod {
    /**
     * Use the certificate provided by the server without verification. (For testing purposes only!)
     */
    encryptedTrustServerCertificate?: pulumi.Input<inputs.DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificate>;
    /**
     * Verify and use the certificate provided by the server.
     */
    encryptedVerifyCertificate?: pulumi.Input<inputs.DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate>;
    /**
     * The data transfer will not be encrypted.
     */
    unencrypted?: pulumi.Input<inputs.DestinationMssqlConfigurationSslMethodUnencrypted>;
}

export interface DestinationMssqlConfigurationSslMethodEncryptedTrustServerCertificate {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "encrypted_trust_server_certificate"; must be "encrypted_trust_server_certificate"
     */
    name?: pulumi.Input<string>;
}

export interface DestinationMssqlConfigurationSslMethodEncryptedVerifyCertificate {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Specifies the host name of the server. The value of this property must match the subject property of the certificate.
     */
    hostNameInCertificate?: pulumi.Input<string>;
    /**
     * Default: "encrypted_verify_certificate"; must be "encrypted_verify_certificate"
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the name of the trust store.
     */
    trustStoreName?: pulumi.Input<string>;
    /**
     * Specifies the password of the trust store.
     */
    trustStorePassword?: pulumi.Input<string>;
}

export interface DestinationMssqlConfigurationSslMethodUnencrypted {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "unencrypted"; must be "unencrypted"
     */
    name?: pulumi.Input<string>;
}

export interface DestinationMssqlResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationMssqlResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationMssqlResourceAllocationJobSpecific>[]>;
}

export interface DestinationMssqlResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMssqlResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationMssqlResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationMssqlResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMssqlV2Configuration {
    /**
     * The name of the MSSQL database.
     */
    database: pulumi.Input<string>;
    /**
     * The host name of the MSSQL database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Specifies the type of load mechanism (e.g., BULK, INSERT) and its associated configuration.
     */
    loadType: pulumi.Input<inputs.DestinationMssqlV2ConfigurationLoadType>;
    /**
     * The password associated with this username.
     */
    password?: pulumi.Input<string>;
    /**
     * The port of the MSSQL database.
     */
    port: pulumi.Input<number>;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
     */
    schema?: pulumi.Input<string>;
    /**
     * The encryption method which is used to communicate with the database.
     */
    sslMethod: pulumi.Input<inputs.DestinationMssqlV2ConfigurationSslMethod>;
    /**
     * The username which is used to access the database.
     */
    user: pulumi.Input<string>;
}

export interface DestinationMssqlV2ConfigurationLoadType {
    /**
     * Configuration details for using the BULK loading mechanism.
     */
    bulkLoad?: pulumi.Input<inputs.DestinationMssqlV2ConfigurationLoadTypeBulkLoad>;
    /**
     * Configuration details for using the INSERT loading mechanism.
     */
    insertLoad?: pulumi.Input<inputs.DestinationMssqlV2ConfigurationLoadTypeInsertLoad>;
}

export interface DestinationMssqlV2ConfigurationLoadTypeBulkLoad {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The name of the Azure Blob Storage account. See: https://learn.microsoft.com/azure/storage/blobs/storage-blobs-introduction#storage-accounts
     */
    azureBlobStorageAccountName: pulumi.Input<string>;
    /**
     * The name of the Azure Blob Storage container. See: https://learn.microsoft.com/azure/storage/blobs/storage-blobs-introduction#containers
     */
    azureBlobStorageContainerName: pulumi.Input<string>;
    /**
     * Specifies the external data source name configured in MSSQL, which references the Azure Blob container. See: https://learn.microsoft.com/sql/t-sql/statements/bulk-insert-transact-sql
     */
    bulkLoadDataSource: pulumi.Input<string>;
    /**
     * When enabled, Airbyte will validate all values before loading them into the destination table. This provides stronger data integrity guarantees but may significantly impact performance. Default: false
     */
    bulkLoadValidateValuesPreLoad?: pulumi.Input<boolean>;
    /**
     * Default: "BULK"; must be "BULK"
     */
    loadType?: pulumi.Input<string>;
    /**
     * A shared access signature (SAS) provides secure delegated access to resources in your storage account. See: https://learn.microsoft.com/azure/storage/common/storage-sas-overview
     */
    sharedAccessSignature: pulumi.Input<string>;
}

export interface DestinationMssqlV2ConfigurationLoadTypeInsertLoad {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "INSERT"; must be "INSERT"
     */
    loadType?: pulumi.Input<string>;
}

export interface DestinationMssqlV2ConfigurationSslMethod {
    /**
     * Use the certificate provided by the server without verification. (For testing purposes only!)
     */
    encryptedTrustServerCertificate?: pulumi.Input<inputs.DestinationMssqlV2ConfigurationSslMethodEncryptedTrustServerCertificate>;
    /**
     * Verify and use the certificate provided by the server.
     */
    encryptedVerifyCertificate?: pulumi.Input<inputs.DestinationMssqlV2ConfigurationSslMethodEncryptedVerifyCertificate>;
    /**
     * The data transfer will not be encrypted.
     */
    unencrypted?: pulumi.Input<inputs.DestinationMssqlV2ConfigurationSslMethodUnencrypted>;
}

export interface DestinationMssqlV2ConfigurationSslMethodEncryptedTrustServerCertificate {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "encrypted_trust_server_certificate"; must be "encrypted_trust_server_certificate"
     */
    name?: pulumi.Input<string>;
}

export interface DestinationMssqlV2ConfigurationSslMethodEncryptedVerifyCertificate {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Specifies the host name of the server. The value of this property must match the subject property of the certificate.
     */
    hostNameInCertificate?: pulumi.Input<string>;
    /**
     * Default: "encrypted_verify_certificate"; must be "encrypted_verify_certificate"
     */
    name?: pulumi.Input<string>;
    /**
     * Specifies the name of the trust store.
     */
    trustStoreName?: pulumi.Input<string>;
    /**
     * Specifies the password of the trust store.
     */
    trustStorePassword?: pulumi.Input<string>;
}

export interface DestinationMssqlV2ConfigurationSslMethodUnencrypted {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "unencrypted"; must be "unencrypted"
     */
    name?: pulumi.Input<string>;
}

export interface DestinationMssqlV2ResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationMssqlV2ResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationMssqlV2ResourceAllocationJobSpecific>[]>;
}

export interface DestinationMssqlV2ResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMssqlV2ResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationMssqlV2ResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationMssqlV2ResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMysqlConfiguration {
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
     */
    disableTypeDedupe?: pulumi.Input<boolean>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database. Default: 3306
     */
    port?: pulumi.Input<number>;
    /**
     * The database to write raw tables into
     */
    rawDataSchema?: pulumi.Input<string>;
    /**
     * Encrypt data using SSL. Default: true
     */
    ssl?: pulumi.Input<boolean>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationMysqlConfigurationTunnelMethod>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationMysqlConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationMysqlConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationMysqlConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationMysqlConfigurationTunnelMethodNoTunnel {
}

export interface DestinationMysqlConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationMysqlConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationMysqlResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationMysqlResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationMysqlResourceAllocationJobSpecific>[]>;
}

export interface DestinationMysqlResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationMysqlResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationMysqlResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationMysqlResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationOracleConfiguration {
    /**
     * The encryption method which is used when communicating with the database.
     */
    encryption?: pulumi.Input<inputs.DestinationOracleConfigurationEncryption>;
    /**
     * The hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * The port of the database. Default: 1521
     */
    port?: pulumi.Input<number>;
    /**
     * The schema to write raw tables into (default: airbyte_internal)
     */
    rawDataSchema?: pulumi.Input<string>;
    /**
     * The default schema is used as the target schema for all statements issued from the connection that do not explicitly specify a schema name. The usual value for this field is "airbyte".  In Oracle, schemas and users are the same thing, so the "user" parameter is used as the login credentials and this is used for the default Airbyte message schema. Default: "airbyte"
     */
    schema?: pulumi.Input<string>;
    /**
     * The System Identifier uniquely distinguishes the instance from any other instance on the same computer.
     */
    sid: pulumi.Input<string>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationOracleConfigurationTunnelMethod>;
    /**
     * The username to access the database. This user must have CREATE USER privileges in the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationOracleConfigurationEncryption {
    /**
     * The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
     */
    nativeNetworkEncryptionNne?: pulumi.Input<inputs.DestinationOracleConfigurationEncryptionNativeNetworkEncryptionNne>;
    /**
     * Verify and use the certificate provided by the server.
     */
    tlsEncryptedVerifyCertificate?: pulumi.Input<inputs.DestinationOracleConfigurationEncryptionTlsEncryptedVerifyCertificate>;
    /**
     * Data transfer will not be encrypted.
     */
    unencrypted?: pulumi.Input<inputs.DestinationOracleConfigurationEncryptionUnencrypted>;
}

export interface DestinationOracleConfigurationEncryptionNativeNetworkEncryptionNne {
    /**
     * This parameter defines the database encryption algorithm. Default: "AES256"; must be one of ["AES256", "RC4_56", "3DES168"]
     */
    encryptionAlgorithm?: pulumi.Input<string>;
}

export interface DestinationOracleConfigurationEncryptionTlsEncryptedVerifyCertificate {
    /**
     * Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
     */
    sslCertificate: pulumi.Input<string>;
}

export interface DestinationOracleConfigurationEncryptionUnencrypted {
}

export interface DestinationOracleConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationOracleConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationOracleConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationOracleConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationOracleConfigurationTunnelMethodNoTunnel {
}

export interface DestinationOracleConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationOracleConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationOracleResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationOracleResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationOracleResourceAllocationJobSpecific>[]>;
}

export interface DestinationOracleResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationOracleResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationOracleResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationOracleResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPgvectorConfiguration {
    /**
     * Embedding configuration
     */
    embedding: pulumi.Input<inputs.DestinationPgvectorConfigurationEmbedding>;
    /**
     * Postgres can be used to store vector data and retrieve embeddings.
     */
    indexing: pulumi.Input<inputs.DestinationPgvectorConfigurationIndexing>;
    /**
     * Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
     */
    omitRawText?: pulumi.Input<boolean>;
    processing: pulumi.Input<inputs.DestinationPgvectorConfigurationProcessing>;
}

export interface DestinationPgvectorConfigurationEmbedding {
    /**
     * Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    azureOpenAi?: pulumi.Input<inputs.DestinationPgvectorConfigurationEmbeddingAzureOpenAi>;
    /**
     * Use the Cohere API to embed text.
     */
    cohere?: pulumi.Input<inputs.DestinationPgvectorConfigurationEmbeddingCohere>;
    /**
     * Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
     */
    fake?: pulumi.Input<inputs.DestinationPgvectorConfigurationEmbeddingFake>;
    /**
     * Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    openAi?: pulumi.Input<inputs.DestinationPgvectorConfigurationEmbeddingOpenAi>;
    /**
     * Use a service that's compatible with the OpenAI API to embed text.
     */
    openAiCompatible?: pulumi.Input<inputs.DestinationPgvectorConfigurationEmbeddingOpenAiCompatible>;
}

export interface DestinationPgvectorConfigurationEmbeddingAzureOpenAi {
    /**
     * The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    apiBase: pulumi.Input<string>;
    /**
     * The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    deployment: pulumi.Input<string>;
    /**
     * The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    openaiKey: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationEmbeddingCohere {
    cohereKey: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationEmbeddingFake {
}

export interface DestinationPgvectorConfigurationEmbeddingOpenAi {
    openaiKey: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationEmbeddingOpenAiCompatible {
    /**
     * Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The base URL for your OpenAI-compatible service
     */
    baseUrl: pulumi.Input<string>;
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * The name of the model to use for embedding. Default: "text-embedding-ada-002"
     */
    modelName?: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationIndexing {
    credentials: pulumi.Input<inputs.DestinationPgvectorConfigurationIndexingCredentials>;
    /**
     * Enter the name of the database that you want to sync data into
     */
    database: pulumi.Input<string>;
    /**
     * Enter the name of the default schema. Default: "public"
     */
    defaultSchema?: pulumi.Input<string>;
    /**
     * Enter the account name you want to use to access the database.
     */
    host: pulumi.Input<string>;
    /**
     * Enter the port you want to use to access the database. Default: 5432
     */
    port?: pulumi.Input<number>;
    /**
     * Enter the name of the user you want to use to access the database
     */
    username: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationIndexingCredentials {
    /**
     * Enter the password you want to use to access the database
     */
    password: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationProcessing {
    /**
     * Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
     */
    chunkOverlap?: pulumi.Input<number>;
    /**
     * Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
     */
    chunkSize: pulumi.Input<number>;
    /**
     * List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
     */
    fieldNameMappings?: pulumi.Input<pulumi.Input<inputs.DestinationPgvectorConfigurationProcessingFieldNameMapping>[]>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Split text fields into chunks based on the specified method.
     */
    textSplitter?: pulumi.Input<inputs.DestinationPgvectorConfigurationProcessingTextSplitter>;
}

export interface DestinationPgvectorConfigurationProcessingFieldNameMapping {
    /**
     * The field name in the source
     */
    fromField: pulumi.Input<string>;
    /**
     * The field name to use in the destination
     */
    toField: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationProcessingTextSplitter {
    /**
     * Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
     */
    byMarkdownHeader?: pulumi.Input<inputs.DestinationPgvectorConfigurationProcessingTextSplitterByMarkdownHeader>;
    /**
     * Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
     */
    byProgrammingLanguage?: pulumi.Input<inputs.DestinationPgvectorConfigurationProcessingTextSplitterByProgrammingLanguage>;
    /**
     * Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
     */
    bySeparator?: pulumi.Input<inputs.DestinationPgvectorConfigurationProcessingTextSplitterBySeparator>;
}

export interface DestinationPgvectorConfigurationProcessingTextSplitterByMarkdownHeader {
    /**
     * Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
     */
    splitLevel?: pulumi.Input<number>;
}

export interface DestinationPgvectorConfigurationProcessingTextSplitterByProgrammingLanguage {
    /**
     * Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
     */
    language: pulumi.Input<string>;
}

export interface DestinationPgvectorConfigurationProcessingTextSplitterBySeparator {
    /**
     * Whether to keep the separator in the resulting chunks. Default: false
     */
    keepSeparator?: pulumi.Input<boolean>;
    /**
     * List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
     */
    separators?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationPgvectorResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationPgvectorResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationPgvectorResourceAllocationJobSpecific>[]>;
}

export interface DestinationPgvectorResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPgvectorResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationPgvectorResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationPgvectorResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPineconeConfiguration {
    /**
     * Embedding configuration
     */
    embedding: pulumi.Input<inputs.DestinationPineconeConfigurationEmbedding>;
    /**
     * Pinecone is a popular vector store that can be used to store and retrieve embeddings.
     */
    indexing: pulumi.Input<inputs.DestinationPineconeConfigurationIndexing>;
    /**
     * Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
     */
    omitRawText?: pulumi.Input<boolean>;
    processing: pulumi.Input<inputs.DestinationPineconeConfigurationProcessing>;
}

export interface DestinationPineconeConfigurationEmbedding {
    /**
     * Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    azureOpenAi?: pulumi.Input<inputs.DestinationPineconeConfigurationEmbeddingAzureOpenAi>;
    /**
     * Use the Cohere API to embed text.
     */
    cohere?: pulumi.Input<inputs.DestinationPineconeConfigurationEmbeddingCohere>;
    /**
     * Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
     */
    fake?: pulumi.Input<inputs.DestinationPineconeConfigurationEmbeddingFake>;
    /**
     * Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    openAi?: pulumi.Input<inputs.DestinationPineconeConfigurationEmbeddingOpenAi>;
    /**
     * Use a service that's compatible with the OpenAI API to embed text.
     */
    openAiCompatible?: pulumi.Input<inputs.DestinationPineconeConfigurationEmbeddingOpenAiCompatible>;
}

export interface DestinationPineconeConfigurationEmbeddingAzureOpenAi {
    /**
     * The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    apiBase: pulumi.Input<string>;
    /**
     * The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    deployment: pulumi.Input<string>;
    /**
     * The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    openaiKey: pulumi.Input<string>;
}

export interface DestinationPineconeConfigurationEmbeddingCohere {
    cohereKey: pulumi.Input<string>;
}

export interface DestinationPineconeConfigurationEmbeddingFake {
}

export interface DestinationPineconeConfigurationEmbeddingOpenAi {
    openaiKey: pulumi.Input<string>;
}

export interface DestinationPineconeConfigurationEmbeddingOpenAiCompatible {
    /**
     * Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The base URL for your OpenAI-compatible service
     */
    baseUrl: pulumi.Input<string>;
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * The name of the model to use for embedding. Default: "text-embedding-ada-002"
     */
    modelName?: pulumi.Input<string>;
}

export interface DestinationPineconeConfigurationIndexing {
    /**
     * Pinecone index in your project to load data into
     */
    index: pulumi.Input<string>;
    /**
     * Pinecone Cloud environment to use
     */
    pineconeEnvironment: pulumi.Input<string>;
    /**
     * The Pinecone API key to use matching the environment (copy from Pinecone console)
     */
    pineconeKey: pulumi.Input<string>;
}

export interface DestinationPineconeConfigurationProcessing {
    /**
     * Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
     */
    chunkOverlap?: pulumi.Input<number>;
    /**
     * Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
     */
    chunkSize: pulumi.Input<number>;
    /**
     * List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
     */
    fieldNameMappings?: pulumi.Input<pulumi.Input<inputs.DestinationPineconeConfigurationProcessingFieldNameMapping>[]>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Split text fields into chunks based on the specified method.
     */
    textSplitter?: pulumi.Input<inputs.DestinationPineconeConfigurationProcessingTextSplitter>;
}

export interface DestinationPineconeConfigurationProcessingFieldNameMapping {
    /**
     * The field name in the source
     */
    fromField: pulumi.Input<string>;
    /**
     * The field name to use in the destination
     */
    toField: pulumi.Input<string>;
}

export interface DestinationPineconeConfigurationProcessingTextSplitter {
    /**
     * Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
     */
    byMarkdownHeader?: pulumi.Input<inputs.DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader>;
    /**
     * Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
     */
    byProgrammingLanguage?: pulumi.Input<inputs.DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguage>;
    /**
     * Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
     */
    bySeparator?: pulumi.Input<inputs.DestinationPineconeConfigurationProcessingTextSplitterBySeparator>;
}

export interface DestinationPineconeConfigurationProcessingTextSplitterByMarkdownHeader {
    /**
     * Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
     */
    splitLevel?: pulumi.Input<number>;
}

export interface DestinationPineconeConfigurationProcessingTextSplitterByProgrammingLanguage {
    /**
     * Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
     */
    language: pulumi.Input<string>;
}

export interface DestinationPineconeConfigurationProcessingTextSplitterBySeparator {
    /**
     * Whether to keep the separator in the resulting chunks. Default: false
     */
    keepSeparator?: pulumi.Input<boolean>;
    /**
     * List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
     */
    separators?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationPineconeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationPineconeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationPineconeResourceAllocationJobSpecific>[]>;
}

export interface DestinationPineconeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPineconeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationPineconeResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationPineconeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPostgresConfiguration {
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
     */
    disableTypeDedupe?: pulumi.Input<boolean>;
    /**
     * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
     */
    dropCascade?: pulumi.Input<boolean>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database. Default: 5432
     */
    port?: pulumi.Input<number>;
    /**
     * The schema to write raw tables into
     */
    rawDataSchema?: pulumi.Input<string>;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
     */
    schema?: pulumi.Input<string>;
    /**
     * Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
     */
    ssl?: pulumi.Input<boolean>;
    /**
     * SSL connection modes. 
     *  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
     *  <b>allow</b> - Chose this mode to enable encryption only when required by the source database
     *  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     *  <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     *   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     *   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     *  See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
     */
    sslMode?: pulumi.Input<inputs.DestinationPostgresConfigurationSslMode>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationPostgresConfigurationTunnelMethod>;
    /**
     * Create numeric columns as unconstrained DECIMAL instead of NUMBER(38, 9). This will allow increased precision in numeric values. (this is disabled by default for backwards compatibility, but is recommended to enable). Default: false
     */
    unconstrainedNumber?: pulumi.Input<boolean>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationPostgresConfigurationSslMode {
    /**
     * Allow SSL mode.
     */
    allow?: pulumi.Input<inputs.DestinationPostgresConfigurationSslModeAllow>;
    /**
     * Disable SSL.
     */
    disable?: pulumi.Input<inputs.DestinationPostgresConfigurationSslModeDisable>;
    /**
     * Prefer SSL mode.
     */
    prefer?: pulumi.Input<inputs.DestinationPostgresConfigurationSslModePrefer>;
    /**
     * Require SSL mode.
     */
    require?: pulumi.Input<inputs.DestinationPostgresConfigurationSslModeRequire>;
    /**
     * Verify-ca SSL mode.
     */
    verifyCa?: pulumi.Input<inputs.DestinationPostgresConfigurationSslModeVerifyCa>;
    /**
     * Verify-full SSL mode.
     */
    verifyFull?: pulumi.Input<inputs.DestinationPostgresConfigurationSslModeVerifyFull>;
}

export interface DestinationPostgresConfigurationSslModeAllow {
}

export interface DestinationPostgresConfigurationSslModeDisable {
}

export interface DestinationPostgresConfigurationSslModePrefer {
}

export interface DestinationPostgresConfigurationSslModeRequire {
}

export interface DestinationPostgresConfigurationSslModeVerifyCa {
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
}

export interface DestinationPostgresConfigurationSslModeVerifyFull {
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Client certificate
     */
    clientCertificate: pulumi.Input<string>;
    /**
     * Client key
     */
    clientKey: pulumi.Input<string>;
    /**
     * Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
}

export interface DestinationPostgresConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationPostgresConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationPostgresConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationPostgresConfigurationTunnelMethodNoTunnel {
}

export interface DestinationPostgresConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationPostgresConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationPostgresResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationPostgresResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationPostgresResourceAllocationJobSpecific>[]>;
}

export interface DestinationPostgresResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPostgresResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationPostgresResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationPostgresResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPubsubConfiguration {
    /**
     * Number of ms before the buffer is flushed. Default: 1
     */
    batchingDelayThreshold?: pulumi.Input<number>;
    /**
     * Number of messages before the buffer is flushed. Default: 1
     */
    batchingElementCountThreshold?: pulumi.Input<number>;
    /**
     * If TRUE messages will be buffered instead of sending them one by one. Default: false
     */
    batchingEnabled?: pulumi.Input<boolean>;
    /**
     * Number of bytes before the buffer is flushed. Default: 1
     */
    batchingRequestBytesThreshold?: pulumi.Input<number>;
    /**
     * The contents of the JSON service account key. Check out the <a href="https://docs.airbyte.com/integrations/destinations/pubsub">docs</a> if you need help generating this key.
     */
    credentialsJson: pulumi.Input<string>;
    /**
     * If TRUE PubSub publisher will have <a href="https://cloud.google.com/pubsub/docs/ordering">message ordering</a> enabled. Every message will have an ordering key of stream. Default: false
     */
    orderingEnabled?: pulumi.Input<boolean>;
    /**
     * The GCP project ID for the project containing the target PubSub.
     */
    projectId: pulumi.Input<string>;
    /**
     * The PubSub topic ID in the given GCP project ID.
     */
    topicId: pulumi.Input<string>;
}

export interface DestinationPubsubResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationPubsubResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationPubsubResourceAllocationJobSpecific>[]>;
}

export interface DestinationPubsubResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationPubsubResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationPubsubResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationPubsubResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationQdrantConfiguration {
    /**
     * Embedding configuration
     */
    embedding: pulumi.Input<inputs.DestinationQdrantConfigurationEmbedding>;
    /**
     * Indexing configuration
     */
    indexing: pulumi.Input<inputs.DestinationQdrantConfigurationIndexing>;
    /**
     * Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
     */
    omitRawText?: pulumi.Input<boolean>;
    processing: pulumi.Input<inputs.DestinationQdrantConfigurationProcessing>;
}

export interface DestinationQdrantConfigurationEmbedding {
    /**
     * Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    azureOpenAi?: pulumi.Input<inputs.DestinationQdrantConfigurationEmbeddingAzureOpenAi>;
    /**
     * Use the Cohere API to embed text.
     */
    cohere?: pulumi.Input<inputs.DestinationQdrantConfigurationEmbeddingCohere>;
    /**
     * Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
     */
    fake?: pulumi.Input<inputs.DestinationQdrantConfigurationEmbeddingFake>;
    /**
     * Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    openAi?: pulumi.Input<inputs.DestinationQdrantConfigurationEmbeddingOpenAi>;
    /**
     * Use a service that's compatible with the OpenAI API to embed text.
     */
    openAiCompatible?: pulumi.Input<inputs.DestinationQdrantConfigurationEmbeddingOpenAiCompatible>;
}

export interface DestinationQdrantConfigurationEmbeddingAzureOpenAi {
    /**
     * The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    apiBase: pulumi.Input<string>;
    /**
     * The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    deployment: pulumi.Input<string>;
    /**
     * The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    openaiKey: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationEmbeddingCohere {
    cohereKey: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationEmbeddingFake {
}

export interface DestinationQdrantConfigurationEmbeddingOpenAi {
    openaiKey: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationEmbeddingOpenAiCompatible {
    /**
     * Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The base URL for your OpenAI-compatible service
     */
    baseUrl: pulumi.Input<string>;
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * The name of the model to use for embedding. Default: "text-embedding-ada-002"
     */
    modelName?: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationIndexing {
    /**
     * Method to authenticate with the Qdrant Instance
     */
    authMethod?: pulumi.Input<inputs.DestinationQdrantConfigurationIndexingAuthMethod>;
    /**
     * The collection to load data into
     */
    collection: pulumi.Input<string>;
    /**
     * The Distance metric used to measure similarities among vectors. This field is only used if the collection defined in the does not exist yet and is created automatically by the connector. Default: "cos"; must be one of ["dot", "cos", "euc"]
     */
    distanceMetric?: pulumi.Input<string>;
    /**
     * Whether to prefer gRPC over HTTP. Set to true for Qdrant cloud clusters. Default: true
     */
    preferGrpc?: pulumi.Input<boolean>;
    /**
     * The field in the payload that contains the embedded text. Default: "text"
     */
    textField?: pulumi.Input<string>;
    /**
     * Public Endpoint of the Qdrant cluser
     */
    url: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationIndexingAuthMethod {
    apiKeyAuth?: pulumi.Input<inputs.DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth>;
    noAuth?: pulumi.Input<inputs.DestinationQdrantConfigurationIndexingAuthMethodNoAuth>;
}

export interface DestinationQdrantConfigurationIndexingAuthMethodApiKeyAuth {
    /**
     * API Key for the Qdrant instance
     */
    apiKey: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationIndexingAuthMethodNoAuth {
}

export interface DestinationQdrantConfigurationProcessing {
    /**
     * Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
     */
    chunkOverlap?: pulumi.Input<number>;
    /**
     * Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
     */
    chunkSize: pulumi.Input<number>;
    /**
     * List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
     */
    fieldNameMappings?: pulumi.Input<pulumi.Input<inputs.DestinationQdrantConfigurationProcessingFieldNameMapping>[]>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Split text fields into chunks based on the specified method.
     */
    textSplitter?: pulumi.Input<inputs.DestinationQdrantConfigurationProcessingTextSplitter>;
}

export interface DestinationQdrantConfigurationProcessingFieldNameMapping {
    /**
     * The field name in the source
     */
    fromField: pulumi.Input<string>;
    /**
     * The field name to use in the destination
     */
    toField: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationProcessingTextSplitter {
    /**
     * Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
     */
    byMarkdownHeader?: pulumi.Input<inputs.DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader>;
    /**
     * Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
     */
    byProgrammingLanguage?: pulumi.Input<inputs.DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguage>;
    /**
     * Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
     */
    bySeparator?: pulumi.Input<inputs.DestinationQdrantConfigurationProcessingTextSplitterBySeparator>;
}

export interface DestinationQdrantConfigurationProcessingTextSplitterByMarkdownHeader {
    /**
     * Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
     */
    splitLevel?: pulumi.Input<number>;
}

export interface DestinationQdrantConfigurationProcessingTextSplitterByProgrammingLanguage {
    /**
     * Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
     */
    language: pulumi.Input<string>;
}

export interface DestinationQdrantConfigurationProcessingTextSplitterBySeparator {
    /**
     * Whether to keep the separator in the resulting chunks. Default: false
     */
    keepSeparator?: pulumi.Input<boolean>;
    /**
     * List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
     */
    separators?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationQdrantResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationQdrantResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationQdrantResourceAllocationJobSpecific>[]>;
}

export interface DestinationQdrantResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationQdrantResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationQdrantResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationQdrantResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationRedisConfiguration {
    /**
     * Redis cache type to store data in. Default: "hash"; must be "hash"
     */
    cacheType?: pulumi.Input<string>;
    /**
     * Redis host to connect to.
     */
    host: pulumi.Input<string>;
    /**
     * Password associated with Redis.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of Redis. Default: 6379
     */
    port?: pulumi.Input<number>;
    /**
     * Indicates whether SSL encryption protocol will be used to connect to Redis. It is recommended to use SSL connection if possible. Default: false
     */
    ssl?: pulumi.Input<boolean>;
    /**
     * SSL connection modes. 
     *   <li><b>verify-full</b> - This is the most secure mode. Always require encryption and verifies the identity of the source database server
     */
    sslMode?: pulumi.Input<inputs.DestinationRedisConfigurationSslMode>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationRedisConfigurationTunnelMethod>;
    /**
     * Username associated with Redis.
     */
    username: pulumi.Input<string>;
}

export interface DestinationRedisConfigurationSslMode {
    /**
     * Disable SSL.
     */
    disable?: pulumi.Input<inputs.DestinationRedisConfigurationSslModeDisable>;
    /**
     * Verify-full SSL mode.
     */
    verifyFull?: pulumi.Input<inputs.DestinationRedisConfigurationSslModeVerifyFull>;
}

export interface DestinationRedisConfigurationSslModeDisable {
}

export interface DestinationRedisConfigurationSslModeVerifyFull {
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Client certificate
     */
    clientCertificate: pulumi.Input<string>;
    /**
     * Client key
     */
    clientKey: pulumi.Input<string>;
    /**
     * Password for keystorage. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
}

export interface DestinationRedisConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationRedisConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationRedisConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationRedisConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationRedisConfigurationTunnelMethodNoTunnel {
}

export interface DestinationRedisConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationRedisConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationRedisResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationRedisResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationRedisResourceAllocationJobSpecific>[]>;
}

export interface DestinationRedisResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationRedisResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationRedisResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationRedisResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationRedshiftConfiguration {
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
     */
    disableTypeDedupe?: pulumi.Input<boolean>;
    /**
     * Drop tables with CASCADE. WARNING! This will delete all data in all dependent objects (views, etc.). Use with caution. This option is intended for usecases which can easily rebuild the dependent objects. Default: false
     */
    dropCascade?: pulumi.Input<boolean>;
    /**
     * Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com)
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * Port of the database. Default: 5439
     */
    port?: pulumi.Input<number>;
    /**
     * The schema to write raw tables into (default: airbyte_internal).
     */
    rawDataSchema?: pulumi.Input<string>;
    /**
     * The default schema tables are written to if the source does not specify a namespace. Unless specifically configured, the usual value for this field is "public". Default: "public"
     */
    schema?: pulumi.Input<string>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationRedshiftConfigurationTunnelMethod>;
    /**
     * The way data will be uploaded to Redshift.
     */
    uploadingMethod?: pulumi.Input<inputs.DestinationRedshiftConfigurationUploadingMethod>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationRedshiftConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationRedshiftConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationRedshiftConfigurationTunnelMethodNoTunnel {
}

export interface DestinationRedshiftConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationRedshiftConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationRedshiftConfigurationUploadingMethod {
    /**
     * <i>(recommended)</i> Uploads data to S3 and then uses a COPY to insert the data into Redshift. COPY is recommended for production workloads for better speed and scalability. See <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/creating-bucket.html">AWS docs</a> for more details.
     */
    awss3Staging?: pulumi.Input<inputs.DestinationRedshiftConfigurationUploadingMethodAwss3Staging>;
}

export interface DestinationRedshiftConfigurationUploadingMethodAwss3Staging {
    /**
     * This ID grants access to the above S3 staging bucket. Airbyte requires Read and Write permissions to the given bucket. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
     */
    accessKeyId: pulumi.Input<string>;
    /**
     * The pattern allows you to set the file-name format for the S3 staging file(s)
     */
    fileNamePattern?: pulumi.Input<string>;
    /**
     * Whether to delete the staging files from S3 after completing the sync. See <a href="https://docs.airbyte.com/integrations/destinations/redshift/#:~:text=the%20root%20directory.-,Purge%20Staging%20Data,-Whether%20to%20delete"> docs</a> for details. Default: true
     */
    purgeStagingData?: pulumi.Input<boolean>;
    /**
     * The name of the staging S3 bucket.
     */
    s3BucketName: pulumi.Input<string>;
    /**
     * The directory under the S3 bucket where data will be written. If not provided, then defaults to the root directory. See <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/defining-bucket-names-data-lakes/faq.html#:~:text=be%20globally%20unique.-,For%20S3%20bucket%20paths,-%2C%20you%20can%20use">path's name recommendations</a> for more details.
     */
    s3BucketPath?: pulumi.Input<string>;
    /**
     * The region of the S3 staging bucket. Default: ""; must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
     */
    s3BucketRegion?: pulumi.Input<string>;
    /**
     * The corresponding secret to the above access key id. See <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">AWS docs</a> on how to generate an access key ID and secret access key.
     */
    secretAccessKey: pulumi.Input<string>;
}

export interface DestinationRedshiftResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationRedshiftResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationRedshiftResourceAllocationJobSpecific>[]>;
}

export interface DestinationRedshiftResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationRedshiftResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationRedshiftResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationRedshiftResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationS3Configuration {
    /**
     * The access key ID to access the S3 bucket. Airbyte requires Read and Write permissions to the given bucket. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>.
     */
    accessKeyId?: pulumi.Input<string>;
    /**
     * Pattern to match file names in the bucket directory. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/ListingKeysUsingAPIs.html">here</a>
     */
    fileNamePattern?: pulumi.Input<string>;
    /**
     * Format of the data output. See <a href="https://docs.airbyte.com/integrations/destinations/s3/#supported-output-schema">here</a> for more details
     */
    format: pulumi.Input<inputs.DestinationS3ConfigurationFormat>;
    /**
     * The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
     */
    roleArn?: pulumi.Input<string>;
    /**
     * The name of the S3 bucket. Read more <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/create-bucket-overview.html">here</a>.
     */
    s3BucketName: pulumi.Input<string>;
    /**
     * Directory under the S3 bucket where data will be written. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=to%20format%20the-,bucket%20path,-%3A">here</a>
     */
    s3BucketPath: pulumi.Input<string>;
    /**
     * The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. Default: ""; must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
     */
    s3BucketRegion?: pulumi.Input<string>;
    /**
     * Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
     */
    s3Endpoint?: pulumi.Input<string>;
    /**
     * Format string on how data will be organized inside the bucket directory. Read more <a href="https://docs.airbyte.com/integrations/destinations/s3#:~:text=The%20full%20path%20of%20the%20output%20data%20with%20the%20default%20S3%20path%20format">here</a>
     */
    s3PathFormat?: pulumi.Input<string>;
    /**
     * The corresponding secret to the access key ID. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html#access-keys-and-secret-access-keys">here</a>
     */
    secretAccessKey?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormat {
    avroApacheAvro?: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvro>;
    csvCommaSeparatedValues?: pulumi.Input<inputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValues>;
    jsonLinesNewlineDelimitedJson?: pulumi.Input<inputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson>;
    parquetColumnarStorage?: pulumi.Input<inputs.DestinationS3ConfigurationFormatParquetColumnarStorage>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvro {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The compression algorithm used to compress data. Default to no compression.
     */
    compressionCodec: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec>;
    /**
     * Default: "Avro"; must be "Avro"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodec {
    bzip2?: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2>;
    deflate?: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate>;
    noCompression?: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompression>;
    snappy?: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappy>;
    xz?: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz>;
    zstandard?: pulumi.Input<inputs.DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecBzip2 {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "bzip2"; must be "bzip2"
     */
    codec?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecDeflate {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "Deflate"; must be "Deflate"
     */
    codec?: pulumi.Input<string>;
    compressionLevel: pulumi.Input<number>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecNoCompression {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "no compression"; must be "no compression"
     */
    codec?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecSnappy {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "snappy"; must be "snappy"
     */
    codec?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecXz {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "xz"; must be "xz"
     */
    codec?: pulumi.Input<string>;
    compressionLevel: pulumi.Input<number>;
}

export interface DestinationS3ConfigurationFormatAvroApacheAvroCompressionCodecZstandard {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "zstandard"; must be "zstandard"
     */
    codec?: pulumi.Input<string>;
    compressionLevel: pulumi.Input<number>;
    includeChecksum: pulumi.Input<boolean>;
}

export interface DestinationS3ConfigurationFormatCsvCommaSeparatedValues {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
     */
    compression?: pulumi.Input<inputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression>;
    /**
     * Default: "No flattening"; must be one of ["No flattening", "Root level flattening"]
     */
    flattening?: pulumi.Input<string>;
    /**
     * Default: "CSV"; must be "CSV"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompression {
    gzip?: pulumi.Input<inputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip>;
    noCompression?: pulumi.Input<inputs.DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression>;
}

export interface DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionGzip {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "GZIP"; must be "GZIP"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatCsvCommaSeparatedValuesCompressionNoCompression {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "No Compression"; must be "No Compression"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJson {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Whether the output files should be compressed. If compression is selected, the output filename will have an extra extension (GZIP: ".jsonl.gz").
     */
    compression?: pulumi.Input<inputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression>;
    /**
     * Default: "No flattening"; must be one of ["No flattening", "Root level flattening"]
     */
    flattening?: pulumi.Input<string>;
    /**
     * Default: "JSONL"; must be "JSONL"
     */
    formatType?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompression {
    gzip?: pulumi.Input<inputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip>;
    noCompression?: pulumi.Input<inputs.DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression>;
}

export interface DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionGzip {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "GZIP"; must be "GZIP"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatJsonLinesNewlineDelimitedJsonCompressionNoCompression {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "No Compression"; must be "No Compression"
     */
    compressionType?: pulumi.Input<string>;
}

export interface DestinationS3ConfigurationFormatParquetColumnarStorage {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * This is the size of a row group being buffered in memory. It limits the memory usage when writing. Larger values will improve the IO when reading, but consume more memory when writing. Default: 128 MB. Default: 128
     */
    blockSizeMb?: pulumi.Input<number>;
    /**
     * The compression algorithm used to compress data pages. Default: "UNCOMPRESSED"; must be one of ["UNCOMPRESSED", "SNAPPY", "GZIP", "LZO", "BROTLI", "LZ4", "ZSTD"]
     */
    compressionCodec?: pulumi.Input<string>;
    /**
     * Default: true.
     */
    dictionaryEncoding?: pulumi.Input<boolean>;
    /**
     * There is one dictionary page per column per row group when dictionary encoding is used. The dictionary page size works like the page size but for dictionary. Default: 1024 KB. Default: 1024
     */
    dictionaryPageSizeKb?: pulumi.Input<number>;
    /**
     * Default: "Parquet"; must be "Parquet"
     */
    formatType?: pulumi.Input<string>;
    /**
     * Maximum size allowed as padding to align row groups. This is also the minimum size of a row group. Default: 8 MB. Default: 8
     */
    maxPaddingSizeMb?: pulumi.Input<number>;
    /**
     * The page size is for compression. A block is composed of pages. A page is the smallest unit that must be read fully to access a single record. If this value is too small, the compression will deteriorate. Default: 1024 KB. Default: 1024
     */
    pageSizeKb?: pulumi.Input<number>;
}

export interface DestinationS3DataLakeConfiguration {
    /**
     * The AWS Access Key ID with permissions for S3 and Glue operations.
     */
    accessKeyId?: pulumi.Input<string>;
    /**
     * Specifies the type of Iceberg catalog (e.g., NESSIE, GLUE, REST) and its associated configuration.
     */
    catalogType: pulumi.Input<inputs.DestinationS3DataLakeConfigurationCatalogType>;
    /**
     * The primary or default branch name in the catalog. Most query engines will use "main" by default. See <a href="https://iceberg.apache.org/docs/latest/branching/">Iceberg documentation</a> for more information. Default: "main"
     */
    mainBranchName?: pulumi.Input<string>;
    /**
     * The name of the S3 bucket that will host the Iceberg data.
     */
    s3BucketName: pulumi.Input<string>;
    /**
     * The region of the S3 bucket. See <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-regions-availability-zones.html#concepts-available-regions">here</a> for all region codes. must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
     */
    s3BucketRegion: pulumi.Input<string>;
    /**
     * Your S3 endpoint url. Read more <a href="https://docs.aws.amazon.com/general/latest/gr/s3.html#:~:text=Service%20endpoints-,Amazon%20S3%20endpoints,-When%20you%20use">here</a>
     */
    s3Endpoint?: pulumi.Input<string>;
    /**
     * The AWS Secret Access Key paired with the Access Key ID for AWS authentication.
     */
    secretAccessKey?: pulumi.Input<string>;
    /**
     * The root location of the data warehouse used by the Iceberg catalog. Typically includes a bucket name and path within that bucket. For AWS Glue and Nessie, must include the storage protocol (such as "s3://" for Amazon S3).
     */
    warehouseLocation: pulumi.Input<string>;
}

export interface DestinationS3DataLakeConfigurationCatalogType {
    /**
     * Configuration details for connecting to an AWS Glue-based Iceberg catalog.
     */
    glueCatalog?: pulumi.Input<inputs.DestinationS3DataLakeConfigurationCatalogTypeGlueCatalog>;
    /**
     * Configuration details for connecting to a Nessie-based Iceberg catalog.
     */
    nessieCatalog?: pulumi.Input<inputs.DestinationS3DataLakeConfigurationCatalogTypeNessieCatalog>;
    /**
     * Configuration details for connecting to a REST catalog.
     */
    restCatalog?: pulumi.Input<inputs.DestinationS3DataLakeConfigurationCatalogTypeRestCatalog>;
}

export interface DestinationS3DataLakeConfigurationCatalogTypeGlueCatalog {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "GLUE"; must be "GLUE"
     */
    catalogType?: pulumi.Input<string>;
    /**
     * The Glue database name. This will ONLY be used if the `Destination Namespace` setting for the connection is set to `Destination-defined` or `Source-defined`
     */
    databaseName: pulumi.Input<string>;
    /**
     * The AWS Account ID associated with the Glue service used by the Iceberg catalog.
     */
    glueId: pulumi.Input<string>;
    /**
     * The ARN of the AWS role to assume. Only usable in Airbyte Cloud.
     */
    roleArn?: pulumi.Input<string>;
}

export interface DestinationS3DataLakeConfigurationCatalogTypeNessieCatalog {
    /**
     * Optional token for authentication with the Nessie server.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "NESSIE"; must be "NESSIE"
     */
    catalogType?: pulumi.Input<string>;
    /**
     * The Nessie namespace to be used in the Table identifier. 
     *            This will ONLY be used if the `Destination Namespace` setting for the connection is set to
     *            `Destination-defined` or `Source-defined`
     */
    namespace: pulumi.Input<string>;
    /**
     * The base URL of the Nessie server used to connect to the Nessie catalog.
     */
    serverUri: pulumi.Input<string>;
}

export interface DestinationS3DataLakeConfigurationCatalogTypeRestCatalog {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "REST"; must be "REST"
     */
    catalogType?: pulumi.Input<string>;
    /**
     * The namespace to be used in the Table identifier. 
     *            This will ONLY be used if the `Destination Namespace` setting for the connection is set to
     *            `Destination-defined` or `Source-defined`
     */
    namespace: pulumi.Input<string>;
    /**
     * The base URL of the Rest server used to connect to the Rest catalog.
     */
    serverUri: pulumi.Input<string>;
}

export interface DestinationS3DataLakeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationS3DataLakeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationS3DataLakeResourceAllocationJobSpecific>[]>;
}

export interface DestinationS3DataLakeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationS3DataLakeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationS3DataLakeResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationS3DataLakeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationS3ResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationS3ResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationS3ResourceAllocationJobSpecific>[]>;
}

export interface DestinationS3ResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationS3ResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationS3ResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationS3ResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationSftpJsonConfiguration {
    /**
     * Path to the directory where json files will be written.
     */
    destinationPath: pulumi.Input<string>;
    /**
     * Hostname of the SFTP server.
     */
    host: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * Port of the SFTP server. Default: 22
     */
    port?: pulumi.Input<number>;
    /**
     * Username to use to access the SFTP server.
     */
    username: pulumi.Input<string>;
}

export interface DestinationSftpJsonResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationSftpJsonResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationSftpJsonResourceAllocationJobSpecific>[]>;
}

export interface DestinationSftpJsonResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationSftpJsonResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationSftpJsonResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationSftpJsonResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationSnowflakeConfiguration {
    credentials?: pulumi.Input<inputs.DestinationSnowflakeConfigurationCredentials>;
    /**
     * Enter the name of the <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">database</a> you want to sync data into
     */
    database: pulumi.Input<string>;
    /**
     * Disable Writing Final Tables. WARNING! The data format in _airbyte_data is likely stable but there are no guarantees that other metadata columns will remain the same in future versions. Default: false
     */
    disableTypeDedupe?: pulumi.Input<boolean>;
    /**
     * Enter your Snowflake account's <a href="https://docs.snowflake.com/en/user-guide/admin-account-identifier.html#using-an-account-locator-as-an-identifier">locator</a> (in the format <account_locator>.<region>.<cloud>.snowflakecomputing.com)
     */
    host: pulumi.Input<string>;
    /**
     * Enter the additional properties to pass to the JDBC URL string when connecting to the database (formatted as key=value pairs separated by the symbol &). Example: key1=value1&key2=value2&key3=value3
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The schema to write raw tables into (default: airbyte_internal)
     */
    rawDataSchema?: pulumi.Input<string>;
    /**
     * The number of days of Snowflake Time Travel to enable on the tables. See <a href="https://docs.snowflake.com/en/user-guide/data-time-travel#data-retention-period">Snowflake's documentation</a> for more information. Setting a nonzero value will incur increased storage costs in your Snowflake instance. Default: 1
     */
    retentionPeriodDays?: pulumi.Input<number>;
    /**
     * Enter the <a href="https://docs.snowflake.com/en/user-guide/security-access-control-overview.html#roles">role</a> that you want to use to access Snowflake
     */
    role: pulumi.Input<string>;
    /**
     * Enter the name of the default <a href="https://docs.snowflake.com/en/sql-reference/ddl-database.html#database-schema-share-ddl">schema</a>
     */
    schema: pulumi.Input<string>;
    /**
     * Use MERGE for de-duplication of final tables. This option no effect if Final tables are disabled or Sync mode is not DEDUPE. Default: false
     */
    useMergeForUpsert?: pulumi.Input<boolean>;
    /**
     * Enter the name of the user you want to use to access the database
     */
    username: pulumi.Input<string>;
    /**
     * Enter the name of the <a href="https://docs.snowflake.com/en/user-guide/warehouses-overview.html#overview-of-warehouses">warehouse</a> that you want to use as a compute cluster
     */
    warehouse: pulumi.Input<string>;
}

export interface DestinationSnowflakeConfigurationCredentials {
    keyPairAuthentication?: pulumi.Input<inputs.DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication>;
    oAuth20?: pulumi.Input<inputs.DestinationSnowflakeConfigurationCredentialsOAuth20>;
    usernameAndPassword?: pulumi.Input<inputs.DestinationSnowflakeConfigurationCredentialsUsernameAndPassword>;
}

export interface DestinationSnowflakeConfigurationCredentialsKeyPairAuthentication {
    /**
     * RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/destinations/snowflake">docs</a> for more information on how to obtain this key.
     */
    privateKey: pulumi.Input<string>;
    /**
     * Passphrase for private key
     */
    privateKeyPassword?: pulumi.Input<string>;
}

export interface DestinationSnowflakeConfigurationCredentialsOAuth20 {
    /**
     * Enter you application's Access Token
     */
    accessToken: pulumi.Input<string>;
    /**
     * Enter your application's Client ID
     */
    clientId?: pulumi.Input<string>;
    /**
     * Enter your application's Client secret
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * Enter your application's Refresh Token
     */
    refreshToken: pulumi.Input<string>;
}

export interface DestinationSnowflakeConfigurationCredentialsUsernameAndPassword {
    /**
     * Enter the password associated with the username.
     */
    password: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfiguration {
    /**
     * Embedding configuration
     */
    embedding: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationEmbedding>;
    /**
     * Snowflake can be used to store vector data and retrieve embeddings.
     */
    indexing: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationIndexing>;
    /**
     * Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
     */
    omitRawText?: pulumi.Input<boolean>;
    processing: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationProcessing>;
}

export interface DestinationSnowflakeCortexConfigurationEmbedding {
    /**
     * Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    azureOpenAi?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi>;
    /**
     * Use the Cohere API to embed text.
     */
    cohere?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationEmbeddingCohere>;
    /**
     * Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
     */
    fake?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationEmbeddingFake>;
    /**
     * Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    openAi?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationEmbeddingOpenAi>;
    /**
     * Use a service that's compatible with the OpenAI API to embed text.
     */
    openAiCompatible?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible>;
}

export interface DestinationSnowflakeCortexConfigurationEmbeddingAzureOpenAi {
    /**
     * The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    apiBase: pulumi.Input<string>;
    /**
     * The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    deployment: pulumi.Input<string>;
    /**
     * The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    openaiKey: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationEmbeddingCohere {
    cohereKey: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationEmbeddingFake {
}

export interface DestinationSnowflakeCortexConfigurationEmbeddingOpenAi {
    openaiKey: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationEmbeddingOpenAiCompatible {
    /**
     * Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The base URL for your OpenAI-compatible service
     */
    baseUrl: pulumi.Input<string>;
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * The name of the model to use for embedding. Default: "text-embedding-ada-002"
     */
    modelName?: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationIndexing {
    credentials: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationIndexingCredentials>;
    /**
     * Enter the name of the database that you want to sync data into
     */
    database: pulumi.Input<string>;
    /**
     * Enter the name of the default schema
     */
    defaultSchema: pulumi.Input<string>;
    /**
     * Enter the account name you want to use to access the database. This is usually the identifier before .snowflakecomputing.com
     */
    host: pulumi.Input<string>;
    /**
     * Enter the role that you want to use to access Snowflake
     */
    role: pulumi.Input<string>;
    /**
     * Enter the name of the user you want to use to access the database
     */
    username: pulumi.Input<string>;
    /**
     * Enter the name of the warehouse that you want to use as a compute cluster
     */
    warehouse: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationIndexingCredentials {
    /**
     * Enter the password you want to use to access the database
     */
    password: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationProcessing {
    /**
     * Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
     */
    chunkOverlap?: pulumi.Input<number>;
    /**
     * Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
     */
    chunkSize: pulumi.Input<number>;
    /**
     * List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
     */
    fieldNameMappings?: pulumi.Input<pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping>[]>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Split text fields into chunks based on the specified method.
     */
    textSplitter?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitter>;
}

export interface DestinationSnowflakeCortexConfigurationProcessingFieldNameMapping {
    /**
     * The field name in the source
     */
    fromField: pulumi.Input<string>;
    /**
     * The field name to use in the destination
     */
    toField: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationProcessingTextSplitter {
    /**
     * Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
     */
    byMarkdownHeader?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader>;
    /**
     * Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
     */
    byProgrammingLanguage?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguage>;
    /**
     * Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
     */
    bySeparator?: pulumi.Input<inputs.DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator>;
}

export interface DestinationSnowflakeCortexConfigurationProcessingTextSplitterByMarkdownHeader {
    /**
     * Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
     */
    splitLevel?: pulumi.Input<number>;
}

export interface DestinationSnowflakeCortexConfigurationProcessingTextSplitterByProgrammingLanguage {
    /**
     * Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
     */
    language: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexConfigurationProcessingTextSplitterBySeparator {
    /**
     * Whether to keep the separator in the resulting chunks. Default: false
     */
    keepSeparator?: pulumi.Input<boolean>;
    /**
     * List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
     */
    separators?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationSnowflakeCortexResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationSnowflakeCortexResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationSnowflakeCortexResourceAllocationJobSpecific>[]>;
}

export interface DestinationSnowflakeCortexResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationSnowflakeCortexResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationSnowflakeCortexResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationSnowflakeCortexResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationSnowflakeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationSnowflakeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationSnowflakeResourceAllocationJobSpecific>[]>;
}

export interface DestinationSnowflakeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationSnowflakeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationSnowflakeResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationSnowflakeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationTeradataConfiguration {
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    logmech?: pulumi.Input<inputs.DestinationTeradataConfigurationLogmech>;
    /**
     * Defines the custom session query band using name-value pairs. For example, 'org=Finance;report=Fin123;'
     */
    queryBand?: pulumi.Input<string>;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "airbyte_td"
     */
    schema?: pulumi.Input<string>;
    /**
     * Encrypt data using SSL. When activating SSL, please select one of the SSL modes. Default: false
     */
    ssl?: pulumi.Input<boolean>;
    /**
     * SSL connection modes. 
     *  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
     *  <b>allow</b> - Chose this mode to enable encryption only when required by the destination database
     *  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the destination database does not support encryption
     *  <b>require</b> - Chose this mode to always require encryption. If the destination database server does not support encryption, connection will fail
     *   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the destination database server has a valid SSL certificate
     *   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the destination database server
     *  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLMODE"> in the docs</a>.
     */
    sslMode?: pulumi.Input<inputs.DestinationTeradataConfigurationSslMode>;
}

export interface DestinationTeradataConfigurationLogmech {
    ldap?: pulumi.Input<inputs.DestinationTeradataConfigurationLogmechLdap>;
    td2?: pulumi.Input<inputs.DestinationTeradataConfigurationLogmechTd2>;
}

export interface DestinationTeradataConfigurationLogmechLdap {
    /**
     * Enter the password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationTeradataConfigurationLogmechTd2 {
    /**
     * Enter the password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationTeradataConfigurationSslMode {
    /**
     * Allow SSL mode.
     */
    allow?: pulumi.Input<inputs.DestinationTeradataConfigurationSslModeAllow>;
    /**
     * Disable SSL.
     */
    disable?: pulumi.Input<inputs.DestinationTeradataConfigurationSslModeDisable>;
    /**
     * Prefer SSL mode.
     */
    prefer?: pulumi.Input<inputs.DestinationTeradataConfigurationSslModePrefer>;
    /**
     * Require SSL mode.
     */
    require?: pulumi.Input<inputs.DestinationTeradataConfigurationSslModeRequire>;
    /**
     * Verify-ca SSL mode.
     */
    verifyCa?: pulumi.Input<inputs.DestinationTeradataConfigurationSslModeVerifyCa>;
    /**
     * Verify-full SSL mode.
     */
    verifyFull?: pulumi.Input<inputs.DestinationTeradataConfigurationSslModeVerifyFull>;
}

export interface DestinationTeradataConfigurationSslModeAllow {
}

export interface DestinationTeradataConfigurationSslModeDisable {
}

export interface DestinationTeradataConfigurationSslModePrefer {
}

export interface DestinationTeradataConfigurationSslModeRequire {
}

export interface DestinationTeradataConfigurationSslModeVerifyCa {
    /**
     * Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-ca.
     *  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
     */
    sslCaCertificate: pulumi.Input<string>;
}

export interface DestinationTeradataConfigurationSslModeVerifyFull {
    /**
     * Specifies the file name of a PEM file that contains Certificate Authority (CA) certificates for use with SSLMODE=verify-full.
     *  See more information - <a href="https://teradata-docs.s3.amazonaws.com/doc/connectivity/jdbc/reference/current/jdbcug_chapter_2.html#URL_SSLCA"> in the docs</a>.
     */
    sslCaCertificate: pulumi.Input<string>;
}

export interface DestinationTeradataResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationTeradataResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationTeradataResourceAllocationJobSpecific>[]>;
}

export interface DestinationTeradataResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationTeradataResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationTeradataResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationTeradataResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationTimeplusConfiguration {
    /**
     * Personal API key
     */
    apikey: pulumi.Input<string>;
    /**
     * Timeplus workspace endpoint. Default: "https://us-west-2.timeplus.cloud/<workspace_id>"
     */
    endpoint?: pulumi.Input<string>;
}

export interface DestinationTimeplusResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationTimeplusResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationTimeplusResourceAllocationJobSpecific>[]>;
}

export interface DestinationTimeplusResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationTimeplusResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationTimeplusResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationTimeplusResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationTypesenseConfiguration {
    /**
     * Typesense API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * How many documents should be imported together. Default 1000
     */
    batchSize?: pulumi.Input<number>;
    /**
     * Hostname of the Typesense instance without protocol. Accept multiple hosts separated by comma.
     */
    host: pulumi.Input<string>;
    /**
     * Path of the Typesense instance. Default is none
     */
    path?: pulumi.Input<string>;
    /**
     * Port of the Typesense instance. Ex: 8108, 80, 443. Default is 8108
     */
    port?: pulumi.Input<string>;
    /**
     * Protocol of the Typesense instance. Ex: http or https. Default is https
     */
    protocol?: pulumi.Input<string>;
}

export interface DestinationTypesenseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationTypesenseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationTypesenseResourceAllocationJobSpecific>[]>;
}

export interface DestinationTypesenseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationTypesenseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationTypesenseResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationTypesenseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationVectaraConfiguration {
    /**
     * The Name of Corpus to load data into
     */
    corpusName: pulumi.Input<string>;
    /**
     * Your customer id as it is in the authenticaion url
     */
    customerId: pulumi.Input<string>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * OAuth2.0 credentials used to authenticate admin actions (creating/deleting corpora)
     */
    oauth2: pulumi.Input<inputs.DestinationVectaraConfigurationOauth2>;
    /**
     * Parallelize indexing into Vectara with multiple threads. Default: false
     */
    parallelize?: pulumi.Input<boolean>;
    /**
     * List of fields in the record that should be in the section of the document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A field that will be used to populate the `title` of each document. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. Default: ""
     */
    titleField?: pulumi.Input<string>;
}

export interface DestinationVectaraConfigurationOauth2 {
    /**
     * OAuth2.0 client id
     */
    clientId: pulumi.Input<string>;
    /**
     * OAuth2.0 client secret
     */
    clientSecret: pulumi.Input<string>;
}

export interface DestinationVectaraResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationVectaraResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationVectaraResourceAllocationJobSpecific>[]>;
}

export interface DestinationVectaraResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationVectaraResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationVectaraResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationVectaraResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationWeaviateConfiguration {
    /**
     * Embedding configuration
     */
    embedding: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbedding>;
    /**
     * Indexing configuration
     */
    indexing: pulumi.Input<inputs.DestinationWeaviateConfigurationIndexing>;
    /**
     * Do not store the text that gets embedded along with the vector and the metadata in the destination. If set to true, only the vector and the metadata will be stored - in this case raw text for LLM use cases needs to be retrieved from another source. Default: false
     */
    omitRawText?: pulumi.Input<boolean>;
    processing: pulumi.Input<inputs.DestinationWeaviateConfigurationProcessing>;
}

export interface DestinationWeaviateConfigurationEmbedding {
    /**
     * Use the Azure-hosted OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    azureOpenAi?: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbeddingAzureOpenAi>;
    /**
     * Use the Cohere API to embed text.
     */
    cohere?: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbeddingCohere>;
    /**
     * Use a fake embedding made out of random vectors with 1536 embedding dimensions. This is useful for testing the data pipeline without incurring any costs.
     */
    fake?: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbeddingFake>;
    /**
     * Use a field in the record as the embedding. This is useful if you already have an embedding for your data and want to store it in the vector store.
     */
    fromField?: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbeddingFromField>;
    /**
     * Do not calculate and pass embeddings to Weaviate. Suitable for clusters with configured vectorizers to calculate embeddings within Weaviate or for classes that should only support regular text search.
     */
    noExternalEmbedding?: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbeddingNoExternalEmbedding>;
    /**
     * Use the OpenAI API to embed text. This option is using the text-embedding-ada-002 model with 1536 embedding dimensions.
     */
    openAi?: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbeddingOpenAi>;
    /**
     * Use a service that's compatible with the OpenAI API to embed text.
     */
    openAiCompatible?: pulumi.Input<inputs.DestinationWeaviateConfigurationEmbeddingOpenAiCompatible>;
}

export interface DestinationWeaviateConfigurationEmbeddingAzureOpenAi {
    /**
     * The base URL for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    apiBase: pulumi.Input<string>;
    /**
     * The deployment for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    deployment: pulumi.Input<string>;
    /**
     * The API key for your Azure OpenAI resource.  You can find this in the Azure portal under your Azure OpenAI resource
     */
    openaiKey: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationEmbeddingCohere {
    cohereKey: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationEmbeddingFake {
}

export interface DestinationWeaviateConfigurationEmbeddingFromField {
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * Name of the field in the record that contains the embedding
     */
    fieldName: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationEmbeddingNoExternalEmbedding {
}

export interface DestinationWeaviateConfigurationEmbeddingOpenAi {
    openaiKey: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationEmbeddingOpenAiCompatible {
    /**
     * Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The base URL for your OpenAI-compatible service
     */
    baseUrl: pulumi.Input<string>;
    /**
     * The number of dimensions the embedding model is generating
     */
    dimensions: pulumi.Input<number>;
    /**
     * The name of the model to use for embedding. Default: "text-embedding-ada-002"
     */
    modelName?: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationIndexing {
    /**
     * Additional HTTP headers to send with every request.
     */
    additionalHeaders?: pulumi.Input<pulumi.Input<inputs.DestinationWeaviateConfigurationIndexingAdditionalHeader>[]>;
    /**
     * Authentication method
     */
    auth: pulumi.Input<inputs.DestinationWeaviateConfigurationIndexingAuth>;
    /**
     * The number of records to send to Weaviate in each batch. Default: 128
     */
    batchSize?: pulumi.Input<number>;
    /**
     * The vectorizer to use if new classes need to be created. Default: "none"; must be one of ["none", "text2vec-cohere", "text2vec-huggingface", "text2vec-openai", "text2vec-palm", "text2vec-contextionary", "text2vec-transformers", "text2vec-gpt4all"]
     */
    defaultVectorizer?: pulumi.Input<string>;
    /**
     * The public endpoint of the Weaviate cluster.
     */
    host: pulumi.Input<string>;
    /**
     * The tenant ID to use for multi tenancy. Default: ""
     */
    tenantId?: pulumi.Input<string>;
    /**
     * The field in the object that contains the embedded text. Default: "text"
     */
    textField?: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationIndexingAdditionalHeader {
    headerKey: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationIndexingAuth {
    /**
     * Authenticate using an API token (suitable for Weaviate Cloud)
     */
    apiToken?: pulumi.Input<inputs.DestinationWeaviateConfigurationIndexingAuthApiToken>;
    /**
     * Do not authenticate (suitable for locally running test clusters, do not use for clusters with public IP addresses)
     */
    noAuthentication?: pulumi.Input<inputs.DestinationWeaviateConfigurationIndexingAuthNoAuthentication>;
    /**
     * Authenticate using username and password (suitable for self-managed Weaviate clusters)
     */
    usernamePassword?: pulumi.Input<inputs.DestinationWeaviateConfigurationIndexingAuthUsernamePassword>;
}

export interface DestinationWeaviateConfigurationIndexingAuthApiToken {
    /**
     * API Token for the Weaviate instance
     */
    token: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationIndexingAuthNoAuthentication {
}

export interface DestinationWeaviateConfigurationIndexingAuthUsernamePassword {
    /**
     * Password for the Weaviate cluster
     */
    password: pulumi.Input<string>;
    /**
     * Username for the Weaviate cluster
     */
    username: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationProcessing {
    /**
     * Size of overlap between chunks in tokens to store in vector store to better capture relevant context. Default: 0
     */
    chunkOverlap?: pulumi.Input<number>;
    /**
     * Size of chunks in tokens to store in vector store (make sure it is not too big for the context if your LLM)
     */
    chunkSize: pulumi.Input<number>;
    /**
     * List of fields to rename. Not applicable for nested fields, but can be used to rename fields already flattened via dot notation.
     */
    fieldNameMappings?: pulumi.Input<pulumi.Input<inputs.DestinationWeaviateConfigurationProcessingFieldNameMapping>[]>;
    /**
     * List of fields in the record that should be stored as metadata. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered metadata fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array. When specifying nested paths, all matching values are flattened into an array set to a field named by the path.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * List of fields in the record that should be used to calculate the embedding. The field list is applied to all streams in the same way and non-existing fields are ignored. If none are defined, all fields are considered text fields. When specifying text fields, you can access nested fields in the record by using dot notation, e.g. `user.name` will access the `name` field in the `user` object. It's also possible to use wildcards to access all fields in an object, e.g. `users.*.name` will access all `names` fields in all entries of the `users` array.
     */
    textFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Split text fields into chunks based on the specified method.
     */
    textSplitter?: pulumi.Input<inputs.DestinationWeaviateConfigurationProcessingTextSplitter>;
}

export interface DestinationWeaviateConfigurationProcessingFieldNameMapping {
    /**
     * The field name in the source
     */
    fromField: pulumi.Input<string>;
    /**
     * The field name to use in the destination
     */
    toField: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationProcessingTextSplitter {
    /**
     * Split the text by Markdown headers down to the specified header level. If the chunk size fits multiple sections, they will be combined into a single chunk.
     */
    byMarkdownHeader?: pulumi.Input<inputs.DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader>;
    /**
     * Split the text by suitable delimiters based on the programming language. This is useful for splitting code into chunks.
     */
    byProgrammingLanguage?: pulumi.Input<inputs.DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguage>;
    /**
     * Split the text by the list of separators until the chunk size is reached, using the earlier mentioned separators where possible. This is useful for splitting text fields by paragraphs, sentences, words, etc.
     */
    bySeparator?: pulumi.Input<inputs.DestinationWeaviateConfigurationProcessingTextSplitterBySeparator>;
}

export interface DestinationWeaviateConfigurationProcessingTextSplitterByMarkdownHeader {
    /**
     * Level of markdown headers to split text fields by. Headings down to the specified level will be used as split points. Default: 1
     */
    splitLevel?: pulumi.Input<number>;
}

export interface DestinationWeaviateConfigurationProcessingTextSplitterByProgrammingLanguage {
    /**
     * Split code in suitable places based on the programming language. must be one of ["cpp", "go", "java", "js", "php", "proto", "python", "rst", "ruby", "rust", "scala", "swift", "markdown", "latex", "html", "sol"]
     */
    language: pulumi.Input<string>;
}

export interface DestinationWeaviateConfigurationProcessingTextSplitterBySeparator {
    /**
     * Whether to keep the separator in the resulting chunks. Default: false
     */
    keepSeparator?: pulumi.Input<boolean>;
    /**
     * List of separator strings to split text fields by. The separator itself needs to be wrapped in double quotes, e.g. to split by the dot character, use ".". To split by a newline, use "\n".
     */
    separators?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface DestinationWeaviateResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationWeaviateResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationWeaviateResourceAllocationJobSpecific>[]>;
}

export interface DestinationWeaviateResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationWeaviateResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationWeaviateResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationWeaviateResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationYellowbrickConfiguration {
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database. Default: 5432
     */
    port?: pulumi.Input<number>;
    /**
     * The default schema tables are written to if the source does not specify a namespace. The usual value for this field is "public". Default: "public"
     */
    schema?: pulumi.Input<string>;
    /**
     * Encrypt data using SSL. When activating SSL, please select one of the connection modes. Default: false
     */
    ssl?: pulumi.Input<boolean>;
    /**
     * SSL connection modes. 
     *  <b>disable</b> - Chose this mode to disable encryption of communication between Airbyte and destination database
     *  <b>allow</b> - Chose this mode to enable encryption only when required by the source database
     *  <b>prefer</b> - Chose this mode to allow unencrypted connection only if the source database does not support encryption
     *  <b>require</b> - Chose this mode to always require encryption. If the source database server does not support encryption, connection will fail
     *   <b>verify-ca</b> - Chose this mode to always require encryption and to verify that the source database server has a valid SSL certificate
     *   <b>verify-full</b> - This is the most secure mode. Chose this mode to always require encryption and to verify the identity of the source database server
     *  See more information - <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
     */
    sslMode?: pulumi.Input<inputs.DestinationYellowbrickConfigurationSslMode>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.DestinationYellowbrickConfigurationTunnelMethod>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface DestinationYellowbrickConfigurationSslMode {
    /**
     * Allow SSL mode.
     */
    allow?: pulumi.Input<inputs.DestinationYellowbrickConfigurationSslModeAllow>;
    /**
     * Disable SSL.
     */
    disable?: pulumi.Input<inputs.DestinationYellowbrickConfigurationSslModeDisable>;
    /**
     * Prefer SSL mode.
     */
    prefer?: pulumi.Input<inputs.DestinationYellowbrickConfigurationSslModePrefer>;
    /**
     * Require SSL mode.
     */
    require?: pulumi.Input<inputs.DestinationYellowbrickConfigurationSslModeRequire>;
    /**
     * Verify-ca SSL mode.
     */
    verifyCa?: pulumi.Input<inputs.DestinationYellowbrickConfigurationSslModeVerifyCa>;
    /**
     * Verify-full SSL mode.
     */
    verifyFull?: pulumi.Input<inputs.DestinationYellowbrickConfigurationSslModeVerifyFull>;
}

export interface DestinationYellowbrickConfigurationSslModeAllow {
}

export interface DestinationYellowbrickConfigurationSslModeDisable {
}

export interface DestinationYellowbrickConfigurationSslModePrefer {
}

export interface DestinationYellowbrickConfigurationSslModeRequire {
}

export interface DestinationYellowbrickConfigurationSslModeVerifyCa {
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
}

export interface DestinationYellowbrickConfigurationSslModeVerifyFull {
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Client certificate
     */
    clientCertificate: pulumi.Input<string>;
    /**
     * Client key
     */
    clientKey: pulumi.Input<string>;
    /**
     * Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
}

export interface DestinationYellowbrickConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.DestinationYellowbrickConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface DestinationYellowbrickConfigurationTunnelMethodNoTunnel {
}

export interface DestinationYellowbrickConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface DestinationYellowbrickConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface DestinationYellowbrickResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.DestinationYellowbrickResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.DestinationYellowbrickResourceAllocationJobSpecific>[]>;
}

export interface DestinationYellowbrickResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface DestinationYellowbrickResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.DestinationYellowbrickResourceAllocationJobSpecificResourceRequirements>;
}

export interface DestinationYellowbrickResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface Source100msConfiguration {
    /**
     * The management token used for authenticating API requests. You can find or generate this token in your 100ms dashboard under the API section. Refer to the documentation at https://www.100ms.live/docs/concepts/v2/concepts/security-and-tokens#management-token-for-rest-api for more details.
     */
    managementToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface Source100msResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.Source100msResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.Source100msResourceAllocationJobSpecific>[]>;
}

export interface Source100msResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface Source100msResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.Source100msResourceAllocationJobSpecificResourceRequirements>;
}

export interface Source100msResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface Source7shiftsConfiguration {
    /**
     * Access token to use for authentication. Generate it in the 7shifts Developer Tools.
     */
    accessToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface Source7shiftsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.Source7shiftsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.Source7shiftsResourceAllocationJobSpecific>[]>;
}

export interface Source7shiftsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface Source7shiftsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.Source7shiftsResourceAllocationJobSpecificResourceRequirements>;
}

export interface Source7shiftsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceActivecampaignConfiguration {
    /**
     * Account Username
     */
    accountUsername: pulumi.Input<string>;
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceActivecampaignResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceActivecampaignResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceActivecampaignResourceAllocationJobSpecific>[]>;
}

export interface SourceActivecampaignResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceActivecampaignResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceActivecampaignResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceActivecampaignResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAgilecrmConfiguration {
    /**
     * API key to use. Find it at Admin Settings > API & Analytics > API Key in your Agile CRM account.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The specific subdomain for your Agile CRM account
     */
    domain: pulumi.Input<string>;
    /**
     * Your Agile CRM account email address. This is used as the username for authentication.
     */
    email: pulumi.Input<string>;
}

export interface SourceAgilecrmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAgilecrmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAgilecrmResourceAllocationJobSpecific>[]>;
}

export interface SourceAgilecrmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAgilecrmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAgilecrmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAgilecrmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAhaConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * URL
     */
    url: pulumi.Input<string>;
}

export interface SourceAhaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAhaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAhaResourceAllocationJobSpecific>[]>;
}

export interface SourceAhaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAhaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAhaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAhaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAirbyteConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The Host URL of your Self-Managed Deployment (e.x. airbtye.mydomain.com)
     */
    host?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceAirbyteResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAirbyteResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAirbyteResourceAllocationJobSpecific>[]>;
}

export interface SourceAirbyteResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAirbyteResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAirbyteResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAirbyteResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAircallConfiguration {
    /**
     * App ID found at settings https://dashboard.aircall.io/integrations/api-keys
     */
    apiId: pulumi.Input<string>;
    /**
     * App token found at settings (Ref- https://dashboard.aircall.io/integrations/api-keys)
     */
    apiToken: pulumi.Input<string>;
    /**
     * Date time filter for incremental filter, Specify which date to extract from.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceAircallResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAircallResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAircallResourceAllocationJobSpecific>[]>;
}

export interface SourceAircallResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAircallResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAircallResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAircallResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAirtableConfiguration {
    credentials?: pulumi.Input<inputs.SourceAirtableConfigurationCredentials>;
}

export interface SourceAirtableConfigurationCredentials {
    oAuth20?: pulumi.Input<inputs.SourceAirtableConfigurationCredentialsOAuth20>;
    personalAccessToken?: pulumi.Input<inputs.SourceAirtableConfigurationCredentialsPersonalAccessToken>;
}

export interface SourceAirtableConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The client ID of the Airtable developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret of the Airtable developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The key to refresh the expired access token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The date-time when the access token should be refreshed.
     */
    tokenExpiryDate?: pulumi.Input<string>;
}

export interface SourceAirtableConfigurationCredentialsPersonalAccessToken {
    /**
     * The Personal Access Token for the Airtable account. See the <a href="https://airtable.com/developers/web/guides/personal-access-tokens">Support Guide</a> for more information on how to obtain this token.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceAirtableResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAirtableResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAirtableResourceAllocationJobSpecific>[]>;
}

export interface SourceAirtableResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAirtableResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAirtableResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAirtableResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAkeneoConfiguration {
    apiUsername: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    /**
     * https://cb8715249e.trial.akeneo.cloud
     */
    host: pulumi.Input<string>;
    password: pulumi.Input<string>;
    secret?: pulumi.Input<string>;
}

export interface SourceAkeneoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAkeneoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAkeneoResourceAllocationJobSpecific>[]>;
}

export interface SourceAkeneoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAkeneoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAkeneoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAkeneoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAlgoliaConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * The application ID for your application found in settings
     */
    applicationId: pulumi.Input<string>;
    /**
     * Object ID within index for search queries. Default: "ecommerce-sample-data-9999996"
     */
    objectId?: pulumi.Input<string>;
    /**
     * Search query to be used with indexes_query stream with format defined in `https://www.algolia.com/doc/rest-api/search/#tag/Search/operation/searchSingleIndex`. Default: "hitsPerPage=2&getRankingInfo=1"
     */
    searchQuery?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceAlgoliaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAlgoliaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAlgoliaResourceAllocationJobSpecific>[]>;
}

export interface SourceAlgoliaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAlgoliaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAlgoliaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAlgoliaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAlpacaBrokerApiConfiguration {
    /**
     * The trading environment, either 'live', 'paper' or 'broker-api.sandbox'. Default: "broker-api.sandbox"; must be one of ["api", "paper-api", "broker-api.sandbox"]
     */
    environment?: pulumi.Input<string>;
    /**
     * Limit for each response objects. Default: "20"
     */
    limit?: pulumi.Input<string>;
    /**
     * Your Alpaca API Secret Key. You can find this in the Alpaca developer web console under your account settings.
     */
    password?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * API Key ID for the alpaca market
     */
    username: pulumi.Input<string>;
}

export interface SourceAlpacaBrokerApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAlpacaBrokerApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAlpacaBrokerApiResourceAllocationJobSpecific>[]>;
}

export interface SourceAlpacaBrokerApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAlpacaBrokerApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAlpacaBrokerApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAlpacaBrokerApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAlphaVantageConfiguration {
    /**
     * Whether to return adjusted data. Only applicable to intraday endpoints. Default: false
     */
    adjusted?: pulumi.Input<boolean>;
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * Time-series data point interval. Required for intraday endpoints. Default: "1min"; must be one of ["1min", "5min", "15min", "30min", "60min"]
     */
    interval?: pulumi.Input<string>;
    /**
     * Whether to return full or compact data (the last 100 data points). Default: "compact"; must be one of ["compact", "full"]
     */
    outputsize?: pulumi.Input<string>;
    /**
     * Stock symbol (with exchange code)
     */
    symbol: pulumi.Input<string>;
}

export interface SourceAlphaVantageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAlphaVantageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAlphaVantageResourceAllocationJobSpecific>[]>;
}

export interface SourceAlphaVantageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAlphaVantageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAlphaVantageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAlphaVantageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmazonAdsConfiguration {
    /**
     * The client ID of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret of your Amazon Ads developer application. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens#retrieve-your-client-id-and-client-secret">docs</a> for more information.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The amount of days to go back in time to get the updated data from Amazon Ads. Default: 3
     */
    lookBackWindow?: pulumi.Input<number>;
    /**
     * Marketplace IDs you want to fetch data for. Note: If Profile IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
     */
    marketplaceIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Profile IDs you want to fetch data for. The Amazon Ads source connector supports only profiles with seller and vendor type, profiles with agency type will be ignored. See <a href="https://advertising.amazon.com/API/docs/en-us/concepts/authorization/profiles">docs</a> for more details. Note: If Marketplace IDs are also selected, profiles will be selected if they match the Profile ID OR the Marketplace ID.
     */
    profiles?: pulumi.Input<pulumi.Input<number>[]>;
    /**
     * Amazon Ads refresh token. See the <a href="https://advertising.amazon.com/API/docs/en-us/get-started/generate-api-tokens">docs</a> for more information on how to obtain this token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * Region to pull data from (EU/NA/FE). See <a href="https://advertising.amazon.com/API/docs/en-us/info/api-overview#api-endpoints">docs</a> for more details. Default: "NA"; must be one of ["NA", "EU", "FE"]
     */
    region?: pulumi.Input<string>;
    /**
     * The Start date for collecting reports, should not be more than 60 days in the past. In YYYY-MM-DD format
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceAmazonAdsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAmazonAdsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAmazonAdsResourceAllocationJobSpecific>[]>;
}

export interface SourceAmazonAdsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmazonAdsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAmazonAdsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAmazonAdsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmazonSellerPartnerConfiguration {
    /**
     * Type of the Account you're going to authorize the Airbyte application by. Default: "Seller"; must be one of ["Seller", "Vendor"]
     */
    accountType?: pulumi.Input<string>;
    /**
     * Your Amazon Application ID.
     */
    appId?: pulumi.Input<string>;
    /**
     * Select the AWS Environment. Default: "PRODUCTION"; must be one of ["PRODUCTION", "SANDBOX"]
     */
    awsEnvironment?: pulumi.Input<string>;
    /**
     * The time window size (in days) for fetching financial events data in chunks. Options are 1 day, 7 days, 14 days, 30 days, 60 days, and 190 days, based on API limitations.
     *
     * - **Smaller step sizes (e.g., 1 day)** are better for large data volumes. They fetch smaller chunks per request, reducing the risk of timeouts or overwhelming the API, though more requests may slow syncing and increase the chance of hitting rate limits.
     * - **Larger step sizes (e.g., 14 days)** are better for smaller data volumes. They fetch more data per request, speeding up syncing and reducing the number of API calls, which minimizes strain on rate limits.
     *
     * Select a step size that matches your data volume to optimize syncing speed and API performance.
     * Default: "180"; must be one of ["1", "7", "14", "30", "60", "90", "180"]
     */
    financialEventsStep?: pulumi.Input<string>;
    /**
     * Your Login with Amazon Client ID.
     */
    lwaAppId: pulumi.Input<string>;
    /**
     * Your Login with Amazon Client Secret.
     */
    lwaClientSecret: pulumi.Input<string>;
    /**
     * For syncs spanning a large date range, this option is used to request data in a smaller fixed window to improve sync reliability. This time window can be configured granularly by day. Default: 90
     */
    periodInDays?: pulumi.Input<number>;
    /**
     * The Refresh Token obtained via OAuth flow authorization.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * Select the AWS Region. Default: "US"; must be one of ["AE", "AU", "BE", "BR", "CA", "DE", "EG", "ES", "FR", "GB", "IN", "IT", "JP", "MX", "NL", "PL", "SA", "SE", "SG", "TR", "UK", "US"]
     */
    region?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data after this date will not be replicated.
     */
    replicationEndDate?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If start date is not provided or older than 2 years ago from today, the date 2 years ago from today will be used.
     */
    replicationStartDate?: pulumi.Input<string>;
    /**
     * Additional information passed to reports. This varies by report type.
     */
    reportOptionsLists?: pulumi.Input<pulumi.Input<inputs.SourceAmazonSellerPartnerConfigurationReportOptionsList>[]>;
    /**
     * For report based streams with known amount of requests per time period, this option will use waiting time between requests to avoid fatal statuses in reports. See <a href="https://docs.airbyte.com/integrations/sources/amazon-seller-partner#limitations--troubleshooting" target="_blank">Troubleshooting</a> section for more details. Default: false
     */
    waitToAvoidFatalErrors?: pulumi.Input<boolean>;
}

export interface SourceAmazonSellerPartnerConfigurationReportOptionsList {
    /**
     * List of options
     */
    optionsLists: pulumi.Input<pulumi.Input<inputs.SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList>[]>;
    /**
     * must be one of ["GET_AFN_INVENTORY_DATA", "GET_AFN_INVENTORY_DATA_BY_COUNTRY", "GET_AMAZON_FULFILLED_SHIPMENTS_DATA_GENERAL", "GET_FBA_ESTIMATED_FBA_FEES_TXT_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_RETURNS_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_PROMOTION_DATA", "GET_FBA_FULFILLMENT_CUSTOMER_SHIPMENT_REPLACEMENT_DATA", "GET_FBA_FULFILLMENT_REMOVAL_ORDER_DETAIL_DATA", "GET_FBA_FULFILLMENT_REMOVAL_SHIPMENT_DETAIL_DATA", "GET_FBA_INVENTORY_PLANNING_DATA", "GET_FBA_MYI_UNSUPPRESSED_INVENTORY_DATA", "GET_FBA_REIMBURSEMENTS_DATA", "GET_FBA_SNS_FORECAST_DATA", "GET_FBA_SNS_PERFORMANCE_DATA", "GET_FBA_STORAGE_FEE_CHARGES_DATA", "GET_FLAT_FILE_ACTIONABLE_ORDER_DATA_SHIPPING", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_LAST_UPDATE_GENERAL", "GET_FLAT_FILE_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_FLAT_FILE_ARCHIVED_ORDERS_DATA_BY_ORDER_DATE", "GET_FLAT_FILE_OPEN_LISTINGS_DATA", "GET_FLAT_FILE_RETURNS_DATA_BY_RETURN_DATE", "GET_LEDGER_DETAIL_VIEW_DATA", "GET_LEDGER_SUMMARY_VIEW_DATA", "GET_MERCHANT_CANCELLED_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_ALL_DATA", "GET_MERCHANT_LISTINGS_DATA", "GET_MERCHANT_LISTINGS_DATA_BACK_COMPAT", "GET_MERCHANT_LISTINGS_INACTIVE_DATA", "GET_MERCHANTS_LISTINGS_FYP_REPORT", "GET_ORDER_REPORT_DATA_SHIPPING", "GET_RESTOCK_INVENTORY_RECOMMENDATIONS_REPORT", "GET_SELLER_FEEDBACK_DATA", "GET_STRANDED_INVENTORY_UI_DATA", "GET_V2_SETTLEMENT_REPORT_DATA_FLAT_FILE", "GET_XML_ALL_ORDERS_DATA_BY_ORDER_DATE_GENERAL", "GET_XML_BROWSE_TREE_DATA", "GET_VENDOR_REAL_TIME_INVENTORY_REPORT"]
     */
    reportName: pulumi.Input<string>;
    streamName: pulumi.Input<string>;
}

export interface SourceAmazonSellerPartnerConfigurationReportOptionsListOptionsList {
    optionName: pulumi.Input<string>;
    optionValue: pulumi.Input<string>;
}

export interface SourceAmazonSellerPartnerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAmazonSellerPartnerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAmazonSellerPartnerResourceAllocationJobSpecific>[]>;
}

export interface SourceAmazonSellerPartnerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmazonSellerPartnerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAmazonSellerPartnerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAmazonSellerPartnerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmazonSqsConfiguration {
    /**
     * The Access Key ID of the AWS IAM Role to use for pulling messages
     */
    accessKey: pulumi.Input<string>;
    /**
     * Comma separated list of Mesage Attribute names to return. Default: "All"
     */
    attributesToReturn?: pulumi.Input<string>;
    /**
     * Max amount of messages to get in one batch (10 max). Default: 10
     */
    maxBatchSize?: pulumi.Input<number>;
    /**
     * Max amount of time in seconds to wait for messages in a single poll (20 max). Default: 20
     */
    maxWaitTime?: pulumi.Input<number>;
    /**
     * URL of the SQS Queue
     */
    queueUrl: pulumi.Input<string>;
    /**
     * AWS Region of the SQS Queue. Default: "us-east-1"; must be one of ["af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
     */
    region?: pulumi.Input<string>;
    /**
     * The Secret Key of the AWS IAM Role to use for pulling messages
     */
    secretKey: pulumi.Input<string>;
    /**
     * Note - Different targets have different attribute enum requirements, please refer actions sections in https://docs.aws.amazon.com/AWSSimpleQueueService/latest/APIReference/Welcome.html. Default: "ReceiveMessage"; must be one of ["GetQueueAttributes", "ReceiveMessage"]
     */
    target?: pulumi.Input<string>;
    /**
     * Modify the Visibility Timeout of the individual message from the Queue's default (seconds). Default: 20
     */
    visibilityTimeout?: pulumi.Input<number>;
}

export interface SourceAmazonSqsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAmazonSqsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAmazonSqsResourceAllocationJobSpecific>[]>;
}

export interface SourceAmazonSqsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmazonSqsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAmazonSqsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAmazonSqsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmplitudeConfiguration {
    /**
     * According to <a href="https://amplitude.com/docs/apis/analytics/dashboard-rest#query-parameters">Amplitude documentation</a>, grouping by `Country` is optional. If you face issues fetching the stream or checking the connection please set this field to `False`. Default: true
     */
    activeUsersGroupByCountry?: pulumi.Input<boolean>;
    /**
     * Amplitude API Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Amplitude data region server. Default: "Standard Server"; must be one of ["Standard Server", "EU Residency Server"]
     */
    dataRegion?: pulumi.Input<string>;
    /**
     * According to <a href="https://www.docs.developers.amplitude.com/analytics/apis/export-api/#considerations">Considerations</a> too large of a time range in te request can cause a timeout error. In this case, please provide a shorter time interval in hours. Default: 24
     */
    requestTimeRange?: pulumi.Input<number>;
    /**
     * Amplitude Secret Key. See the <a href="https://docs.airbyte.com/integrations/sources/amplitude#setup-guide">setup guide</a> for more information on how to obtain this key.
     */
    secretKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2021-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceAmplitudeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAmplitudeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAmplitudeResourceAllocationJobSpecific>[]>;
}

export interface SourceAmplitudeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAmplitudeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAmplitudeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAmplitudeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceApifyDatasetConfiguration {
    /**
     * ID of the dataset you would like to load to Airbyte. In Apify Console, you can view your datasets in the <a href="https://console.apify.com/storage/datasets">Storage section under the Datasets tab</a> after you login. See the <a href="https://docs.apify.com/platform/storage/dataset">Apify Docs</a> for more information.
     */
    datasetId: pulumi.Input<string>;
    /**
     * Personal API token of your Apify account. In Apify Console, you can find your API token in the <a href="https://console.apify.com/account/integrations">Settings section under the Integrations tab</a> after you login. See the <a href="https://docs.apify.com/platform/integrations/api#api-token">Apify Docs</a> for more information.
     */
    token: pulumi.Input<string>;
}

export interface SourceApifyDatasetResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceApifyDatasetResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceApifyDatasetResourceAllocationJobSpecific>[]>;
}

export interface SourceApifyDatasetResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceApifyDatasetResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceApifyDatasetResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceApifyDatasetResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppcuesConfiguration {
    /**
     * Account ID of Appcues found in account settings page (https://studio.appcues.com/settings/account)
     */
    accountId: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceAppcuesResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAppcuesResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAppcuesResourceAllocationJobSpecific>[]>;
}

export interface SourceAppcuesResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppcuesResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAppcuesResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAppcuesResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppfiguresConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Category term for grouping the search results. Default: "product"; must be one of ["network", "product", "country", "date"]
     */
    groupBy?: pulumi.Input<string>;
    /**
     * The store which needs to be searched in streams. Default: "apple"
     */
    searchStore?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceAppfiguresResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAppfiguresResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAppfiguresResourceAllocationJobSpecific>[]>;
}

export interface SourceAppfiguresResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppfiguresResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAppfiguresResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAppfiguresResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppfollowConfiguration {
    /**
     * API Key provided by Appfollow
     */
    apiSecret?: pulumi.Input<string>;
}

export interface SourceAppfollowResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAppfollowResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAppfollowResourceAllocationJobSpecific>[]>;
}

export interface SourceAppfollowResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppfollowResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAppfollowResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAppfollowResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppleSearchAdsConfiguration {
    /**
     * This factor factor determines the delay increase factor between retryable failures. Valid values are integers between 1 and 20. Default: 5
     */
    backoffFactor?: pulumi.Input<number>;
    /**
     * A user identifier for the token request. See <a href="https://developer.apple.com/documentation/apple_search_ads/implementing_oauth_for_the_apple_search_ads_api">here</a>
     */
    clientId: pulumi.Input<string>;
    /**
     * A string that authenticates the userâ€™s setup request. See <a href="https://developer.apple.com/documentation/apple_search_ads/implementing_oauth_for_the_apple_search_ads_api">here</a>
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Data is retrieved until that date (included)
     */
    endDate?: pulumi.Input<string>;
    /**
     * Apple Search Ads uses a 30-day attribution window. However, you may consider smaller values in order to shorten sync durations, at the cost of missing late data attributions. Default: 30
     */
    lookbackWindow?: pulumi.Input<number>;
    /**
     * The identifier of the organization that owns the campaign. Your Org Id is the same as your account in the Apple Search Ads UI.
     */
    orgId: pulumi.Input<number>;
    /**
     * Start getting data from that date.
     */
    startDate: pulumi.Input<string>;
    /**
     * The timezone for the reporting data. Use 'ORTZ' for Organization Time Zone or 'UTC' for Coordinated Universal Time. Default is UTC. Default: "UTC"; must be one of ["ORTZ", "UTC"]
     */
    timezone?: pulumi.Input<string>;
}

export interface SourceAppleSearchAdsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAppleSearchAdsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAppleSearchAdsResourceAllocationJobSpecific>[]>;
}

export interface SourceAppleSearchAdsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAppleSearchAdsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAppleSearchAdsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAppleSearchAdsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceApptivoConfiguration {
    accessKey: pulumi.Input<string>;
    /**
     * API key to use. Find it in your Apptivo account under Business Settings > API Access.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceApptivoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceApptivoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceApptivoResourceAllocationJobSpecific>[]>;
}

export interface SourceApptivoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceApptivoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceApptivoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceApptivoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAsanaConfiguration {
    /**
     * Choose how to authenticate to Github
     */
    credentials?: pulumi.Input<inputs.SourceAsanaConfigurationCredentials>;
    /**
     * The number of worker threads to use for the sync. The performance upper boundary is based on the limit of your Asana pricing plan. More info about the rate limit tiers can be found on Asana's API <a href="https://developers.asana.com/docs/rate-limits">docs</a>. Default: 10
     */
    numWorkers?: pulumi.Input<number>;
    /**
     * Globally unique identifiers for the organization exports
     */
    organizationExportIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceAsanaConfigurationCredentials {
    authenticateViaAsanaOauth?: pulumi.Input<inputs.SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth>;
    authenticateWithPersonalAccessToken?: pulumi.Input<inputs.SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken>;
}

export interface SourceAsanaConfigurationCredentialsAuthenticateViaAsanaOauth {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    refreshToken: pulumi.Input<string>;
}

export interface SourceAsanaConfigurationCredentialsAuthenticateWithPersonalAccessToken {
    /**
     * Asana Personal Access Token (generate yours <a href="https://app.asana.com/0/developer-console">here</a>).
     */
    personalAccessToken: pulumi.Input<string>;
}

export interface SourceAsanaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAsanaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAsanaResourceAllocationJobSpecific>[]>;
}

export interface SourceAsanaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAsanaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAsanaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAsanaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAshbyConfiguration {
    /**
     * The Ashby API Key, see <a href=\"https://developers.ashbyhq.com/reference/authentication\">doc</a> here.
     */
    apiKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceAshbyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAshbyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAshbyResourceAllocationJobSpecific>[]>;
}

export interface SourceAshbyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAshbyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAshbyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAshbyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAssemblyaiConfiguration {
    /**
     * Your AssemblyAI API key. You can find it in the AssemblyAI dashboard at https://www.assemblyai.com/app/api-keys.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The request ID for LeMur responses
     */
    requestId?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * The subtitle format for transcript_subtitle stream. Default: "srt"; must be one of ["vtt", "srt"]
     */
    subtitleFormat?: pulumi.Input<string>;
}

export interface SourceAssemblyaiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAssemblyaiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAssemblyaiResourceAllocationJobSpecific>[]>;
}

export interface SourceAssemblyaiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAssemblyaiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAssemblyaiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAssemblyaiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAuth0Configuration {
    /**
     * The Authentication API is served over HTTPS. All URLs referenced in the documentation have the following base `https://YOUR_DOMAIN`
     */
    baseUrl: pulumi.Input<string>;
    credentials: pulumi.Input<inputs.SourceAuth0ConfigurationCredentials>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Default: "2023-08-05T00:43:59.244Z"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceAuth0ConfigurationCredentials {
    oAuth2AccessToken?: pulumi.Input<inputs.SourceAuth0ConfigurationCredentialsOAuth2AccessToken>;
    oAuth2ConfidentialApplication?: pulumi.Input<inputs.SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication>;
}

export interface SourceAuth0ConfigurationCredentialsOAuth2AccessToken {
    /**
     * Also called <a href="https://auth0.com/docs/secure/tokens/access-tokens/get-management-api-access-tokens-for-testing">API Access Token </a> The access token used to call the Auth0 Management API Token. It's a JWT that contains specific grant permissions knowns as scopes.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceAuth0ConfigurationCredentialsOAuth2ConfidentialApplication {
    /**
     * The audience for the token, which is your API. You can find this in the Identifier field on your  <a href="https://manage.auth0.com/#/apis">API's settings tab</a>
     */
    audience: pulumi.Input<string>;
    /**
     * Your application's Client ID. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
     */
    clientId: pulumi.Input<string>;
    /**
     * Your application's Client Secret. You can find this value on the <a href="https://manage.auth0.com/#/applications">application's settings tab</a> after you login the admin portal.
     */
    clientSecret: pulumi.Input<string>;
}

export interface SourceAuth0ResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAuth0ResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAuth0ResourceAllocationJobSpecific>[]>;
}

export interface SourceAuth0ResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAuth0ResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAuth0ResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAuth0ResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAviationstackConfiguration {
    /**
     * Your unique API key for authenticating with the Aviation API. You can find it in your Aviation account dashboard at https://aviationstack.com/dashboard
     */
    accessKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceAviationstackResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAviationstackResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAviationstackResourceAllocationJobSpecific>[]>;
}

export interface SourceAviationstackResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAviationstackResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAviationstackResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAviationstackResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAwinAdvertiserConfiguration {
    /**
     * Your Awin Advertiser ID. You can find this in your Awin dashboard or account settings.
     */
    advertiserId: pulumi.Input<string>;
    /**
     * Your Awin API key. Generate this from your Awin account under API Credentials.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Number of days to look back on each sync to catch any updates to existing records.
     */
    lookbackDays: pulumi.Input<number>;
    /**
     * Start date for data replication in YYYY-MM-DD format
     */
    startDate: pulumi.Input<string>;
    /**
     * The time window size for each API request in ISO8601 duration format.
     * For the campaign performance stream, Awin API explicitly limits the period between startDate and endDate to 400 days maximum.
     * Default: "P400D"
     */
    stepIncrement?: pulumi.Input<string>;
}

export interface SourceAwinAdvertiserResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAwinAdvertiserResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAwinAdvertiserResourceAllocationJobSpecific>[]>;
}

export interface SourceAwinAdvertiserResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAwinAdvertiserResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAwinAdvertiserResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAwinAdvertiserResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAwsCloudtrailConfiguration {
    /**
     * AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
     */
    awsKeyId: pulumi.Input<string>;
    /**
     * The default AWS Region to use, for example, us-west-1 or us-west-2. When specifying a Region inline during client initialization, this property is named region_name. Default: "us-east-1"
     */
    awsRegionName?: pulumi.Input<string>;
    /**
     * AWS CloudTrail Access Key ID. See the <a href="https://docs.airbyte.com/integrations/sources/aws-cloudtrail">docs</a> for more information on how to obtain this key.
     */
    awsSecretKey: pulumi.Input<string>;
    lookupAttributesFilter?: pulumi.Input<inputs.SourceAwsCloudtrailConfigurationLookupAttributesFilter>;
    /**
     * The date you would like to replicate data. Data in AWS CloudTrail is available for last 90 days only. Format: YYYY-MM-DD.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceAwsCloudtrailConfigurationLookupAttributesFilter {
    /**
     * Default: "EventName"
     */
    attributeKey?: pulumi.Input<string>;
    /**
     * Default: "ListInstanceAssociations"
     */
    attributeValue?: pulumi.Input<string>;
}

export interface SourceAwsCloudtrailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAwsCloudtrailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAwsCloudtrailResourceAllocationJobSpecific>[]>;
}

export interface SourceAwsCloudtrailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAwsCloudtrailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAwsCloudtrailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAwsCloudtrailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAzureBlobStorageConfiguration {
    /**
     * The account's name of the Azure Blob Storage.
     */
    azureBlobStorageAccountName: pulumi.Input<string>;
    /**
     * The name of the Azure blob storage container.
     */
    azureBlobStorageContainerName: pulumi.Input<string>;
    /**
     * This is Azure Blob Storage endpoint domain name. Leave default value (or leave it empty if run container from command line) to use Microsoft native from example.
     */
    azureBlobStorageEndpoint?: pulumi.Input<string>;
    /**
     * Credentials for connecting to the Azure Blob Storage
     */
    credentials: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationCredentials>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStream>[]>;
}

export interface SourceAzureBlobStorageConfigurationCredentials {
    authenticateViaClientCredentials?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaClientCredentials>;
    authenticateViaOauth2?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2>;
    authenticateViaStorageAccountKey?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey>;
}

export interface SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaClientCredentials {
    /**
     * Client ID of your Microsoft developer application
     */
    appClientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    appClientSecret: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft Azure Application
     */
    appTenantId: pulumi.Input<string>;
}

export interface SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaOauth2 {
    /**
     * Client ID of your Microsoft developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token of your Microsoft developer application
     */
    refreshToken: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft Azure Application user
     */
    tenantId: pulumi.Input<string>;
}

export interface SourceAzureBlobStorageConfigurationCredentialsAuthenticateViaStorageAccountKey {
    /**
     * The Azure blob storage account key.
     */
    azureBlobStorageAccountKey: pulumi.Input<string>;
}

export interface SourceAzureBlobStorageConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * The number of resent files which will be used to discover the schema for this stream.
     */
    recentNFilesToReadForSchemaDiscovery?: pulumi.Input<number>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceAzureBlobStorageConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatJsonlFormat {
}

export interface SourceAzureBlobStorageConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceAzureBlobStorageConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
}

export interface SourceAzureBlobStorageConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceAzureBlobStorageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAzureBlobStorageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAzureBlobStorageResourceAllocationJobSpecific>[]>;
}

export interface SourceAzureBlobStorageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAzureBlobStorageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAzureBlobStorageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAzureBlobStorageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAzureTableConfiguration {
    /**
     * Azure Table Storage Access Key. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain this key.
     */
    storageAccessKey: pulumi.Input<string>;
    /**
     * The name of your storage account.
     */
    storageAccountName: pulumi.Input<string>;
    /**
     * Azure Table Storage service account URL suffix. See the <a href="https://docs.airbyte.com/integrations/sources/azure-table">docs</a> for more information on how to obtain endpoint suffix. Default: "core.windows.net"
     */
    storageEndpointSuffix?: pulumi.Input<string>;
}

export interface SourceAzureTableResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceAzureTableResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceAzureTableResourceAllocationJobSpecific>[]>;
}

export interface SourceAzureTableResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceAzureTableResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceAzureTableResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceAzureTableResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBabelforceConfiguration {
    /**
     * The Babelforce access key ID
     */
    accessKeyId: pulumi.Input<string>;
    /**
     * The Babelforce access token
     */
    accessToken: pulumi.Input<string>;
    /**
     * Timestamp in Unix the replication from Babelforce API will start from. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    dateCreatedFrom?: pulumi.Input<number>;
    /**
     * Timestamp in Unix the replication from Babelforce will be up to. For example 1651363200 which corresponds to 2022-05-01 00:00:00.
     */
    dateCreatedTo?: pulumi.Input<number>;
    /**
     * Babelforce region. Default: "services"; must be one of ["services", "us-east", "ap-southeast"]
     */
    region?: pulumi.Input<string>;
}

export interface SourceBabelforceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBabelforceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBabelforceResourceAllocationJobSpecific>[]>;
}

export interface SourceBabelforceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBabelforceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBabelforceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBabelforceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBambooHrConfiguration {
    /**
     * Api key of bamboo hr
     */
    apiKey: pulumi.Input<string>;
    /**
     * Comma-separated list of fields to include in custom reports.
     */
    customReportsFields?: pulumi.Input<string>;
    /**
     * If true, the custom reports endpoint will include the default fields defined here: https://documentation.bamboohr.com/docs/list-of-field-names. Default: true
     */
    customReportsIncludeDefaultFields?: pulumi.Input<boolean>;
    /**
     * Comma-separated list of fields to include for employees. Default: "firstName,lastName"
     */
    employeeFields?: pulumi.Input<string>;
    startDate?: pulumi.Input<string>;
    /**
     * Sub Domain of bamboo hr
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceBambooHrResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBambooHrResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBambooHrResourceAllocationJobSpecific>[]>;
}

export interface SourceBambooHrResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBambooHrResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBambooHrResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBambooHrResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBasecampConfiguration {
    accountId: pulumi.Input<number>;
    clientId: pulumi.Input<string>;
    clientRefreshToken2: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBasecampResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBasecampResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBasecampResourceAllocationJobSpecific>[]>;
}

export interface SourceBasecampResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBasecampResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBasecampResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBasecampResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBeamerConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBeamerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBeamerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBeamerResourceAllocationJobSpecific>[]>;
}

export interface SourceBeamerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBeamerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBeamerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBeamerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBigmailerConfiguration {
    /**
     * API key to use. You can create and find it on the API key management page in your BigMailer account.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceBigmailerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBigmailerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBigmailerResourceAllocationJobSpecific>[]>;
}

export interface SourceBigmailerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBigmailerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBigmailerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBigmailerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBigqueryConfiguration {
    /**
     * The contents of your Service Account Key JSON file. See the <a href="https://docs.airbyte.com/integrations/sources/bigquery#setup-the-bigquery-source-in-airbyte">docs</a> for more information on how to obtain this key.
     */
    credentialsJson: pulumi.Input<string>;
    /**
     * The dataset ID to search for tables and views. If you are only loading data from one dataset, setting this option could result in much faster schema discovery.
     */
    datasetId?: pulumi.Input<string>;
    /**
     * The GCP project ID for the project containing the target BigQuery dataset.
     */
    projectId: pulumi.Input<string>;
}

export interface SourceBigqueryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBigqueryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBigqueryResourceAllocationJobSpecific>[]>;
}

export interface SourceBigqueryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBigqueryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBigqueryResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBigqueryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBingAdsConfiguration {
    /**
     * Predicates that will be used to sync data by specific accounts.
     */
    accountNames?: pulumi.Input<pulumi.Input<inputs.SourceBingAdsConfigurationAccountName>[]>;
    /**
     * The Client ID of your Microsoft Advertising developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Microsoft Advertising developer application. Default: ""
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * You can add your Custom Bing Ads report by creating one.
     */
    customReports?: pulumi.Input<pulumi.Input<inputs.SourceBingAdsConfigurationCustomReport>[]>;
    /**
     * Developer token associated with user. See more info <a href="https://docs.microsoft.com/en-us/advertising/guides/get-started?view=bingads-13#get-developer-token"> in the docs</a>.
     */
    developerToken: pulumi.Input<string>;
    /**
     * Also known as attribution or conversion window. How far into the past to look for records (in days). If your conversion window has an hours/minutes granularity, round it up to the number of days exceeding. Used only for performance report streams in incremental mode without specified Reports Start Date. Default: 0
     */
    lookbackWindow?: pulumi.Input<number>;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The start date from which to begin replicating report data. Any data generated before this date will not be replicated in reports. This is a UTC date in YYYY-MM-DD format. If not set, data from previous and current calendar year will be replicated.
     */
    reportsStartDate?: pulumi.Input<string>;
    /**
     * The Tenant ID of your Microsoft Advertising developer application. Set this to "common" unless you know you need a different value. Default: "common"
     */
    tenantId?: pulumi.Input<string>;
}

export interface SourceBingAdsConfigurationAccountName {
    /**
     * Account Name is a string value for comparing with the specified predicate.
     */
    name: pulumi.Input<string>;
    /**
     * An Operator that will be used to filter accounts. The Contains predicate has features for matching words, matching inflectional forms of words, searching using wildcard characters, and searching using proximity. The Equals is used to return all rows where account name is equal(=) to the string that you provided. must be one of ["Contains", "Equals"]
     */
    operator: pulumi.Input<string>;
}

export interface SourceBingAdsConfigurationCustomReport {
    /**
     * The name of the custom report, this name would be used as stream name
     */
    name: pulumi.Input<string>;
    /**
     * A list of available aggregations. Default: "[Hourly]"
     */
    reportAggregation?: pulumi.Input<string>;
    /**
     * A list of available report object columns. You can find it in description of reporting object that you want to add to custom report.
     */
    reportColumns: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the the object derives from the ReportRequest object. You can find it in Bing Ads Api docs - Reporting API - Reporting Data Objects. must be one of ["AccountPerformanceReportRequest", "AdDynamicTextPerformanceReportRequest", "AdExtensionByAdReportRequest", "AdExtensionByKeywordReportRequest", "AdExtensionDetailReportRequest", "AdGroupPerformanceReportRequest", "AdPerformanceReportRequest", "AgeGenderAudienceReportRequest", "AudiencePerformanceReportRequest", "CallDetailReportRequest", "CampaignPerformanceReportRequest", "ConversionPerformanceReportRequest", "DestinationUrlPerformanceReportRequest", "DSAAutoTargetPerformanceReportRequest", "DSACategoryPerformanceReportRequest", "DSASearchQueryPerformanceReportRequest", "GeographicPerformanceReportRequest", "GoalsAndFunnelsReportRequest", "HotelDimensionPerformanceReportRequest", "HotelGroupPerformanceReportRequest", "KeywordPerformanceReportRequest", "NegativeKeywordConflictReportRequest", "ProductDimensionPerformanceReportRequest", "ProductMatchCountReportRequest", "ProductNegativeKeywordConflictReportRequest", "ProductPartitionPerformanceReportRequest", "ProductPartitionUnitPerformanceReportRequest", "ProductSearchQueryPerformanceReportRequest", "ProfessionalDemographicsAudienceReportRequest", "PublisherUsagePerformanceReportRequest", "SearchCampaignChangeHistoryReportRequest", "SearchQueryPerformanceReportRequest", "ShareOfVoiceReportRequest", "UserLocationPerformanceReportRequest"]
     */
    reportingObject: pulumi.Input<string>;
}

export interface SourceBingAdsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBingAdsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBingAdsResourceAllocationJobSpecific>[]>;
}

export interface SourceBingAdsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBingAdsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBingAdsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBingAdsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBitlyConfiguration {
    apiKey: pulumi.Input<string>;
    endDate: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBitlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBitlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBitlyResourceAllocationJobSpecific>[]>;
}

export interface SourceBitlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBitlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBitlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBitlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBloggerConfiguration {
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
}

export interface SourceBloggerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBloggerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBloggerResourceAllocationJobSpecific>[]>;
}

export interface SourceBloggerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBloggerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBloggerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBloggerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBluetallyConfiguration {
    /**
     * Your API key to authenticate with the BlueTally API. You can generate it by navigating to your account settings, selecting 'API Keys', and clicking 'Create API Key'.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBluetallyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBluetallyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBluetallyResourceAllocationJobSpecific>[]>;
}

export interface SourceBluetallyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBluetallyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBluetallyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBluetallyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBoldsignConfiguration {
    /**
     * Your BoldSign API key. You can generate it by navigating to the API menu in the BoldSign app, selecting 'API Key', and clicking 'Generate API Key'. Copy the generated key and paste it here.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBoldsignResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBoldsignResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBoldsignResourceAllocationJobSpecific>[]>;
}

export interface SourceBoldsignResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBoldsignResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBoldsignResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBoldsignResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBoxConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    user: pulumi.Input<number>;
}

export interface SourceBoxResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBoxResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBoxResourceAllocationJobSpecific>[]>;
}

export interface SourceBoxResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBoxResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBoxResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBoxResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBraintreeConfiguration {
    /**
     * Environment specifies where the data will come from. must be one of ["Development", "Sandbox", "Qa", "Production"]
     */
    environment: pulumi.Input<string>;
    /**
     * The unique identifier for your entire gateway account. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this ID.
     */
    merchantId: pulumi.Input<string>;
    /**
     * Braintree Private Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
     */
    privateKey: pulumi.Input<string>;
    /**
     * Braintree Public Key. See the <a href="https://docs.airbyte.com/integrations/sources/braintree">docs</a> for more information on how to obtain this key.
     */
    publicKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceBraintreeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBraintreeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBraintreeResourceAllocationJobSpecific>[]>;
}

export interface SourceBraintreeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBraintreeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBraintreeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBraintreeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBrazeConfiguration {
    /**
     * Braze REST API key
     */
    apiKey: pulumi.Input<string>;
    /**
     * Rows after this date will be synced
     */
    startDate: pulumi.Input<string>;
    /**
     * Braze REST API endpoint
     */
    url: pulumi.Input<string>;
}

export interface SourceBrazeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBrazeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBrazeResourceAllocationJobSpecific>[]>;
}

export interface SourceBrazeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBrazeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBrazeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBrazeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBreezometerConfiguration {
    /**
     * Your API Access Key. See <a href="https://docs.breezometer.com/api-documentation/introduction/#authentication/">here</a>.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Number of days to forecast. Minimum 1, maximum 3. Valid for Polen and Weather Forecast streams.
     */
    daysToForecast?: pulumi.Input<number>;
    /**
     * Number of hours retireve from Air Quality History stream. Minimum 1, maximum 720.
     */
    historicHours?: pulumi.Input<number>;
    /**
     * Number of hours to forecast. Minimum 1, maximum 96. Valid for Air Quality Forecast stream.
     */
    hoursToForecast?: pulumi.Input<number>;
    /**
     * Latitude of the monitored location.
     */
    latitude: pulumi.Input<string>;
    /**
     * Longitude of the monitored location.
     */
    longitude: pulumi.Input<string>;
    /**
     * Desired radius from the location provided. Minimum 5, maximum 100. Valid for Wildfires streams.
     */
    radius?: pulumi.Input<number>;
}

export interface SourceBreezometerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBreezometerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBreezometerResourceAllocationJobSpecific>[]>;
}

export interface SourceBreezometerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBreezometerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBreezometerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBreezometerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBreezyHrConfiguration {
    apiKey: pulumi.Input<string>;
    companyId: pulumi.Input<string>;
}

export interface SourceBreezyHrResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBreezyHrResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBreezyHrResourceAllocationJobSpecific>[]>;
}

export interface SourceBreezyHrResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBreezyHrResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBreezyHrResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBreezyHrResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBrevoConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBrevoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBrevoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBrevoResourceAllocationJobSpecific>[]>;
}

export interface SourceBrevoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBrevoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBrevoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBrevoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBrexConfiguration {
    startDate: pulumi.Input<string>;
    /**
     * User token to authenticate API requests. Generate it from your Brex dashboard under Developer > Settings.
     */
    userToken: pulumi.Input<string>;
}

export interface SourceBrexResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBrexResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBrexResourceAllocationJobSpecific>[]>;
}

export interface SourceBrexResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBrexResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBrexResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBrexResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBugsnagConfiguration {
    /**
     * Personal auth token for accessing the Bugsnag API. Generate it in the My Account section of Bugsnag settings.
     */
    authToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBugsnagResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBugsnagResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBugsnagResourceAllocationJobSpecific>[]>;
}

export interface SourceBugsnagResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBugsnagResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBugsnagResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBugsnagResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBuildkiteConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBuildkiteResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBuildkiteResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBuildkiteResourceAllocationJobSpecific>[]>;
}

export interface SourceBuildkiteResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBuildkiteResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBuildkiteResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBuildkiteResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBunnyIncConfiguration {
    apikey: pulumi.Input<string>;
    startDate?: pulumi.Input<string>;
    /**
     * The subdomain specific to your Bunny account or service.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceBunnyIncResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBunnyIncResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBunnyIncResourceAllocationJobSpecific>[]>;
}

export interface SourceBunnyIncResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBunnyIncResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBunnyIncResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBunnyIncResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBuzzsproutConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Podcast ID found in `https://www.buzzsprout.com/my/profile/api`
     */
    podcastId: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceBuzzsproutResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceBuzzsproutResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceBuzzsproutResourceAllocationJobSpecific>[]>;
}

export interface SourceBuzzsproutResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceBuzzsproutResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceBuzzsproutResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceBuzzsproutResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCalComConfiguration {
    /**
     * API key to use. Find it at https://cal.com/account
     */
    apiKey: pulumi.Input<string>;
    orgId: pulumi.Input<string>;
}

export interface SourceCalComResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCalComResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCalComResourceAllocationJobSpecific>[]>;
}

export interface SourceCalComResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCalComResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCalComResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCalComResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCalendlyConfiguration {
    /**
     * Go to Integrations â†’ API & Webhooks to obtain your bearer token. https://calendly.com/integrations/api_webhooks
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceCalendlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCalendlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCalendlyResourceAllocationJobSpecific>[]>;
}

export interface SourceCalendlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCalendlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCalendlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCalendlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCallrailConfiguration {
    /**
     * Account ID
     */
    accountId: pulumi.Input<string>;
    /**
     * API access key
     */
    apiKey: pulumi.Input<string>;
    /**
     * Start getting data from that date.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceCallrailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCallrailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCallrailResourceAllocationJobSpecific>[]>;
}

export interface SourceCallrailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCallrailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCallrailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCallrailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCampaignMonitorConfiguration {
    password?: pulumi.Input<string>;
    /**
     * Date from when the sync should start
     */
    startDate?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceCampaignMonitorResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCampaignMonitorResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCampaignMonitorResourceAllocationJobSpecific>[]>;
}

export interface SourceCampaignMonitorResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCampaignMonitorResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCampaignMonitorResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCampaignMonitorResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCampaynConfiguration {
    /**
     * API key to use. Find it in your Campayn account settings. Keep it secure as it grants access to your Campayn data.
     */
    apiKey: pulumi.Input<string>;
    subDomain: pulumi.Input<string>;
}

export interface SourceCampaynResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCampaynResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCampaynResourceAllocationJobSpecific>[]>;
}

export interface SourceCampaynResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCampaynResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCampaynResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCampaynResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCannyConfiguration {
    /**
     * You can find your secret API key in Your Canny Subdomain > Settings > API
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceCannyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCannyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCannyResourceAllocationJobSpecific>[]>;
}

export interface SourceCannyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCannyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCannyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCannyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCapsuleCrmConfiguration {
    /**
     * Bearer token to authenticate API requests. Generate it from the 'My Preferences' > 'API Authentication Tokens' page in your Capsule account.
     */
    bearerToken: pulumi.Input<string>;
    /**
     * must be one of ["parties", "opportunities", "kases"]
     */
    entity: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceCapsuleCrmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCapsuleCrmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCapsuleCrmResourceAllocationJobSpecific>[]>;
}

export interface SourceCapsuleCrmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCapsuleCrmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCapsuleCrmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCapsuleCrmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCaptainDataConfiguration {
    /**
     * Your Captain Data project API key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Your Captain Data project uuid.
     */
    projectUid: pulumi.Input<string>;
}

export interface SourceCaptainDataResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCaptainDataResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCaptainDataResourceAllocationJobSpecific>[]>;
}

export interface SourceCaptainDataResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCaptainDataResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCaptainDataResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCaptainDataResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCareQualityCommissionConfiguration {
    /**
     * Your CQC Primary Key. See https://www.cqc.org.uk/about-us/transparency/using-cqc-data#api for steps to generate one.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceCareQualityCommissionResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCareQualityCommissionResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCareQualityCommissionResourceAllocationJobSpecific>[]>;
}

export interface SourceCareQualityCommissionResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCareQualityCommissionResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCareQualityCommissionResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCareQualityCommissionResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCartConfiguration {
    credentials?: pulumi.Input<inputs.SourceCartConfigurationCredentials>;
    /**
     * The date from which you'd like to replicate the data
     */
    startDate: pulumi.Input<string>;
}

export interface SourceCartConfigurationCredentials {
    centralApiRouter?: pulumi.Input<inputs.SourceCartConfigurationCredentialsCentralApiRouter>;
    singleStoreAccessToken?: pulumi.Input<inputs.SourceCartConfigurationCredentialsSingleStoreAccessToken>;
}

export interface SourceCartConfigurationCredentialsCentralApiRouter {
    /**
     * You can determine a site provisioning site Id by hitting https://site.com/store/sitemonitor.aspx and reading the response param PSID
     */
    siteId: pulumi.Input<string>;
    /**
     * Enter your application's User Name
     */
    userName: pulumi.Input<string>;
    /**
     * Enter your application's User Secret
     */
    userSecret: pulumi.Input<string>;
}

export interface SourceCartConfigurationCredentialsSingleStoreAccessToken {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The name of Cart.com Online Store. All API URLs start with https://[mystorename.com]/api/v1/, where [mystorename.com] is the domain name of your store.
     */
    storeName: pulumi.Input<string>;
}

export interface SourceCartResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCartResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCartResourceAllocationJobSpecific>[]>;
}

export interface SourceCartResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCartResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCartResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCartResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCastorEdcConfiguration {
    /**
     * Visit `https://YOUR_REGION.castoredc.com/account/settings`
     */
    clientId: pulumi.Input<string>;
    /**
     * Visit `https://YOUR_REGION.castoredc.com/account/settings`
     */
    clientSecret: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * The url region given at time of registration. Default: "uk"; must be one of ["uk", "nl", "us"]
     */
    urlRegion?: pulumi.Input<string>;
}

export interface SourceCastorEdcResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCastorEdcResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCastorEdcResourceAllocationJobSpecific>[]>;
}

export interface SourceCastorEdcResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCastorEdcResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCastorEdcResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCastorEdcResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChameleonConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * End date for incremental sync
     */
    endDate?: pulumi.Input<string>;
    /**
     * Filter for using in the `segments_experiences` stream. Default: "tour"; must be one of ["tour", "survey", "launcher"]
     */
    filter?: pulumi.Input<string>;
    /**
     * Max records per page limit. Default: "50"
     */
    limit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceChameleonResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceChameleonResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceChameleonResourceAllocationJobSpecific>[]>;
}

export interface SourceChameleonResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChameleonResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceChameleonResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceChameleonResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChargebeeConfiguration {
    /**
     * The number of worker threads to use for the sync. The performance upper boundary is based on the limit of your Chargebee plan. More info about the rate limit plan tiers can be found on Chargebee's API <a href="https://support.chargebee.com/support/solutions/articles/243576-what-are-the-chargebee-api-limits-">docs</a>. Default: 3
     */
    numWorkers?: pulumi.Input<number>;
    /**
     * Product Catalog version of your Chargebee site. Instructions on how to find your version you may find <a href="https://apidocs.chargebee.com/docs/api?prod_cat_ver=2">here</a> under `API Version` section. If left blank, the product catalog version will be set to 2.0. Default: "2.0"; must be one of ["1.0", "2.0"]
     */
    productCatalog?: pulumi.Input<string>;
    /**
     * The site prefix for your Chargebee instance.
     */
    site: pulumi.Input<string>;
    /**
     * Chargebee API Key. See the <a href="https://docs.airbyte.com/integrations/sources/chargebee">docs</a> for more information on how to obtain this key.
     */
    siteApiKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceChargebeeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceChargebeeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceChargebeeResourceAllocationJobSpecific>[]>;
}

export interface SourceChargebeeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChargebeeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceChargebeeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceChargebeeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChargedeskConfiguration {
    password?: pulumi.Input<string>;
    /**
     * Date from when the sync should start in epoch Unix timestamp
     */
    startDate?: pulumi.Input<number>;
    username: pulumi.Input<string>;
}

export interface SourceChargedeskResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceChargedeskResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceChargedeskResourceAllocationJobSpecific>[]>;
}

export interface SourceChargedeskResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChargedeskResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceChargedeskResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceChargedeskResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChargifyConfiguration {
    /**
     * Maxio Advanced Billing/Chargify API Key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Chargify domain. Normally this domain follows the following format
     */
    domain: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceChargifyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceChargifyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceChargifyResourceAllocationJobSpecific>[]>;
}

export interface SourceChargifyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChargifyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceChargifyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceChargifyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChartmogulConfiguration {
    /**
     * Your Chartmogul API key. See <a href="https://help.chartmogul.com/hc/en-us/articles/4407796325906-Creating-and-Managing-API-keys#creating-an-api-key"> the docs </a> for info on how to obtain this.
     */
    apiKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. When feasible, any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceChartmogulResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceChartmogulResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceChartmogulResourceAllocationJobSpecific>[]>;
}

export interface SourceChartmogulResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceChartmogulResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceChartmogulResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceChartmogulResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCimisConfiguration {
    apiKey: pulumi.Input<string>;
    dailyDataItems?: pulumi.Input<pulumi.Input<string>[]>;
    endDate: pulumi.Input<string>;
    hourlyDataItems?: pulumi.Input<pulumi.Input<string>[]>;
    startDate: pulumi.Input<string>;
    targets: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * must be one of ["WSN station numbers", "California zip codes", "decimal-degree coordinates", "street addresses"]
     */
    targetsType: pulumi.Input<string>;
    /**
     * must be one of ["E", "M"]
     */
    unitOfMeasure?: pulumi.Input<string>;
}

export interface SourceCimisResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCimisResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCimisResourceAllocationJobSpecific>[]>;
}

export interface SourceCimisResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCimisResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCimisResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCimisResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCin7Configuration {
    /**
     * The ID associated with your account.
     */
    accountid: pulumi.Input<string>;
    /**
     * The API key associated with your account.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceCin7ResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCin7ResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCin7ResourceAllocationJobSpecific>[]>;
}

export interface SourceCin7ResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCin7ResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCin7ResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCin7ResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCircaConfiguration {
    /**
     * API key to use. Find it at https://app.circa.co/settings/integrations/api
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceCircaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCircaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCircaResourceAllocationJobSpecific>[]>;
}

export interface SourceCircaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCircaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCircaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCircaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCircleciConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Job Number of the workflow for `jobs` stream, Auto fetches from `workflow_jobs` stream, if not configured. Default: "2"
     */
    jobNumber?: pulumi.Input<string>;
    /**
     * The org ID found in `https://app.circleci.com/settings/organization/circleci/xxxxx/overview`
     */
    orgId: pulumi.Input<string>;
    /**
     * Project ID found in the project settings, Visit `https://app.circleci.com/settings/project/circleci/ORG_SLUG/YYYYY`
     */
    projectId: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * Workflow ID of a project pipeline, Could be seen in the URL of pipeline build, Example `https://app.circleci.com/pipelines/circleci/55555xxxxxx/7yyyyyyyyxxxxx/2/workflows/WORKFLOW_ID`
     */
    workflowIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceCircleciResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCircleciResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCircleciResourceAllocationJobSpecific>[]>;
}

export interface SourceCircleciResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCircleciResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCircleciResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCircleciResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCiscoMerakiConfiguration {
    /**
     * Your Meraki API key. Obtain it by logging into your Meraki Dashboard at https://dashboard.meraki.com/, navigating to 'My Profile' via the avatar icon in the top right corner, and generating the API key. Save this key securely as it represents your admin credentials.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceCiscoMerakiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCiscoMerakiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCiscoMerakiResourceAllocationJobSpecific>[]>;
}

export interface SourceCiscoMerakiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCiscoMerakiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCiscoMerakiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCiscoMerakiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClarifAiConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * User ID found in settings
     */
    userId: pulumi.Input<string>;
}

export interface SourceClarifAiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceClarifAiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceClarifAiResourceAllocationJobSpecific>[]>;
}

export interface SourceClarifAiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClarifAiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceClarifAiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceClarifAiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClazarConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
}

export interface SourceClazarResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceClazarResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceClazarResourceAllocationJobSpecific>[]>;
}

export interface SourceClazarResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClazarResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceClazarResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceClazarResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClickhouseConfiguration {
    /**
     * The name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * The host endpoint of the Clickhouse cluster.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The password associated with this username.
     */
    password?: pulumi.Input<string>;
    /**
     * The port of the database. Default: 8123
     */
    port?: pulumi.Input<number>;
    /**
     * Encrypt data using SSL. Default: true
     */
    ssl?: pulumi.Input<boolean>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.SourceClickhouseConfigurationTunnelMethod>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceClickhouseConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.SourceClickhouseConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.SourceClickhouseConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourceClickhouseConfigurationTunnelMethodNoTunnel {
}

export interface SourceClickhouseConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourceClickhouseConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourceClickhouseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceClickhouseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceClickhouseResourceAllocationJobSpecific>[]>;
}

export interface SourceClickhouseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClickhouseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceClickhouseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceClickhouseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClickupApiConfiguration {
    /**
     * Every ClickUp API call required authentication. This field is your personal API token. See <a href="https://clickup.com/api/developer-portal/authentication/#personal-token">here</a>.
     */
    apiToken: pulumi.Input<string>;
    /**
     * Include or exclude closed tasks. By default, they are excluded. See <a https://clickup.com/api/clickupreference/operation/GetTasks/#!in=query&path=include_closed&t=request">here</a>. Default: false
     */
    includeClosedTasks?: pulumi.Input<boolean>;
}

export interface SourceClickupApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceClickupApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceClickupApiResourceAllocationJobSpecific>[]>;
}

export interface SourceClickupApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClickupApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceClickupApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceClickupApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClockifyConfiguration {
    /**
     * You can get your api access_key <a href="https://app.clockify.me/user/settings">here</a> This API is Case Sensitive.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The URL for the Clockify API. This should only need to be modified if connecting to an enterprise version of Clockify. Default: "https://api.clockify.me"
     */
    apiUrl?: pulumi.Input<string>;
    /**
     * WorkSpace Id
     */
    workspaceId: pulumi.Input<string>;
}

export interface SourceClockifyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceClockifyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceClockifyResourceAllocationJobSpecific>[]>;
}

export interface SourceClockifyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClockifyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceClockifyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceClockifyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClockodoConfiguration {
    /**
     * API key to use. Find it in the 'Personal data' section of your Clockodo account.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Your Clockodo account email address. Find it in your Clockodo account settings.
     */
    emailAddress: pulumi.Input<string>;
    /**
     * Identification of the calling application, including the email address of a technical contact person. Format: [name of application or company];[email address]. Default: "Airbyte"
     */
    externalApplication?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * 2024, 2025
     */
    years: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceClockodoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceClockodoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceClockodoResourceAllocationJobSpecific>[]>;
}

export interface SourceClockodoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceClockodoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceClockodoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceClockodoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCloseComConfiguration {
    /**
     * Close.com API key (usually starts with 'api_'; find yours <a href="https://app.close.com/settings/api/">here</a>).
     */
    apiKey: pulumi.Input<string>;
    /**
     * The start date to sync data; all data after this date will be replicated. Leave blank to retrieve all the data available in the account. Format: YYYY-MM-DD. Default: "2021-01-01"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceCloseComResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCloseComResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCloseComResourceAllocationJobSpecific>[]>;
}

export interface SourceCloseComResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCloseComResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCloseComResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCloseComResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCloudbedsConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceCloudbedsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCloudbedsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCloudbedsResourceAllocationJobSpecific>[]>;
}

export interface SourceCloudbedsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCloudbedsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCloudbedsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCloudbedsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoassembleConfiguration {
    userId: pulumi.Input<string>;
    userToken: pulumi.Input<string>;
}

export interface SourceCoassembleResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCoassembleResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCoassembleResourceAllocationJobSpecific>[]>;
}

export interface SourceCoassembleResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoassembleResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCoassembleResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCoassembleResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCodaConfiguration {
    /**
     * Bearer token
     */
    authToken: pulumi.Input<string>;
}

export interface SourceCodaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCodaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCodaResourceAllocationJobSpecific>[]>;
}

export interface SourceCodaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCodaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCodaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCodaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCodefreshConfiguration {
    accountId: pulumi.Input<string>;
    apiKey: pulumi.Input<string>;
    reportDateRanges?: pulumi.Input<pulumi.Input<string>[]>;
    reportGranularity?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceCodefreshResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCodefreshResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCodefreshResourceAllocationJobSpecific>[]>;
}

export interface SourceCodefreshResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCodefreshResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCodefreshResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCodefreshResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoinApiConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * The end date in ISO 8601 format. If not supplied, data will be returned
     * from the start date to the current time, or when the count of result
     * elements reaches its limit.
     */
    endDate?: pulumi.Input<string>;
    /**
     * The environment to use. Either sandbox or production. Default: "sandbox"; must be one of ["sandbox", "production"]
     */
    environment?: pulumi.Input<string>;
    /**
     * The maximum number of elements to return. If not supplied, the default
     * is 100. For numbers larger than 100, each 100 items is counted as one
     * request for pricing purposes. Maximum value is 100000.
     * Default: 100
     */
    limit?: pulumi.Input<number>;
    /**
     * The period to use. See the documentation for a list. https://docs.coinapi.io/#list-all-periods-get
     */
    period: pulumi.Input<string>;
    /**
     * The start date in ISO 8601 format.
     */
    startDate: pulumi.Input<string>;
    /**
     * The symbol ID to use. See the documentation for a list.
     * https://docs.coinapi.io/#list-all-symbols-get
     */
    symbolId: pulumi.Input<string>;
}

export interface SourceCoinApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCoinApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCoinApiResourceAllocationJobSpecific>[]>;
}

export interface SourceCoinApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoinApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCoinApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCoinApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoingeckoCoinsConfiguration {
    /**
     * API Key (for pro users)
     */
    apiKey?: pulumi.Input<string>;
    /**
     * CoinGecko coin ID (e.g. bitcoin). Can be retrieved from the
     * `/coins/list` endpoint.
     */
    coinId: pulumi.Input<string>;
    /**
     * The number of days of data for market chart. Default: "30"; must be one of ["1", "7", "14", "30", "90", "180", "365", "max"]
     */
    days?: pulumi.Input<string>;
    /**
     * The end date for the historical data stream in dd-mm-yyyy format.
     */
    endDate?: pulumi.Input<string>;
    /**
     * The start date for the historical data stream in dd-mm-yyyy format.
     */
    startDate: pulumi.Input<string>;
    /**
     * The target currency of market data (e.g. usd, eur, jpy, etc.)
     */
    vsCurrency: pulumi.Input<string>;
}

export interface SourceCoingeckoCoinsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCoingeckoCoinsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCoingeckoCoinsResourceAllocationJobSpecific>[]>;
}

export interface SourceCoingeckoCoinsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoingeckoCoinsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCoingeckoCoinsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCoingeckoCoinsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoinmarketcapConfiguration {
    /**
     * Your API Key. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Authentication">here</a>. The token is case sensitive.
     */
    apiKey: pulumi.Input<string>;
    /**
     * /latest: Latest market ticker quotes and averages for cryptocurrencies and exchanges. /historical: Intervals of historic market data like OHLCV data or data for use in charting libraries. See <a href="https://coinmarketcap.com/api/documentation/v1/#section/Endpoint-Overview">here</a>. must be one of ["latest", "historical"]
     */
    dataType: pulumi.Input<string>;
    /**
     * Cryptocurrency symbols. (only used for quotes stream)
     */
    symbols?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceCoinmarketcapResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCoinmarketcapResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCoinmarketcapResourceAllocationJobSpecific>[]>;
}

export interface SourceCoinmarketcapResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCoinmarketcapResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCoinmarketcapResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCoinmarketcapResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConcordConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * The environment from where you want to access the API. must be one of ["uat", "api"]
     */
    env: pulumi.Input<string>;
}

export interface SourceConcordResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceConcordResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceConcordResourceAllocationJobSpecific>[]>;
}

export interface SourceConcordResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConcordResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceConcordResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceConcordResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConfigcatConfiguration {
    /**
     * Basic auth password. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
     */
    password: pulumi.Input<string>;
    /**
     * Basic auth user name. See <a href="https://api.configcat.com/docs/#section/Authentication">here</a>.
     */
    username: pulumi.Input<string>;
}

export interface SourceConfigcatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceConfigcatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceConfigcatResourceAllocationJobSpecific>[]>;
}

export interface SourceConfigcatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConfigcatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceConfigcatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceConfigcatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConfluenceConfiguration {
    /**
     * Please follow the Jira confluence for generating an API token: <a href="https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/">generating an API token</a>.
     */
    apiToken: pulumi.Input<string>;
    /**
     * Your Confluence domain name
     */
    domainName: pulumi.Input<string>;
    /**
     * Your Confluence login email
     */
    email: pulumi.Input<string>;
}

export interface SourceConfluenceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceConfluenceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceConfluenceResourceAllocationJobSpecific>[]>;
}

export interface SourceConfluenceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConfluenceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceConfluenceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceConfluenceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConvertkitConfiguration {
    credentials: pulumi.Input<inputs.SourceConvertkitConfigurationCredentials>;
    /**
     * Default: "2013-01-01T00:00:00Z"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceConvertkitConfigurationCredentials {
    apiKey?: pulumi.Input<inputs.SourceConvertkitConfigurationCredentialsApiKey>;
    oAuth20?: pulumi.Input<inputs.SourceConvertkitConfigurationCredentialsOAuth20>;
}

export interface SourceConvertkitConfigurationCredentialsApiKey {
    /**
     * Kit/ConvertKit API Key. Default: "{{ config.get('credentials',{}).get('api_key') or config.get('api_secret') }}"
     */
    apiKey?: pulumi.Input<string>;
}

export interface SourceConvertkitConfigurationCredentialsOAuth20 {
    /**
     * An access token generated using the provided client information and refresh token.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The client ID of your OAuth application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret of your OAuth application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The time at which the current access token is set to expire
     */
    expiresAt?: pulumi.Input<string>;
    /**
     * A current, non-expired refresh token genereted using the provided client ID and secret.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceConvertkitResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceConvertkitResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceConvertkitResourceAllocationJobSpecific>[]>;
}

export interface SourceConvertkitResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConvertkitResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceConvertkitResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceConvertkitResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConvexConfiguration {
    /**
     * API access key used to retrieve data from Convex.
     */
    accessKey: pulumi.Input<string>;
    deploymentUrl: pulumi.Input<string>;
}

export interface SourceConvexResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceConvexResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceConvexResourceAllocationJobSpecific>[]>;
}

export interface SourceConvexResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceConvexResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceConvexResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceConvexResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCopperConfiguration {
    /**
     * Copper API key
     */
    apiKey: pulumi.Input<string>;
    /**
     * user email used to login in to Copper
     */
    userEmail: pulumi.Input<string>;
}

export interface SourceCopperResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCopperResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCopperResourceAllocationJobSpecific>[]>;
}

export interface SourceCopperResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCopperResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCopperResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCopperResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCouchbaseConfiguration {
    /**
     * The name of the bucket to sync data from
     */
    bucket: pulumi.Input<string>;
    /**
     * The connection string for the Couchbase server (e.g., couchbase://localhost or couchbases://example.com)
     */
    connectionString: pulumi.Input<string>;
    /**
     * The password to use for authentication
     */
    password: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data for incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. If not set, all data will be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * The username to use for authentication
     */
    username: pulumi.Input<string>;
}

export interface SourceCouchbaseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCouchbaseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCouchbaseResourceAllocationJobSpecific>[]>;
}

export interface SourceCouchbaseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCouchbaseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCouchbaseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCouchbaseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCountercyclicalConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceCountercyclicalResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCountercyclicalResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCountercyclicalResourceAllocationJobSpecific>[]>;
}

export interface SourceCountercyclicalResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCountercyclicalResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCountercyclicalResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCountercyclicalResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCustomResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCustomResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCustomResourceAllocationJobSpecific>[]>;
}

export interface SourceCustomResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCustomResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCustomResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCustomResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCustomerIoConfiguration {
    appApiKey: pulumi.Input<string>;
}

export interface SourceCustomerIoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCustomerIoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCustomerIoResourceAllocationJobSpecific>[]>;
}

export interface SourceCustomerIoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCustomerIoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCustomerIoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCustomerIoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCustomerlyConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceCustomerlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceCustomerlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceCustomerlyResourceAllocationJobSpecific>[]>;
}

export interface SourceCustomerlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceCustomerlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceCustomerlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceCustomerlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDatadogConfiguration {
    /**
     * Datadog API key
     */
    apiKey: pulumi.Input<string>;
    /**
     * Datadog application key
     */
    applicationKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Data after this date will  not be replicated. An empty value will represent the current datetime for each  execution. This just applies to Incremental syncs.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Maximum number of records to collect per request. Default: 5000
     */
    maxRecordsPerRequest?: pulumi.Input<number>;
    /**
     * List of queries to be run and used as inputs.
     */
    queries?: pulumi.Input<pulumi.Input<inputs.SourceDatadogConfigurationQuery>[]>;
    /**
     * The search query. This just applies to Incremental syncs. If empty, it'll collect all logs.
     */
    query?: pulumi.Input<string>;
    /**
     * The site where Datadog data resides in. Default: "datadoghq.com"; must be one of ["datadoghq.com", "us3.datadoghq.com", "us5.datadoghq.com", "datadoghq.eu", "ddog-gov.com"]
     */
    site?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This just applies to Incremental syncs. Default: "2023-12-01T00:00:00Z"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceDatadogConfigurationQuery {
    /**
     * A data source that is powered by the platform. must be one of ["metrics", "cloud_cost", "logs", "rum"]
     */
    dataSource: pulumi.Input<string>;
    /**
     * The variable name for use in queries.
     */
    name: pulumi.Input<string>;
    /**
     * A classic query string.
     */
    query: pulumi.Input<string>;
}

export interface SourceDatadogResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDatadogResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDatadogResourceAllocationJobSpecific>[]>;
}

export interface SourceDatadogResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDatadogResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDatadogResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDatadogResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDatascopeConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * Start date for the data to be replicated
     */
    startDate: pulumi.Input<string>;
}

export interface SourceDatascopeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDatascopeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDatascopeResourceAllocationJobSpecific>[]>;
}

export interface SourceDatascopeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDatascopeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDatascopeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDatascopeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDbtConfiguration {
    accountId: pulumi.Input<string>;
    apiKey2: pulumi.Input<string>;
}

export interface SourceDbtResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDbtResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDbtResourceAllocationJobSpecific>[]>;
}

export interface SourceDbtResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDbtResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDbtResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDbtResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDelightedConfiguration {
    /**
     * A Delighted API key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate the data
     */
    since: pulumi.Input<string>;
}

export interface SourceDelightedResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDelightedResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDelightedResourceAllocationJobSpecific>[]>;
}

export interface SourceDelightedResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDelightedResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDelightedResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDelightedResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDeputyConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * The base url for your deputy account to make API requests
     */
    baseUrl: pulumi.Input<string>;
}

export interface SourceDeputyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDeputyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDeputyResourceAllocationJobSpecific>[]>;
}

export interface SourceDeputyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDeputyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDeputyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDeputyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDingConnectConfiguration {
    /**
     * Your API key for authenticating with the DingConnect API. You can generate this key by navigating to the Developer tab in the Account Settings section of your DingConnect account.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * Optional header to correlate HTTP requests between a client and server.
     */
    xCorrelationId?: pulumi.Input<string>;
}

export interface SourceDingConnectResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDingConnectResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDingConnectResourceAllocationJobSpecific>[]>;
}

export interface SourceDingConnectResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDingConnectResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDingConnectResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDingConnectResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDixaConfiguration {
    /**
     * Dixa API token
     */
    apiToken: pulumi.Input<string>;
    /**
     * Number of days to batch into one request. Max 31. Default: 31
     */
    batchSize?: pulumi.Input<number>;
    /**
     * The connector pulls records updated from this date onwards.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceDixaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDixaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDixaResourceAllocationJobSpecific>[]>;
}

export interface SourceDixaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDixaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDixaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDixaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDockerhubConfiguration {
    /**
     * Username of DockerHub person or organization (for https://hub.docker.com/v2/repositories/USERNAME/ API call)
     */
    dockerUsername: pulumi.Input<string>;
}

export interface SourceDockerhubResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDockerhubResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDockerhubResourceAllocationJobSpecific>[]>;
}

export interface SourceDockerhubResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDockerhubResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDockerhubResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDockerhubResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDocusealConfiguration {
    /**
     * Your API key for authenticating with the DocuSeal API. Obtain it from the DocuSeal API Console at https://console.docuseal.com/api.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The pagination limit. Default: "5"
     */
    limit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceDocusealResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDocusealResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDocusealResourceAllocationJobSpecific>[]>;
}

export interface SourceDocusealResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDocusealResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDocusealResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDocusealResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDremioConfiguration {
    /**
     * API Key that is generated when you authenticate to Dremio API
     */
    apiKey: pulumi.Input<string>;
    /**
     * URL of your Dremio instance. Default: "https://app.dremio.cloud"
     */
    baseUrl?: pulumi.Input<string>;
}

export interface SourceDremioResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDremioResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDremioResourceAllocationJobSpecific>[]>;
}

export interface SourceDremioResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDremioResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDremioResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDremioResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDriftConfiguration {
    credentials?: pulumi.Input<inputs.SourceDriftConfigurationCredentials>;
    /**
     * Email used as parameter for contacts stream. Default: "test@test.com"
     */
    email?: pulumi.Input<string>;
}

export interface SourceDriftConfigurationCredentials {
    accessToken?: pulumi.Input<inputs.SourceDriftConfigurationCredentialsAccessToken>;
    oAuth20?: pulumi.Input<inputs.SourceDriftConfigurationCredentialsOAuth20>;
}

export interface SourceDriftConfigurationCredentialsAccessToken {
    /**
     * Drift Access Token. See the <a href="https://docs.airbyte.com/integrations/sources/drift">docs</a> for more information on how to generate this key.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceDriftConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of your Drift developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Drift developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceDriftResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDriftResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDriftResourceAllocationJobSpecific>[]>;
}

export interface SourceDriftResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDriftResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDriftResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDriftResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDripConfiguration {
    /**
     * API key to use. Find it at https://www.getdrip.com/user/edit
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceDripResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDripResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDripResourceAllocationJobSpecific>[]>;
}

export interface SourceDripResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDripResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDripResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDripResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDropboxSignConfiguration {
    /**
     * API key to use. Find it at https://app.hellosign.com/home/myAccount#api
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceDropboxSignResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDropboxSignResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDropboxSignResourceAllocationJobSpecific>[]>;
}

export interface SourceDropboxSignResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDropboxSignResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDropboxSignResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDropboxSignResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDwollaConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The environment for the Dwolla API, either 'api-sandbox' or 'api'. Default: "api"; must be one of ["api", "api-sandbox"]
     */
    environment?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceDwollaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDwollaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDwollaResourceAllocationJobSpecific>[]>;
}

export interface SourceDwollaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDwollaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDwollaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDwollaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDynamodbConfiguration {
    /**
     * Credentials for the service
     */
    credentials?: pulumi.Input<inputs.SourceDynamodbConfigurationCredentials>;
    /**
     * the URL of the Dynamodb database. Default: ""
     */
    endpoint?: pulumi.Input<string>;
    /**
     * Ignore tables with missing scan/read permissions. Default: false
     */
    ignoreMissingReadPermissionsTables?: pulumi.Input<boolean>;
    /**
     * The region of the Dynamodb database. Default: ""; must be one of ["", "af-south-1", "ap-east-1", "ap-northeast-1", "ap-northeast-2", "ap-northeast-3", "ap-south-1", "ap-south-2", "ap-southeast-1", "ap-southeast-2", "ap-southeast-3", "ap-southeast-4", "ca-central-1", "ca-west-1", "cn-north-1", "cn-northwest-1", "eu-central-1", "eu-central-2", "eu-north-1", "eu-south-1", "eu-south-2", "eu-west-1", "eu-west-2", "eu-west-3", "il-central-1", "me-central-1", "me-south-1", "sa-east-1", "us-east-1", "us-east-2", "us-gov-east-1", "us-gov-west-1", "us-west-1", "us-west-2"]
     */
    region?: pulumi.Input<string>;
    /**
     * Comma separated reserved attribute names present in your tables
     */
    reservedAttributeNames?: pulumi.Input<string>;
}

export interface SourceDynamodbConfigurationCredentials {
    authenticateViaAccessKeys?: pulumi.Input<inputs.SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys>;
    roleBasedAuthentication?: pulumi.Input<inputs.SourceDynamodbConfigurationCredentialsRoleBasedAuthentication>;
}

export interface SourceDynamodbConfigurationCredentialsAuthenticateViaAccessKeys {
    /**
     * The access key id to access Dynamodb. Airbyte requires read permissions to the database
     */
    accessKeyId: pulumi.Input<string>;
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The corresponding secret to the access key id.
     */
    secretAccessKey: pulumi.Input<string>;
}

export interface SourceDynamodbConfigurationCredentialsRoleBasedAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
}

export interface SourceDynamodbResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceDynamodbResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceDynamodbResourceAllocationJobSpecific>[]>;
}

export interface SourceDynamodbResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceDynamodbResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceDynamodbResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceDynamodbResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEConomicConfiguration {
    /**
     * Token that identifies the grant issued by an agreement, allowing your app to access data. Obtain it from your e-conomic account settings.
     */
    agreementGrantToken: pulumi.Input<string>;
    /**
     * Your private token that identifies your app. Find it in your e-conomic account settings.
     */
    appSecretToken: pulumi.Input<string>;
}

export interface SourceEConomicResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEConomicResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEConomicResourceAllocationJobSpecific>[]>;
}

export interface SourceEConomicResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEConomicResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEConomicResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEConomicResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEasypostConfiguration {
    startDate: pulumi.Input<string>;
    /**
     * The API Key from your easypost settings
     */
    username: pulumi.Input<string>;
}

export interface SourceEasypostResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEasypostResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEasypostResourceAllocationJobSpecific>[]>;
}

export interface SourceEasypostResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEasypostResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEasypostResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEasypostResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEasypromosConfiguration {
    bearerToken: pulumi.Input<string>;
}

export interface SourceEasypromosResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEasypromosResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEasypromosResourceAllocationJobSpecific>[]>;
}

export interface SourceEasypromosResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEasypromosResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEasypromosResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEasypromosResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEbayFinanceConfiguration {
    /**
     * https://apiz.sandbox.ebay.com for sandbox & https://apiz.ebay.com for production. Default: "https://apiz.ebay.com"; must be one of ["https://apiz.sandbox.ebay.com", "https://apiz.ebay.com"]
     */
    apiHost?: pulumi.Input<string>;
    /**
     * Ebay Client Secret
     */
    password?: pulumi.Input<string>;
    redirectUri: pulumi.Input<string>;
    refreshToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * Default: "https://api.ebay.com/identity/v1/oauth2/token"; must be one of ["https://api.sandbox.ebay.com/identity/v1/oauth2/token", "https://api.ebay.com/identity/v1/oauth2/token"]
     */
    tokenRefreshEndpoint?: pulumi.Input<string>;
    /**
     * Ebay Developer Client ID
     */
    username: pulumi.Input<string>;
}

export interface SourceEbayFinanceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEbayFinanceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEbayFinanceResourceAllocationJobSpecific>[]>;
}

export interface SourceEbayFinanceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEbayFinanceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEbayFinanceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEbayFinanceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceElasticemailConfiguration {
    apiKey: pulumi.Input<string>;
    from?: pulumi.Input<string>;
    /**
     * must be one of ["Personal", "Global"]
     */
    scopeType?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceElasticemailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceElasticemailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceElasticemailResourceAllocationJobSpecific>[]>;
}

export interface SourceElasticemailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceElasticemailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceElasticemailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceElasticemailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEmailoctopusConfiguration {
    /**
     * EmailOctopus API Key. See the <a href="https://help.emailoctopus.com/article/165-how-to-create-and-delete-api-keys">docs</a> for information on how to generate this key.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceEmailoctopusResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEmailoctopusResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEmailoctopusResourceAllocationJobSpecific>[]>;
}

export interface SourceEmailoctopusResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEmailoctopusResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEmailoctopusResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEmailoctopusResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEmploymentHeroConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Employees IDs in the given organisation found in `employees` stream for passing to sub-streams
     */
    employeesConfigids?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Organization ID which could be found as result of `organizations` stream to be used in other substreams
     */
    organizationConfigids?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceEmploymentHeroResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEmploymentHeroResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEmploymentHeroResourceAllocationJobSpecific>[]>;
}

export interface SourceEmploymentHeroResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEmploymentHeroResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEmploymentHeroResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEmploymentHeroResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEnchargeConfiguration {
    /**
     * The API key to use for authentication
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceEnchargeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEnchargeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEnchargeResourceAllocationJobSpecific>[]>;
}

export interface SourceEnchargeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEnchargeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEnchargeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEnchargeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEventbriteConfiguration {
    /**
     * The private token to use for authenticating API requests.
     */
    privateToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceEventbriteResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEventbriteResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEventbriteResourceAllocationJobSpecific>[]>;
}

export interface SourceEventbriteResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEventbriteResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEventbriteResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEventbriteResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEventeeConfiguration {
    /**
     * API token to use. Generate it at https://admin.eventee.co/ in 'Settings > Features'.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceEventeeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEventeeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEventeeResourceAllocationJobSpecific>[]>;
}

export interface SourceEventeeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEventeeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEventeeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEventeeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEventzillaConfiguration {
    /**
     * API key to use. Generate it by creating a new application within your Eventzilla account settings under Settings > App Management.
     */
    xApiKey: pulumi.Input<string>;
}

export interface SourceEventzillaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEventzillaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEventzillaResourceAllocationJobSpecific>[]>;
}

export interface SourceEventzillaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEventzillaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEventzillaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEventzillaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEverhourConfiguration {
    /**
     * Everhour API Key. See the <a href="https://everhour.docs.apiary.io/#introduction/authentication">docs</a> for information on how to generate this key.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceEverhourResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEverhourResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEverhourResourceAllocationJobSpecific>[]>;
}

export interface SourceEverhourResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEverhourResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEverhourResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEverhourResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceExchangeRatesConfiguration {
    /**
     * Your API Key. See <a href="https://apilayer.com/marketplace/exchangerates_data-api">here</a>. The key is case sensitive.
     */
    accessKey: pulumi.Input<string>;
    /**
     * ISO reference currency. See <a href="https://www.ecb.europa.eu/stats/policy_and_exchange_rates/euro_reference_exchange_rates/html/index.en.html">here</a>. Free plan doesn't support Source Currency Switching, default base currency is EUR
     */
    base?: pulumi.Input<string>;
    /**
     * Ignore weekends? (Exchanges don't run on weekends). Default: true
     */
    ignoreWeekends?: pulumi.Input<boolean>;
    /**
     * Start getting data from that date.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceExchangeRatesResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceExchangeRatesResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceExchangeRatesResourceAllocationJobSpecific>[]>;
}

export interface SourceExchangeRatesResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceExchangeRatesResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceExchangeRatesResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceExchangeRatesResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEzofficeinventoryConfiguration {
    /**
     * Your EZOfficeInventory Access Token. API Access is disabled by default. Enable API Access in Settings > Integrations > API Integration and click on Update to generate a new access token
     */
    apiKey: pulumi.Input<string>;
    /**
     * Earliest date you want to sync historical streams (inventory_histories, asset_histories, asset_stock_histories) from
     */
    startDate: pulumi.Input<string>;
    /**
     * The company name used in signup, also visible in the URL when logged in.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceEzofficeinventoryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceEzofficeinventoryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceEzofficeinventoryResourceAllocationJobSpecific>[]>;
}

export interface SourceEzofficeinventoryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceEzofficeinventoryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceEzofficeinventoryResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceEzofficeinventoryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFacebookMarketingConfiguration {
    /**
     * The value of the generated access token. From your Appâ€™s Dashboard, click on "Marketing API" then "Tools". Select permissions <b>ads_management, ads_read, read_insights, business_management</b>. Then click on "Get token". See the <a href="https://docs.airbyte.com/integrations/sources/facebook-marketing">docs</a> for more information.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The Facebook Ad account ID(s) to pull data from. The Ad account ID number is in the account dropdown menu or in your browser's address bar of your <a href="https://adsmanager.facebook.com/adsmanager/">Meta Ads Manager</a>. See the <a href="https://www.facebook.com/business/help/1492627900875762">docs</a> for more information.
     */
    accountIds: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
     */
    adStatuses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
     */
    adsetStatuses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Select the statuses you want to be loaded in the stream. If no specific statuses are selected, the API's default behavior applies, and some statuses may be filtered out.
     */
    campaignStatuses?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Credentials for connecting to the Facebook Marketing API
     */
    credentials: pulumi.Input<inputs.SourceFacebookMarketingConfigurationCredentials>;
    /**
     * A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
     */
    customInsights?: pulumi.Input<pulumi.Input<inputs.SourceFacebookMarketingConfigurationCustomInsight>[]>;
    /**
     * The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Set to active if you want to fetch the thumbnail_url and store the result in thumbnail_data_url for each Ad Creative. Default: false
     */
    fetchThumbnailImages?: pulumi.Input<boolean>;
    /**
     * Insights Job Timeout establishes the maximum amount of time (in minutes) of waiting for the report job to complete. When timeout is reached the job is considered failed and we are trying to request smaller amount of data by breaking the job to few smaller ones. If you definitely know that 60 minutes is not enough for your report to be processed then you can decrease the timeout value, so we start breaking job to smaller parts faster. Default: 60
     */
    insightsJobTimeout?: pulumi.Input<number>;
    /**
     * The attribution window. Facebook freezes insight data 28 days after it was generated, which means that all data from the past 28 days may have changed since we last emitted it, so you can retrieve refreshed insights from the past by setting this parameter. If you set a custom lookback window value in Facebook account, please provide the same value here. Default: 28
     */
    insightsLookbackWindow?: pulumi.Input<number>;
    /**
     * Page size used when sending requests to Facebook API to specify number of records per page when response has pagination. Most users do not need to set this field unless they specifically need to tune the connector to address specific issues or use cases. Default: 100
     */
    pageSize?: pulumi.Input<number>;
    /**
     * The date from which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DDT00:00:00Z. If not set then all data will be replicated for usual streams and only last 2 years for insight streams.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceFacebookMarketingConfigurationCredentials {
    authenticateViaFacebookMarketingOauth?: pulumi.Input<inputs.SourceFacebookMarketingConfigurationCredentialsAuthenticateViaFacebookMarketingOauth>;
    serviceAccountKeyAuthentication?: pulumi.Input<inputs.SourceFacebookMarketingConfigurationCredentialsServiceAccountKeyAuthentication>;
}

export interface SourceFacebookMarketingConfigurationCredentialsAuthenticateViaFacebookMarketingOauth {
    /**
     * The value of the generated access token. From your Appâ€™s Dashboard, click on "Marketing API" then "Tools". Select permissions <b>ads_management, ads_read, read_insights, business_management</b>. Then click on "Get token". See the <a href="https://docs.airbyte.com/integrations/sources/facebook-marketing">docs</a> for more information.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * Client ID for the Facebook Marketing API
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret for the Facebook Marketing API
     */
    clientSecret: pulumi.Input<string>;
}

export interface SourceFacebookMarketingConfigurationCredentialsServiceAccountKeyAuthentication {
    /**
     * The value of the generated access token. From your Appâ€™s Dashboard, click on "Marketing API" then "Tools". Select permissions <b>ads_management, ads_read, read_insights, business_management</b>. Then click on "Get token". See the <a href="https://docs.airbyte.com/integrations/sources/facebook-marketing">docs</a> for more information.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceFacebookMarketingConfigurationCustomInsight {
    /**
     * A list of chosen action_breakdowns for action_breakdowns
     */
    actionBreakdowns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Determines the report time of action stats. For example, if a person saw the ad on Jan 1st but converted on Jan 2nd, when you query the API with action_report_time=impression, you see a conversion on Jan 1st. When you query the API with action_report_time=conversion, you see a conversion on Jan 2nd. Default: "mixed"; must be one of ["conversion", "impression", "mixed"]
     */
    actionReportTime?: pulumi.Input<string>;
    /**
     * A list of chosen breakdowns for breakdowns
     */
    breakdowns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The date until which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z. All data generated between the start date and this end date will be replicated. Not setting this option will result in always syncing the latest data.
     */
    endDate?: pulumi.Input<string>;
    /**
     * A list of chosen fields for fields parameter
     */
    fields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The insights job timeout. Default: 60
     */
    insightsJobTimeout?: pulumi.Input<number>;
    /**
     * The attribution window. Default: 28
     */
    insightsLookbackWindow?: pulumi.Input<number>;
    /**
     * Chosen level for API. Default: "ad"; must be one of ["ad", "adset", "campaign", "account"]
     */
    level?: pulumi.Input<string>;
    /**
     * The name value of insight
     */
    name: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data for this stream, in the format YYYY-MM-DDT00:00:00Z.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Time window in days by which to aggregate statistics. The sync will be chunked into N day intervals, where N is the number of days you specified. For example, if you set this value to 7, then all statistics will be reported as 7-day aggregates by starting from the start_date. If the start and end dates are October 1st and October 30th, then the connector will output 5 records: 01 - 06, 07 - 13, 14 - 20, 21 - 27, and 28 - 30 (3 days only). The minimum allowed value for this field is 1, and the maximum is 89. Default: 1
     */
    timeIncrement?: pulumi.Input<number>;
}

export interface SourceFacebookMarketingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFacebookMarketingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFacebookMarketingResourceAllocationJobSpecific>[]>;
}

export interface SourceFacebookMarketingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFacebookMarketingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFacebookMarketingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFacebookMarketingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFacebookPagesConfiguration {
    /**
     * Facebook Page Access Token
     */
    accessToken: pulumi.Input<string>;
    /**
     * Page ID
     */
    pageId: pulumi.Input<string>;
}

export interface SourceFacebookPagesResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFacebookPagesResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFacebookPagesResourceAllocationJobSpecific>[]>;
}

export interface SourceFacebookPagesResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFacebookPagesResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFacebookPagesResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFacebookPagesResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFactorialConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Max records per page limit. Default: "50"
     */
    limit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceFactorialResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFactorialResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFactorialResourceAllocationJobSpecific>[]>;
}

export interface SourceFactorialResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFactorialResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFactorialResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFactorialResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFakerConfiguration {
    /**
     * Should the updated_at values for every record be new each sync?  Setting this to false will case the source to stop emitting records after COUNT records have been emitted. Default: true
     */
    alwaysUpdated?: pulumi.Input<boolean>;
    /**
     * How many users should be generated in total. The purchases table will be scaled to match, with 10 purchases created per 10 users. This setting does not apply to the products stream. Default: 1000
     */
    count?: pulumi.Input<number>;
    /**
     * How many parallel workers should we use to generate fake data?  Choose a value equal to the number of CPUs you will allocate to this source. Default: 4
     */
    parallelism?: pulumi.Input<number>;
    /**
     * How many fake records will be in each page (stream slice), before a state message is emitted?. Default: 1000
     */
    recordsPerSlice?: pulumi.Input<number>;
    /**
     * Manually control the faker random seed to return the same values on subsequent runs (leave -1 for random). Default: -1
     */
    seed?: pulumi.Input<number>;
}

export interface SourceFakerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFakerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFakerResourceAllocationJobSpecific>[]>;
}

export interface SourceFakerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFakerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFakerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFakerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFastbillConfiguration {
    /**
     * Fastbill API key
     */
    apiKey: pulumi.Input<string>;
    /**
     * Username for Fastbill account
     */
    username: pulumi.Input<string>;
}

export interface SourceFastbillResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFastbillResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFastbillResourceAllocationJobSpecific>[]>;
}

export interface SourceFastbillResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFastbillResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFastbillResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFastbillResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFastlyConfiguration {
    /**
     * Your Fastly API token. You can generate this token in the Fastly web interface under Account Settings or via the Fastly API. Ensure the token has the appropriate scope for your use case.
     */
    fastlyApiToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceFastlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFastlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFastlyResourceAllocationJobSpecific>[]>;
}

export interface SourceFastlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFastlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFastlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFastlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFaunaConfiguration {
    /**
     * Settings for the Fauna Collection.
     */
    collection?: pulumi.Input<inputs.SourceFaunaConfigurationCollection>;
    /**
     * Domain of Fauna to query. Defaults db.fauna.com. See <a href=https://docs.fauna.com/fauna/current/learn/understanding/region_groups#how-to-use-region-groups>the docs</a>. Default: "db.fauna.com"
     */
    domain?: pulumi.Input<string>;
    /**
     * Endpoint port. Default: 443
     */
    port?: pulumi.Input<number>;
    /**
     * URL scheme. Default: "https"
     */
    scheme?: pulumi.Input<string>;
    /**
     * Fauna secret, used when authenticating with the database.
     */
    secret: pulumi.Input<string>;
}

export interface SourceFaunaConfigurationCollection {
    /**
     * <b>This only applies to incremental syncs.</b> <br>
     * Enabling deletion mode informs your destination of deleted documents.<br>
     * Disabled - Leave this feature disabled, and ignore deleted documents.<br>
     * Enabled - Enables this feature. When a document is deleted, the connector exports a record with a "deleted at" column containing the time that the document was deleted.
     */
    deletions: pulumi.Input<inputs.SourceFaunaConfigurationCollectionDeletions>;
    /**
     * The page size used when reading documents from the database. The larger the page size, the faster the connector processes documents. However, if a page is too large, the connector may fail. <br>
     * Choose your page size based on how large the documents are. <br>
     * See <a href="https://docs.fauna.com/fauna/current/learn/understanding/types#page">the docs</a>.
     * Default: 64
     */
    pageSize?: pulumi.Input<number>;
}

export interface SourceFaunaConfigurationCollectionDeletions {
    disabled?: pulumi.Input<inputs.SourceFaunaConfigurationCollectionDeletionsDisabled>;
    enabled?: pulumi.Input<inputs.SourceFaunaConfigurationCollectionDeletionsEnabled>;
}

export interface SourceFaunaConfigurationCollectionDeletionsDisabled {
}

export interface SourceFaunaConfigurationCollectionDeletionsEnabled {
    /**
     * Name of the "deleted at" column. Default: "deleted_at"
     */
    column?: pulumi.Input<string>;
}

export interface SourceFaunaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFaunaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFaunaResourceAllocationJobSpecific>[]>;
}

export interface SourceFaunaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFaunaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFaunaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFaunaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFileConfiguration {
    /**
     * The Name of the final table to replicate this file into (should include letters, numbers dash and underscores only).
     */
    datasetName: pulumi.Input<string>;
    /**
     * The Format of the file which should be replicated (Warning: some formats may be experimental, please refer to the docs). Default: "csv"; must be one of ["csv", "json", "jsonl", "excel", "excel_binary", "fwf", "feather", "parquet", "yaml"]
     */
    format?: pulumi.Input<string>;
    /**
     * The storage Provider or Location of the file(s) which should be replicated.
     */
    provider: pulumi.Input<inputs.SourceFileConfigurationProvider>;
    /**
     * This should be a string in JSON format. It depends on the chosen file format to provide additional options and tune its behavior.
     */
    readerOptions?: pulumi.Input<string>;
    /**
     * The URL path to access the file which should be replicated.
     */
    url: pulumi.Input<string>;
}

export interface SourceFileConfigurationProvider {
    azBlobAzureBlobStorage?: pulumi.Input<inputs.SourceFileConfigurationProviderAzBlobAzureBlobStorage>;
    gcsGoogleCloudStorage?: pulumi.Input<inputs.SourceFileConfigurationProviderGcsGoogleCloudStorage>;
    httpsPublicWeb?: pulumi.Input<inputs.SourceFileConfigurationProviderHttpsPublicWeb>;
    localFilesystemLimited?: pulumi.Input<inputs.SourceFileConfigurationProviderLocalFilesystemLimited>;
    s3AmazonWebServices?: pulumi.Input<inputs.SourceFileConfigurationProviderS3AmazonWebServices>;
    scpSecureCopyProtocol?: pulumi.Input<inputs.SourceFileConfigurationProviderScpSecureCopyProtocol>;
    sftpSecureFileTransferProtocol?: pulumi.Input<inputs.SourceFileConfigurationProviderSftpSecureFileTransferProtocol>;
    sshSecureShell?: pulumi.Input<inputs.SourceFileConfigurationProviderSshSecureShell>;
}

export interface SourceFileConfigurationProviderAzBlobAzureBlobStorage {
    /**
     * To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a SAS (Shared Access Signature) token. If accessing publicly available data, this field is not necessary.
     */
    sasToken?: pulumi.Input<string>;
    /**
     * To access Azure Blob Storage, this connector would need credentials with the proper permissions. One option is a storage account shared key (aka account key or access key). If accessing publicly available data, this field is not necessary.
     */
    sharedKey?: pulumi.Input<string>;
    /**
     * The globally unique name of the storage account that the desired blob sits within. See <a href="https://docs.microsoft.com/en-us/azure/storage/common/storage-account-overview" target="_blank">here</a> for more details.
     */
    storageAccount: pulumi.Input<string>;
}

export interface SourceFileConfigurationProviderGcsGoogleCloudStorage {
    /**
     * In order to access private Buckets stored on Google Cloud, this connector would need a service account json credentials with the proper permissions as described <a href="https://cloud.google.com/iam/docs/service-accounts" target="_blank">here</a>. Please generate the credentials.json file and copy/paste its content to this field (expecting JSON formats). If accessing publicly available data, this field is not necessary.
     */
    serviceAccountJson?: pulumi.Input<string>;
}

export interface SourceFileConfigurationProviderHttpsPublicWeb {
    /**
     * Add User-Agent to request. Default: false
     */
    userAgent?: pulumi.Input<boolean>;
}

export interface SourceFileConfigurationProviderLocalFilesystemLimited {
}

export interface SourceFileConfigurationProviderS3AmazonWebServices {
    /**
     * In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    awsAccessKeyId?: pulumi.Input<string>;
    /**
     * In order to access private Buckets stored on AWS S3, this connector would need credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    awsSecretAccessKey?: pulumi.Input<string>;
}

export interface SourceFileConfigurationProviderScpSecureCopyProtocol {
    host: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    /**
     * Default: "22"
     */
    port?: pulumi.Input<string>;
    user: pulumi.Input<string>;
}

export interface SourceFileConfigurationProviderSftpSecureFileTransferProtocol {
    host: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    /**
     * Default: "22"
     */
    port?: pulumi.Input<string>;
    user: pulumi.Input<string>;
}

export interface SourceFileConfigurationProviderSshSecureShell {
    host: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    /**
     * Default: "22"
     */
    port?: pulumi.Input<string>;
    user: pulumi.Input<string>;
}

export interface SourceFileResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFileResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFileResourceAllocationJobSpecific>[]>;
}

export interface SourceFileResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFileResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFileResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFileResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFilloutConfiguration {
    /**
     * API key to use. Find it in the Developer settings tab of your Fillout account.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceFilloutResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFilloutResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFilloutResourceAllocationJobSpecific>[]>;
}

export interface SourceFilloutResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFilloutResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFilloutResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFilloutResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinageConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Time period. Default is 10
     */
    period?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * List of symbols
     */
    symbols: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * One of DEMA, EMA, SMA, WMA, RSI, TEMA, Williams, ADX. Default: "SMA"; must be one of ["DEMA", "EMA", "SMA", "WMA", "RSI", "TEMA", "Williams", "ADX"]
     */
    techIndicatorType?: pulumi.Input<string>;
    /**
     * Default: "daily"; must be one of ["daily", "1min", "5min", "15min", "30min", "1hour", "4hour"]
     */
    time?: pulumi.Input<string>;
    /**
     * Size of the time. Default: "day"; must be one of ["minute", "hour", "day", "week", "month", "quarter", "year"]
     */
    timeAggregates?: pulumi.Input<string>;
    /**
     * Time Period for cash flow stmts. must be one of ["annual", "quarter"]
     */
    timePeriod?: pulumi.Input<string>;
}

export interface SourceFinageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFinageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFinageResourceAllocationJobSpecific>[]>;
}

export interface SourceFinageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFinageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFinageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinancialModellingConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * The stock exchange : AMEX, AMS, AQS, ASX, ATH, BER, BME, BRU, BSE, BUD, BUE, BVC, CAI, CBOE, CNQ, CPH, DFM, DOH, DUS, DXE, EGX, EURONEXT, HAM, HEL, HKSE, ICE, IOB, IST, JKT, JNB, JPX, KLS, KOE, KSC, KUW, LSE, MCX, MEX, MIL, MUN, NASDAQ, NEO, NSE, NYSE, NZE, OEM, OQX, OSL, OTC, PNK, PRA, RIS, SAO, SAU, SES, SET, SGO, SHH, SHZ, SIX, STO, STU, TAI, TLV, TSX, TSXV, TWO, VIE, VSE, WSE, XETRA. Default: "NASDAQ"
     */
    exchange?: pulumi.Input<string>;
    /**
     * Used in screener to filter out stocks with a market cap lower than the give marketcap
     */
    marketcaplowerthan?: pulumi.Input<string>;
    /**
     * Used in screener to filter out stocks with a market cap more than the give marketcap
     */
    marketcapmorethan?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * For example 1min, 5min, 15min, 30min, 1hour, 4hour. Default: "4hour"; must be one of ["1min", "5min", "15min", "30min", "1hour", "4hour"]
     */
    timeFrame?: pulumi.Input<string>;
}

export interface SourceFinancialModellingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFinancialModellingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFinancialModellingResourceAllocationJobSpecific>[]>;
}

export interface SourceFinancialModellingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinancialModellingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFinancialModellingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFinancialModellingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinnhubConfiguration {
    /**
     * The API key to use for authentication
     */
    apiKey: pulumi.Input<string>;
    /**
     * More info: https://finnhub.io/docs/api/stock-symbols. Default: "US"
     */
    exchange?: pulumi.Input<string>;
    /**
     * This parameter can be 1 of the following values general, forex, crypto, merger. Default: "general"; must be one of ["general", "forex", "crypto", "merger"]
     */
    marketNewsCategory?: pulumi.Input<string>;
    startDate2: pulumi.Input<string>;
    symbols: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceFinnhubResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFinnhubResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFinnhubResourceAllocationJobSpecific>[]>;
}

export interface SourceFinnhubResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinnhubResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFinnhubResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFinnhubResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinnworldsConfiguration {
    /**
     * For example 10y, 5y, 2y...
     */
    bondTypes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Options Available: beef, cheese, oil, ...
     */
    commodities?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * brazil, united states, italia, japan
     */
    countries?: pulumi.Input<pulumi.Input<string>[]>;
    key: pulumi.Input<string>;
    /**
     * Choose isin, ticker, reg_lei or cik. Default: "ticker"
     */
    list?: pulumi.Input<string>;
    /**
     * Default: "country"
     */
    listCountriesForBonds?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * AAPL, T, MU, GOOG
     */
    tickers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceFinnworldsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFinnworldsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFinnworldsResourceAllocationJobSpecific>[]>;
}

export interface SourceFinnworldsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFinnworldsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFinnworldsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFinnworldsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFireboltConfiguration {
    /**
     * Firebolt account to login.
     */
    account: pulumi.Input<string>;
    /**
     * Firebolt service account ID.
     */
    clientId: pulumi.Input<string>;
    /**
     * Firebolt secret, corresponding to the service account ID.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The database to connect to.
     */
    database: pulumi.Input<string>;
    /**
     * Engine name to connect to.
     */
    engine: pulumi.Input<string>;
    /**
     * The host name of your Firebolt database.
     */
    host?: pulumi.Input<string>;
}

export interface SourceFireboltResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFireboltResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFireboltResourceAllocationJobSpecific>[]>;
}

export interface SourceFireboltResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFireboltResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFireboltResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFireboltResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFirehydrantConfiguration {
    /**
     * Bot token to use for authenticating with the FireHydrant API. You can find or create a bot token by logging into your organization and visiting the Bot users page at https://app.firehydrant.io/organizations/bots.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceFirehydrantResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFirehydrantResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFirehydrantResourceAllocationJobSpecific>[]>;
}

export interface SourceFirehydrantResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFirehydrantResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFirehydrantResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFirehydrantResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFleetioConfiguration {
    accountToken: pulumi.Input<string>;
    apiKey: pulumi.Input<string>;
}

export interface SourceFleetioResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFleetioResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFleetioResourceAllocationJobSpecific>[]>;
}

export interface SourceFleetioResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFleetioResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFleetioResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFleetioResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFlexmailConfiguration {
    /**
     * Your Flexmail account ID. You can find it in your Flexmail account settings.
     */
    accountId: pulumi.Input<string>;
    /**
     * A personal access token for API authentication. Manage your tokens in Flexmail under Settings > API > Personal access tokens.
     */
    personalAccessToken: pulumi.Input<string>;
}

export interface SourceFlexmailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFlexmailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFlexmailResourceAllocationJobSpecific>[]>;
}

export interface SourceFlexmailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFlexmailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFlexmailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFlexmailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFlexportConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceFlexportResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFlexportResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFlexportResourceAllocationJobSpecific>[]>;
}

export interface SourceFlexportResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFlexportResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFlexportResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFlexportResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFloatConfiguration {
    /**
     * API token obtained from your Float Account Settings page
     */
    accessToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceFloatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFloatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFloatResourceAllocationJobSpecific>[]>;
}

export interface SourceFloatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFloatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFloatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFloatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFlowluConfiguration {
    /**
     * The API key to use for authentication
     */
    apiKey: pulumi.Input<string>;
    company: pulumi.Input<string>;
}

export interface SourceFlowluResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFlowluResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFlowluResourceAllocationJobSpecific>[]>;
}

export interface SourceFlowluResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFlowluResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFlowluResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFlowluResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFormbricksConfiguration {
    /**
     * API key to use. You can generate and find it in your Postman account settings.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceFormbricksResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFormbricksResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFormbricksResourceAllocationJobSpecific>[]>;
}

export interface SourceFormbricksResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFormbricksResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFormbricksResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFormbricksResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreeAgentConnectorConfiguration {
    clientId: pulumi.Input<string>;
    clientRefreshToken2: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    payrollYear?: pulumi.Input<number>;
    updatedSince?: pulumi.Input<string>;
}

export interface SourceFreeAgentConnectorResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreeAgentConnectorResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreeAgentConnectorResourceAllocationJobSpecific>[]>;
}

export interface SourceFreeAgentConnectorResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreeAgentConnectorResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreeAgentConnectorResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreeAgentConnectorResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreightviewConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
}

export interface SourceFreightviewResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreightviewResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreightviewResourceAllocationJobSpecific>[]>;
}

export interface SourceFreightviewResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreightviewResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreightviewResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreightviewResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshbooksConfiguration {
    accountId: pulumi.Input<string>;
    businessUuid: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The current access token. This field might be overridden by the connector based on the token refresh endpoint response.
     */
    oauthAccessToken?: pulumi.Input<string>;
    /**
     * The date the current access token expires in. This field might be overridden by the connector based on the token refresh endpoint response.
     */
    oauthTokenExpiryDate?: pulumi.Input<string>;
    redirectUri: pulumi.Input<string>;
}

export interface SourceFreshbooksResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreshbooksResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreshbooksResourceAllocationJobSpecific>[]>;
}

export interface SourceFreshbooksResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshbooksResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreshbooksResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreshbooksResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshcallerConfiguration {
    /**
     * Freshcaller API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshcaller">docs</a> for more information on how to obtain this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Used to construct Base URL for the Freshcaller APIs
     */
    domain: pulumi.Input<string>;
    /**
     * The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
     */
    requestsPerMinute?: pulumi.Input<number>;
    /**
     * UTC date and time. Any data created after this date will be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Lag in minutes for each sync, i.e., at time T, data for the time range [prev_sync_time, T-30] will be fetched
     */
    syncLagMinutes?: pulumi.Input<number>;
}

export interface SourceFreshcallerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreshcallerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreshcallerResourceAllocationJobSpecific>[]>;
}

export interface SourceFreshcallerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshcallerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreshcallerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreshcallerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshchatConfiguration {
    /**
     * The unique account name for your Freshchat instance
     */
    accountName: pulumi.Input<string>;
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceFreshchatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreshchatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreshchatResourceAllocationJobSpecific>[]>;
}

export interface SourceFreshchatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshchatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreshchatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreshchatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshdeskConfiguration {
    /**
     * Freshdesk API Key. See the <a href="https://docs.airbyte.com/integrations/sources/freshdesk">docs</a> for more information on how to obtain this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Freshdesk domain
     */
    domain: pulumi.Input<string>;
    /**
     * Number of days for lookback window for the stream Satisfaction Ratings. Default: 14
     */
    lookbackWindowInDays?: pulumi.Input<number>;
    /**
     * The number of requests per minute that this source allowed to use. There is a rate limit of 50 requests per minute per app per account.
     */
    requestsPerMinute?: pulumi.Input<number>;
    /**
     * UTC date and time. Any data created after this date will be replicated. If this parameter is not set, all data will be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceFreshdeskResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreshdeskResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreshdeskResourceAllocationJobSpecific>[]>;
}

export interface SourceFreshdeskResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshdeskResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreshdeskResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreshdeskResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshsalesConfiguration {
    /**
     * Freshsales API Key. See <a href="https://crmsupport.freshworks.com/support/solutions/articles/50000002503-how-to-find-my-api-key-">here</a>. The key is case sensitive.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The Name of your Freshsales domain
     */
    domainName: pulumi.Input<string>;
}

export interface SourceFreshsalesResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreshsalesResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreshsalesResourceAllocationJobSpecific>[]>;
}

export interface SourceFreshsalesResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshsalesResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreshsalesResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreshsalesResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshserviceConfiguration {
    /**
     * Freshservice API Key. See <a href="https://api.freshservice.com/#authentication">here</a>. The key is case sensitive.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The name of your Freshservice domain
     */
    domainName: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceFreshserviceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFreshserviceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFreshserviceResourceAllocationJobSpecific>[]>;
}

export interface SourceFreshserviceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFreshserviceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFreshserviceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFreshserviceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFrontConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Page limit for the responses. Default: "50"
     */
    pageLimit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceFrontResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFrontResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFrontResourceAllocationJobSpecific>[]>;
}

export interface SourceFrontResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFrontResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFrontResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFrontResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFulcrumConfiguration {
    /**
     * API key to use. Find it at https://web.fulcrumapp.com/settings/api
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceFulcrumResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFulcrumResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFulcrumResourceAllocationJobSpecific>[]>;
}

export interface SourceFulcrumResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFulcrumResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFulcrumResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFulcrumResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFullstoryConfiguration {
    /**
     * API Key for the fullstory.com API.
     */
    apiKey: pulumi.Input<string>;
    /**
     * User ID for the fullstory.com API.
     */
    uid: pulumi.Input<string>;
}

export interface SourceFullstoryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceFullstoryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceFullstoryResourceAllocationJobSpecific>[]>;
}

export interface SourceFullstoryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceFullstoryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceFullstoryResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceFullstoryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGainsightPxConfiguration {
    /**
     * The Aptrinsic API Key which is recieved from the dashboard settings (ref - https://app.aptrinsic.com/settings/api-keys)
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceGainsightPxResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGainsightPxResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGainsightPxResourceAllocationJobSpecific>[]>;
}

export interface SourceGainsightPxResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGainsightPxResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGainsightPxResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGainsightPxResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGcsConfiguration {
    /**
     * Name of the GCS bucket where the file(s) exist.
     */
    bucket: pulumi.Input<string>;
    /**
     * Credentials for connecting to the Google Cloud Storage API
     */
    credentials: pulumi.Input<inputs.SourceGcsConfigurationCredentials>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceGcsConfigurationStream>[]>;
}

export interface SourceGcsConfigurationCredentials {
    authenticateViaGoogleOAuth?: pulumi.Input<inputs.SourceGcsConfigurationCredentialsAuthenticateViaGoogleOAuth>;
    serviceAccountAuthentication?: pulumi.Input<inputs.SourceGcsConfigurationCredentialsServiceAccountAuthentication>;
}

export interface SourceGcsConfigurationCredentialsAuthenticateViaGoogleOAuth {
    /**
     * Access Token
     */
    accessToken: pulumi.Input<string>;
    /**
     * Client ID
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Access Token
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceGcsConfigurationCredentialsServiceAccountAuthentication {
    /**
     * Enter your Google Cloud <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">service account key</a> in JSON format
     */
    serviceAccount: pulumi.Input<string>;
}

export interface SourceGcsConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceGcsConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * The number of resent files which will be used to discover the schema for this stream.
     */
    recentNFilesToReadForSchemaDiscovery?: pulumi.Input<number>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceGcsConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatCsvFormat>;
    excelFormat?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatExcelFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceGcsConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceGcsConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceGcsConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGcsConfigurationStreamFormatExcelFormat {
}

export interface SourceGcsConfigurationStreamFormatJsonlFormat {
}

export interface SourceGcsConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceGcsConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
    /**
     * Process files via an API, using the `hi_res` mode. This option is useful for increased performance and accuracy, but requires an API key and a hosted instance of unstructured.
     */
    viaApi?: pulumi.Input<inputs.SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApi>;
}

export interface SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApi {
    /**
     * The API key to use matching the environment. Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The URL of the unstructured API to use. Default: "https://api.unstructured.io"
     */
    apiUrl?: pulumi.Input<string>;
    /**
     * List of parameters send to the API
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApiParameter>[]>;
}

export interface SourceGcsConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApiParameter {
    /**
     * The name of the unstructured API parameter to use
     */
    name: pulumi.Input<string>;
    /**
     * The value of the parameter
     */
    value: pulumi.Input<string>;
}

export interface SourceGcsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGcsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGcsResourceAllocationJobSpecific>[]>;
}

export interface SourceGcsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGcsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGcsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGcsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGetgistConfiguration {
    /**
     * API key to use. Find it in the Integration Settings on your Gist dashboard at https://app.getgist.com/projects/_/settings/api-key.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceGetgistResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGetgistResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGetgistResourceAllocationJobSpecific>[]>;
}

export interface SourceGetgistResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGetgistResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGetgistResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGetgistResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGetlagoConfiguration {
    /**
     * Your API Key. See <a href="https://doc.getlago.com/docs/api/intro">here</a>.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Your Lago API URL. Default: "https://api.getlago.com/api/v1"
     */
    apiUrl?: pulumi.Input<string>;
}

export interface SourceGetlagoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGetlagoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGetlagoResourceAllocationJobSpecific>[]>;
}

export interface SourceGetlagoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGetlagoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGetlagoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGetlagoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGiphyConfiguration {
    /**
     * Your GIPHY API Key. You can create and find your API key in the GIPHY Developer Dashboard at https://developers.giphy.com/dashboard/.
     */
    apiKey: pulumi.Input<string>;
    /**
     * A query for search endpoint. Default: "foo"
     */
    query?: pulumi.Input<string>;
    /**
     * Query for clips search endpoint. Default: "foo"
     */
    queryForClips?: pulumi.Input<string>;
    /**
     * Query for gif search endpoint. Default: "foo"
     */
    queryForGif?: pulumi.Input<string>;
    /**
     * Query for stickers search endpoint. Default: "foo"
     */
    queryForStickers?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceGiphyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGiphyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGiphyResourceAllocationJobSpecific>[]>;
}

export interface SourceGiphyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGiphyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGiphyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGiphyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGitbookConfiguration {
    /**
     * Personal access token for authenticating with the GitBook API. You can view and manage your access tokens in the Developer settings of your GitBook user account.
     */
    accessToken: pulumi.Input<string>;
    spaceId: pulumi.Input<string>;
}

export interface SourceGitbookResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGitbookResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGitbookResourceAllocationJobSpecific>[]>;
}

export interface SourceGitbookResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGitbookResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGitbookResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGitbookResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGithubConfiguration {
    /**
     * Please enter your basic URL from self-hosted GitHub instance or leave it empty to use GitHub. Default: "https://api.github.com/"
     */
    apiUrl?: pulumi.Input<string>;
    /**
     * List of GitHub repository branches to pull commits for, e.g. `airbytehq/airbyte/master`. If no branches are specified for a repository, the default branch will be pulled.
     */
    branches?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Choose how to authenticate to GitHub
     */
    credentials: pulumi.Input<inputs.SourceGithubConfigurationCredentials>;
    /**
     * Max Waiting Time for rate limit. Set higher value to wait till rate limits will be resetted to continue sync. Default: 10
     */
    maxWaitingTime?: pulumi.Input<number>;
    /**
     * List of GitHub organizations/repositories, e.g. `airbytehq/airbyte` for single repository, `airbytehq/*` for get all repositories from organization and `airbytehq/a* for matching multiple repositories by pattern.
     */
    repositories: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The date from which you'd like to replicate data from GitHub in the format YYYY-MM-DDT00:00:00Z. If the date is not set, all data will be replicated.  For the streams which support this configuration, only data generated on or after the start date will be replicated. This field doesn't apply to all streams, see the <a href="https://docs.airbyte.com/integrations/sources/github">docs</a> for more info
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceGithubConfigurationCredentials {
    oAuth?: pulumi.Input<inputs.SourceGithubConfigurationCredentialsOAuth>;
    personalAccessToken?: pulumi.Input<inputs.SourceGithubConfigurationCredentialsPersonalAccessToken>;
}

export interface SourceGithubConfigurationCredentialsOAuth {
    /**
     * OAuth access token
     */
    accessToken: pulumi.Input<string>;
    /**
     * OAuth Client Id
     */
    clientId?: pulumi.Input<string>;
    /**
     * OAuth Client secret
     */
    clientSecret?: pulumi.Input<string>;
}

export interface SourceGithubConfigurationCredentialsPersonalAccessToken {
    /**
     * Log into GitHub and then generate a <a href="https://github.com/settings/tokens">personal access token</a>. To load balance your API quota consumption across multiple API tokens, input multiple tokens separated with ","
     */
    personalAccessToken: pulumi.Input<string>;
}

export interface SourceGithubResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGithubResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGithubResourceAllocationJobSpecific>[]>;
}

export interface SourceGithubResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGithubResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGithubResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGithubResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGitlabConfiguration {
    /**
     * Please enter your basic URL from GitLab instance. Default: "gitlab.com"
     */
    apiUrl?: pulumi.Input<string>;
    credentials: pulumi.Input<inputs.SourceGitlabConfigurationCredentials>;
    /**
     * List of groups. e.g. airbyte.io.
     */
    groupsLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Space-delimited list of projects. e.g. airbyte.io/documentation meltano/tap-gitlab.
     */
    projectsLists?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The date from which you'd like to replicate data for GitLab API, in the format YYYY-MM-DDT00:00:00Z. Optional. If not set, all data will be replicated. All data generated after this date will be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceGitlabConfigurationCredentials {
    oAuth20?: pulumi.Input<inputs.SourceGitlabConfigurationCredentialsOAuth20>;
    privateToken?: pulumi.Input<inputs.SourceGitlabConfigurationCredentialsPrivateToken>;
}

export interface SourceGitlabConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The API ID of the Gitlab developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The API Secret the Gitlab developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The key to refresh the expired access_token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The date-time when the access token should be refreshed.
     */
    tokenExpiryDate: pulumi.Input<string>;
}

export interface SourceGitlabConfigurationCredentialsPrivateToken {
    /**
     * Log into your Gitlab account and then generate a personal Access Token.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceGitlabResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGitlabResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGitlabResourceAllocationJobSpecific>[]>;
}

export interface SourceGitlabResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGitlabResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGitlabResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGitlabResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGlassfrogConfiguration {
    /**
     * API key provided by Glassfrog
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceGlassfrogResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGlassfrogResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGlassfrogResourceAllocationJobSpecific>[]>;
}

export interface SourceGlassfrogResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGlassfrogResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGlassfrogResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGlassfrogResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGmailConfiguration {
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * Include drafts/messages from SPAM and TRASH in the results. Defaults to false. Default: false
     */
    includeSpamAndTrash?: pulumi.Input<boolean>;
}

export interface SourceGmailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGmailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGmailResourceAllocationJobSpecific>[]>;
}

export interface SourceGmailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGmailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGmailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGmailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGnewsConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * This parameter allows you to specify the country where the news articles returned by the API were published, the contents of the articles are not necessarily related to the specified country. You have to set as value the 2 letters code of the country you want to filter. must be one of ["au", "br", "ca", "cn", "eg", "fr", "de", "gr", "hk", "in", "ie", "il", "it", "jp", "nl", "no", "pk", "pe", "ph", "pt", "ro", "ru", "sg", "es", "se", "ch", "tw", "ua", "gb", "us"]
     */
    country?: pulumi.Input<string>;
    /**
     * This parameter allows you to filter the articles that have a publication date smaller than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
     */
    endDate?: pulumi.Input<string>;
    /**
     * This parameter allows you to choose in which attributes the keywords are searched. The attributes that can be set are title, description and content. It is possible to combine several attributes.
     */
    ins?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * must be one of ["ar", "zh", "nl", "en", "fr", "de", "el", "he", "hi", "it", "ja", "ml", "mr", "no", "pt", "ro", "ru", "es", "sv", "ta", "te", "uk"]
     */
    language?: pulumi.Input<string>;
    /**
     * This parameter allows you to specify the attributes that you allow to return null values. The attributes that  can be set are title, description and content. It is possible to combine several attributes
     */
    nullables?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
     *   quotation marks are used to search for articles with the exact same keyword
     * sequence. 
     *   For example the query: "Apple iPhone" will return articles matching at
     * least once this sequence of keywords. - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
     *   search. By default the space character acts as an AND operator, it is
     * possible to replace the space character 
     *   by AND to obtain the same result. For example the query: Apple Microsoft
     * is equivalent to Apple AND Microsoft - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
     *   It is important to note that this operator has a higher precedence than
     * the AND operator. For example the 
     *   query: Apple OR Microsoft will return all articles matching the keyword
     * Apple as well as all articles matching 
     *   the keyword Microsoft
     * - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
     *   specified keywords. To use it, you need to add NOT in front of each word
     * or phrase surrounded by quotes.
     *   For example the query: Apple NOT iPhone will return all articles matching
     * the keyword Apple but not the keyword
     *   iPhone
     */
    query: pulumi.Input<string>;
    /**
     * This parameter allows you to choose with which type of sorting the articles should be returned. Two values  are possible:
     *   - publishedAt = sort by publication date, the articles with the most recent
     * publication date are returned first
     *   - relevance = sort by best match to keywords, the articles with the best
     * match are returned first
     * must be one of ["publishedAt", "relevance"]
     */
    sortby?: pulumi.Input<string>;
    /**
     * This parameter allows you to filter the articles that have a publication date greater than or equal to the  specified value. The date must respect the following format: YYYY-MM-DD hh:mm:ss (in UTC)
     */
    startDate?: pulumi.Input<string>;
    /**
     * This parameter allows you to specify your search keywords to find the news articles you are looking for. The keywords will be used to return the most relevant articles. It is possible to use logical operators  with keywords. - Phrase Search Operator: This operator allows you to make an exact search. Keywords surrounded by 
     *   quotation marks are used to search for articles with the exact same keyword
     * sequence. 
     *   For example the query: "Apple iPhone" will return articles matching at
     * least once this sequence of keywords. - Logical AND Operator: This operator allows you to make sure that several keywords are all used in the article
     *   search. By default the space character acts as an AND operator, it is
     * possible to replace the space character 
     *   by AND to obtain the same result. For example the query: Apple Microsoft
     * is equivalent to Apple AND Microsoft - Logical OR Operator: This operator allows you to retrieve articles matching the keyword a or the keyword b.
     *   It is important to note that this operator has a higher precedence than
     * the AND operator. For example the 
     *   query: Apple OR Microsoft will return all articles matching the keyword
     * Apple as well as all articles matching 
     *   the keyword Microsoft
     * - Logical NOT Operator: This operator allows you to remove from the results the articles corresponding to the
     *   specified keywords. To use it, you need to add NOT in front of each word
     * or phrase surrounded by quotes.
     *   For example the query: Apple NOT iPhone will return all articles matching
     * the keyword Apple but not the keyword
     *   iPhone
     */
    topHeadlinesQuery?: pulumi.Input<string>;
    /**
     * This parameter allows you to change the category for the request. must be one of ["breaking-news", "world", "nation", "business", "technology", "entertainment", "sports", "science", "health"]
     */
    topHeadlinesTopic?: pulumi.Input<string>;
}

export interface SourceGnewsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGnewsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGnewsResourceAllocationJobSpecific>[]>;
}

export interface SourceGnewsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGnewsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGnewsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGnewsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGocardlessConfiguration {
    /**
     * Gocardless API TOKEN
     */
    accessToken: pulumi.Input<string>;
    /**
     * Environment you are trying to connect to. Default: "sandbox"; must be one of ["sandbox", "live"]
     */
    gocardlessEnvironment?: pulumi.Input<string>;
    /**
     * GoCardless version. This is a date. You can find the latest here: 
     * https://developer.gocardless.com/api-reference/#api-usage-making-requests
     */
    gocardlessVersion: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data
     * before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceGocardlessResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGocardlessResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGocardlessResourceAllocationJobSpecific>[]>;
}

export interface SourceGocardlessResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGocardlessResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGocardlessResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGocardlessResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoldcastConfiguration {
    /**
     * Your API Access Key. See <a href="https://help.goldcast.io/hc/en-us/articles/22931655725723-How-To-Create-an-API-Token-in-Goldcast">here</a>. The key is case sensitive.
     */
    accessKey: pulumi.Input<string>;
}

export interface SourceGoldcastResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoldcastResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoldcastResourceAllocationJobSpecific>[]>;
}

export interface SourceGoldcastResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoldcastResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoldcastResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoldcastResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGologinConfiguration {
    /**
     * API Key found at `https://app.gologin.com/personalArea/TokenApi`
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceGologinResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGologinResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGologinResourceAllocationJobSpecific>[]>;
}

export interface SourceGologinResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGologinResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGologinResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGologinResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGongConfiguration {
    /**
     * Gong Access Key
     */
    accessKey: pulumi.Input<string>;
    /**
     * Gong Access Key Secret
     */
    accessKeySecret: pulumi.Input<string>;
    /**
     * The date from which to list calls, in the ISO-8601 format; if not specified, the calls start with the earliest recorded call. For web-conference calls recorded by Gong, the date denotes its scheduled time, otherwise, it denotes its actual start time.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceGongResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGongResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGongResourceAllocationJobSpecific>[]>;
}

export interface SourceGongResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGongResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGongResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGongResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleAdsConfiguration {
    /**
     * A conversion window is the number of days after an ad interaction (such as an ad click or video view) during which a conversion, such as a purchase, is recorded in Google Ads. For more information, see <a href="https://support.google.com/google-ads/answer/3123169?hl=en">Google's documentation</a>. Default: 14
     */
    conversionWindowDays?: pulumi.Input<number>;
    credentials: pulumi.Input<inputs.SourceGoogleAdsConfigurationCredentials>;
    customQueriesArrays?: pulumi.Input<pulumi.Input<inputs.SourceGoogleAdsConfigurationCustomQueriesArray>[]>;
    /**
     * Comma-separated list of (client) customer IDs. Each customer ID must be specified as a 10-digit number without dashes. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
     */
    customerId?: pulumi.Input<string>;
    /**
     * A list of customer statuses to filter on. For detailed info about what each status mean refer to Google Ads <a href="https://developers.google.com/google-ads/api/reference/rpc/v15/CustomerStatusEnum.CustomerStatus">documentation</a>.
     */
    customerStatusFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * UTC date in the format YYYY-MM-DD. Any data after this date will not be replicated. (Default value of today is used if not set)
     */
    endDate?: pulumi.Input<string>;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. (Default value of two years ago is used if not set)
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceGoogleAdsConfigurationCredentials {
    /**
     * The Access Token for making authenticated requests. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The Client ID of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Google Ads developer application. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The Developer Token granted by Google to use their APIs. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
     */
    developerToken: pulumi.Input<string>;
    /**
     * The token used to obtain a new Access Token. For detailed instructions on finding this value, refer to our <a href="https://docs.airbyte.com/integrations/sources/google-ads#setup-guide">documentation</a>.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceGoogleAdsConfigurationCustomQueriesArray {
    /**
     * A custom defined GAQL query for building the report. Avoid including the segments.date field; wherever possible, Airbyte will automatically include it for incremental syncs. For more information, refer to <a href="https://developers.google.com/google-ads/api/fields/v11/overview_query_builder">Google's documentation</a>.
     */
    query: pulumi.Input<string>;
    /**
     * The table name in your destination database for the chosen query.
     */
    tableName: pulumi.Input<string>;
}

export interface SourceGoogleAdsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleAdsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleAdsResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleAdsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleAdsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleAdsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleAdsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfiguration {
    /**
     * Enables conversion of `conversions:*` event metrics from integers to floats. This is beneficial for preventing data rounding when the API returns float values for any `conversions:*` fields. Default: false
     */
    convertConversionsEvent?: pulumi.Input<boolean>;
    /**
     * Credentials for the service
     */
    credentials?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCredentials>;
    /**
     * You can add your Custom Analytics report by creating one.
     */
    customReportsArrays?: pulumi.Input<pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray>[]>;
    /**
     * The end date from which to replicate report data in the format YYYY-MM-DD. Data generated after this date will not be included in the report. Not applied to custom Cohort reports. When no date is provided or the date is in the future, the date from today is used.
     */
    dateRangesEndDate?: pulumi.Input<string>;
    /**
     * The start date from which to replicate report data in the format YYYY-MM-DD. Data generated before this date will not be included in the report. Not applied to custom Cohort reports.
     */
    dateRangesStartDate?: pulumi.Input<string>;
    /**
     * If false, each row with all metrics equal to 0 will not be returned. If true, these rows will be returned if they are not separately removed by a filter. More information is available in <a href="https://developers.google.com/analytics/devguides/reporting/data/v1/rest/v1beta/properties/runReport#request-body">the documentation</a>. Default: false
     */
    keepEmptyRows?: pulumi.Input<boolean>;
    /**
     * Since attribution changes after the event date, and Google Analytics has a data processing latency, we should specify how many days in the past we should refresh the data in every run. So if you set it at 5 days, in every sync it will fetch the last bookmark date minus 5 days. Default: 2
     */
    lookbackWindow?: pulumi.Input<number>;
    /**
     * A list of your Property IDs. The Property ID is a unique number assigned to each property in Google Analytics, found in your GA4 property URL. This ID allows the connector to track the specific events associated with your property. Refer to the <a href='https://developers.google.com/analytics/devguides/reporting/data/v1/property-id#what_is_my_property_id'>Google Analytics documentation</a> to locate your property ID.
     */
    propertyIds: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The interval in days for each data request made to the Google Analytics API. A larger value speeds up data sync, but increases the chance of data sampling, which may result in inaccuracies. We recommend a value of 1 to minimize sampling, unless speed is an absolute priority over accuracy. Acceptable values range from 1 to 364. Does not apply to custom Cohort reports. More information is available in <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api">the documentation</a>. Default: 1
     */
    windowInDays?: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentials {
    authenticateViaGoogleOauth?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth>;
    serviceAccountKeyAuthentication?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentialsAuthenticateViaGoogleOauth {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The Client ID of your Google Analytics developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Google Analytics developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The token for obtaining a new access token.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCredentialsServiceAccountKeyAuthentication {
    /**
     * The JSON key linked to the service account used for authorization. For steps on obtaining this key, refer to <a href="https://docs.airbyte.com/integrations/sources/google-analytics-data-api/#setup-guide">the setup guide</a>.
     */
    credentialsJson: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArray {
    /**
     * Cohort reports creates a time series of user retention for the cohort.
     */
    cohortSpec?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpec>;
    /**
     * Dimensions filter
     */
    dimensionFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter>;
    /**
     * A list of dimensions.
     */
    dimensions: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Metrics filter
     */
    metricFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter>;
    /**
     * A list of metrics.
     */
    metrics: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the custom report, this name would be used as stream name.
     */
    name: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpec {
    disabled?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabled>;
    enabled?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecDisabled {
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabled {
    /**
     * Optional settings for a cohort report.
     */
    cohortReportSettings?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettings>;
    cohorts?: pulumi.Input<pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort>[]>;
    cohortsRange?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohort {
    dateRange: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange>;
    /**
     * Dimension used by the cohort. Required and only supports `firstSessionDate`. must be "firstSessionDate"
     */
    dimension: pulumi.Input<string>;
    /**
     * Assigns a name to this cohort. If not set, cohorts are named by their zero based index cohort_0, cohort_1, etc.
     */
    name?: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortDateRange {
    endDate: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortReportSettings {
    /**
     * If true, accumulates the result from first touch day to the end day
     */
    accumulate?: pulumi.Input<boolean>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayCohortSpecEnabledCohortsRange {
    /**
     * Specifies the end date of the extended reporting date range for a cohort report.
     */
    endOffset: pulumi.Input<number>;
    /**
     * The granularity used to interpret the startOffset and endOffset for the extended reporting date range for a cohort report. must be one of ["GRANULARITY_UNSPECIFIED", "DAILY", "WEEKLY", "MONTHLY"]
     */
    granularity: pulumi.Input<string>;
    /**
     * Specifies the start date of the extended reporting date range for a cohort report.
     */
    startOffset?: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilter {
    /**
     * The FilterExpressions in andGroup have an AND relationship.
     */
    andGroup?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroup>;
    /**
     * A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all dimensions.
     */
    filter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter>;
    /**
     * The FilterExpression is NOT of notExpression.
     */
    notExpression?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpression>;
    /**
     * The FilterExpressions in orGroup have an OR relationship.
     */
    orGroup?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroup>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroup {
    expressions: pulumi.Input<pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpression {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterAndGroupExpressionFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilter {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterFilterFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpression {
    expression?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpression {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterNotExpressionExpressionFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroup {
    expressions: pulumi.Input<pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpression {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayDimensionFilterOrGroupExpressionFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilter {
    /**
     * The FilterExpressions in andGroup have an AND relationship.
     */
    andGroup?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroup>;
    /**
     * A primitive filter. In the same FilterExpression, all of the filter's field names need to be either all metrics.
     */
    filter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter>;
    /**
     * The FilterExpression is NOT of notExpression.
     */
    notExpression?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpression>;
    /**
     * The FilterExpressions in orGroup have an OR relationship.
     */
    orGroup?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroup>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroup {
    expressions: pulumi.Input<pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpression {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterAndGroupExpressionFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilter {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterFilterFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpression {
    expression?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpression {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterNotExpressionExpressionFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroup {
    expressions: pulumi.Input<pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpression {
    fieldName: pulumi.Input<string>;
    filter: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilter {
    betweenFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter>;
    inListFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter>;
    numericFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilter>;
    stringFilter?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilter {
    fromValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue>;
    toValue: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterFromValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterBetweenFilterToValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterInListFilter {
    caseSensitive?: pulumi.Input<boolean>;
    values: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilter {
    operations: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValue {
    doubleValue?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValue>;
    int64Value?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64Value>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueDoubleValue {
    value: pulumi.Input<number>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterNumericFilterValueInt64Value {
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiConfigurationCustomReportsArrayMetricFilterOrGroupExpressionFilterStringFilter {
    caseSensitive?: pulumi.Input<boolean>;
    matchTypes?: pulumi.Input<pulumi.Input<string>[]>;
    value: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleAnalyticsDataApiResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleAnalyticsDataApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleAnalyticsDataApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleAnalyticsDataApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleAnalyticsDataApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleCalendarConfiguration {
    calendarid: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    clientRefreshToken2: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
}

export interface SourceGoogleCalendarResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleCalendarResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleCalendarResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleCalendarResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleCalendarResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleCalendarResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleCalendarResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleClassroomConfiguration {
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
}

export interface SourceGoogleClassroomResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleClassroomResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleClassroomResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleClassroomResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleClassroomResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleClassroomResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleClassroomResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleDirectoryConfiguration {
    /**
     * Google APIs use the OAuth 2.0 protocol for authentication and authorization. The Source supports <a href="https://developers.google.com/identity/protocols/oauth2#webserver" target="_blank">Web server application</a> and <a href="https://developers.google.com/identity/protocols/oauth2#serviceaccount" target="_blank">Service accounts</a> scenarios.
     */
    credentials?: pulumi.Input<inputs.SourceGoogleDirectoryConfigurationCredentials>;
}

export interface SourceGoogleDirectoryConfigurationCredentials {
    /**
     * For these scenario user should obtain service account's credentials from the Google API Console and provide delegated email.
     */
    serviceAccountKey?: pulumi.Input<inputs.SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey>;
    /**
     * For these scenario user only needs to give permission to read Google Directory data.
     */
    signInViaGoogleOAuth?: pulumi.Input<inputs.SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth>;
}

export interface SourceGoogleDirectoryConfigurationCredentialsServiceAccountKey {
    /**
     * The contents of the JSON service account key. See the <a href="https://developers.google.com/admin-sdk/directory/v1/guides/delegation">docs</a> for more information on how to generate this key.
     */
    credentialsJson: pulumi.Input<string>;
    /**
     * The email of the user, which has permissions to access the Google Workspace Admin APIs.
     */
    email: pulumi.Input<string>;
}

export interface SourceGoogleDirectoryConfigurationCredentialsSignInViaGoogleOAuth {
    /**
     * The Client ID of the developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of the developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The Token for obtaining a new access token.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceGoogleDirectoryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleDirectoryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleDirectoryResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleDirectoryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleDirectoryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleDirectoryResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleDirectoryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleDriveConfiguration {
    /**
     * Credentials for connecting to the Google Drive API
     */
    credentials: pulumi.Input<inputs.SourceGoogleDriveConfigurationCredentials>;
    deliveryMethod?: pulumi.Input<inputs.SourceGoogleDriveConfigurationDeliveryMethod>;
    /**
     * URL for the folder you want to sync. Using individual streams and glob patterns, it's possible to only sync a subset of all files located in the folder.
     */
    folderUrl: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceGoogleDriveConfigurationStream>[]>;
}

export interface SourceGoogleDriveConfigurationCredentials {
    authenticateViaGoogleOAuth?: pulumi.Input<inputs.SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth>;
    serviceAccountKeyAuthentication?: pulumi.Input<inputs.SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication>;
}

export interface SourceGoogleDriveConfigurationCredentialsAuthenticateViaGoogleOAuth {
    /**
     * Client ID for the Google Drive API
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret for the Google Drive API
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token for the Google Drive API
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceGoogleDriveConfigurationCredentialsServiceAccountKeyAuthentication {
    /**
     * The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
     */
    serviceAccountInfo: pulumi.Input<string>;
}

export interface SourceGoogleDriveConfigurationDeliveryMethod {
    /**
     * Copy raw files without parsing their contents. Bits are copied into the destination exactly as they appeared in the source. Recommended for use with unstructured text data, non-text and compressed files.
     */
    copyRawFiles?: pulumi.Input<inputs.SourceGoogleDriveConfigurationDeliveryMethodCopyRawFiles>;
    /**
     * Sends one identity stream and one for more permissions (ACL) streams to the destination. This data can be used in downstream systems to recreate permission restrictions mirroring the original source.
     */
    replicatePermissionsAcl?: pulumi.Input<inputs.SourceGoogleDriveConfigurationDeliveryMethodReplicatePermissionsAcl>;
    /**
     * Recommended - Extract and load structured records into your destination of choice. This is the classic method of moving data in Airbyte. It allows for blocking and hashing individual fields or files from a structured schema. Data can be flattened, typed and deduped depending on the destination.
     */
    replicateRecords?: pulumi.Input<inputs.SourceGoogleDriveConfigurationDeliveryMethodReplicateRecords>;
}

export interface SourceGoogleDriveConfigurationDeliveryMethodCopyRawFiles {
    /**
     * If enabled, sends subdirectory folder structure along with source file names to the destination. Otherwise, files will be synced by their names only. This option is ignored when file-based replication is not enabled. Default: true
     */
    preserveDirectoryStructure?: pulumi.Input<boolean>;
}

export interface SourceGoogleDriveConfigurationDeliveryMethodReplicatePermissionsAcl {
    /**
     * The Google domain of the identities.
     */
    domain?: pulumi.Input<string>;
    /**
     * This data can be used in downstream systems to recreate permission restrictions mirroring the original source. Default: true
     */
    includeIdentitiesStream?: pulumi.Input<boolean>;
}

export interface SourceGoogleDriveConfigurationDeliveryMethodReplicateRecords {
}

export interface SourceGoogleDriveConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * The number of resent files which will be used to discover the schema for this stream.
     */
    recentNFilesToReadForSchemaDiscovery?: pulumi.Input<number>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceGoogleDriveConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatCsvFormat>;
    excelFormat?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatExcelFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceGoogleDriveConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceGoogleDriveConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceGoogleDriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleDriveConfigurationStreamFormatExcelFormat {
}

export interface SourceGoogleDriveConfigurationStreamFormatJsonlFormat {
}

export interface SourceGoogleDriveConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceGoogleDriveConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceGoogleDriveConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceGoogleDriveConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
}

export interface SourceGoogleDriveConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceGoogleDriveResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleDriveResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleDriveResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleDriveResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleDriveResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleDriveResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleDriveResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleFormsConfiguration {
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    formIds: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGoogleFormsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleFormsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleFormsResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleFormsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleFormsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleFormsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleFormsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGooglePagespeedInsightsConfiguration {
    /**
     * Google PageSpeed API Key. See <a href="https://developers.google.com/speed/docs/insights/v5/get-started#APIKey">here</a>. The key is optional - however the API is heavily rate limited when using without API Key. Creating and using the API key therefore is recommended. The key is case sensitive.
     */
    apiKey?: pulumi.Input<string>;
    /**
     * Defines which Lighthouse category to run. One or many of: "accessibility", "best-practices", "performance", "pwa", "seo".
     */
    categories: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The analyses strategy to use. Either "desktop" or "mobile".
     */
    strategies: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The URLs to retrieve pagespeed information from. The connector will attempt to sync PageSpeed reports for all the defined URLs. Format: https://(www.)url.domain
     */
    urls: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceGooglePagespeedInsightsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGooglePagespeedInsightsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGooglePagespeedInsightsResourceAllocationJobSpecific>[]>;
}

export interface SourceGooglePagespeedInsightsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGooglePagespeedInsightsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGooglePagespeedInsightsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGooglePagespeedInsightsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleSearchConsoleConfiguration {
    authorization: pulumi.Input<inputs.SourceGoogleSearchConsoleConfigurationAuthorization>;
    /**
     * You can add your Custom Analytics report by creating one.
     */
    customReportsArrays?: pulumi.Input<pulumi.Input<inputs.SourceGoogleSearchConsoleConfigurationCustomReportsArray>[]>;
    /**
     * If set to 'final', the returned data will include only finalized, stable data. If set to 'all', fresh data will be included. When using Incremental sync mode, we do not recommend setting this parameter to 'all' as it may cause data loss. More information can be found in our <a href='https://docs.airbyte.com/integrations/source/google-search-console'>full documentation</a>. Default: "final"; must be one of ["final", "all"]
     */
    dataState?: pulumi.Input<string>;
    /**
     * UTC date in the format YYYY-MM-DD. Any data created after this date will not be replicated. Must be greater or equal to the start date field. Leaving this field blank will replicate all data from the start date onward.
     */
    endDate?: pulumi.Input<string>;
    /**
     * The URLs of the website property attached to your GSC account. Learn more about properties <a href="https://support.google.com/webmasters/answer/34592?hl=en">here</a>.
     */
    siteUrls: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. Default: "2021-01-01"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorization {
    oAuth?: pulumi.Input<inputs.SourceGoogleSearchConsoleConfigurationAuthorizationOAuth>;
    serviceAccountKeyAuthentication?: pulumi.Input<inputs.SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication>;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorizationOAuth {
    /**
     * Access token for making authenticated requests. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The client ID of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret of your Google Search Console developer application. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The token for obtaining a new access token. Read more <a href="https://developers.google.com/webmaster-tools/v1/how-tos/authorizing">here</a>.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceGoogleSearchConsoleConfigurationAuthorizationServiceAccountKeyAuthentication {
    /**
     * The email of the user which has permissions to access the Google Workspace Admin APIs.
     */
    email: pulumi.Input<string>;
    /**
     * The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys">here</a>.
     */
    serviceAccountInfo: pulumi.Input<string>;
}

export interface SourceGoogleSearchConsoleConfigurationCustomReportsArray {
    /**
     * A list of available dimensions. Please note, that for technical reasons `date` is the default dimension which will be included in your query whether you specify it or not. Primary key will consist of your custom dimensions and the default dimension along with `site_url` and `search_type`.
     */
    dimensions?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The name of the custom report, this name would be used as stream name
     */
    name: pulumi.Input<string>;
}

export interface SourceGoogleSearchConsoleResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleSearchConsoleResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleSearchConsoleResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleSearchConsoleResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleSearchConsoleResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleSearchConsoleResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleSearchConsoleResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleSheetsConfiguration {
    /**
     * Default value is 1000000. An integer representing row batch size for each sent request to Google Sheets API. Row batch size means how many rows are processed from the google sheet, for example default value 1000000 would process rows 2-1000002, then 1000003-2000003 and so on. Based on <a href='https://developers.google.com/sheets/api/limits'>Google Sheets API limits documentation</a>, it is possible to send up to 300 requests per minute, but each individual request has to be processed under 180 seconds, otherwise the request returns a timeout error. In regards to this information, consider network speed and number of columns of the google sheet when deciding a batch_size value. Default: 1000000
     */
    batchSize?: pulumi.Input<number>;
    /**
     * Credentials for connecting to the Google Sheets API
     */
    credentials: pulumi.Input<inputs.SourceGoogleSheetsConfigurationCredentials>;
    /**
     * Enables the conversion of column names to a standardized, SQL-compliant format. For example, 'My Name' > 'my_name'. Enable this option if your destination is SQL-based. Default: false
     */
    namesConversion?: pulumi.Input<boolean>;
    /**
     * Enter the link to the Google spreadsheet you want to sync. To copy the link, click the 'Share' button in the top-right corner of the spreadsheet, then click 'Copy link'.
     */
    spreadsheetId: pulumi.Input<string>;
}

export interface SourceGoogleSheetsConfigurationCredentials {
    authenticateViaGoogleOAuth?: pulumi.Input<inputs.SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth>;
    serviceAccountKeyAuthentication?: pulumi.Input<inputs.SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication>;
}

export interface SourceGoogleSheetsConfigurationCredentialsAuthenticateViaGoogleOAuth {
    /**
     * Enter your Google application's Client ID. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
     */
    clientId: pulumi.Input<string>;
    /**
     * Enter your Google application's Client Secret. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Enter your Google application's refresh token. See <a href='https://developers.google.com/identity/protocols/oauth2'>Google's documentation</a> for more information.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceGoogleSheetsConfigurationCredentialsServiceAccountKeyAuthentication {
    /**
     * The JSON key of the service account to use for authorization. Read more <a href="https://cloud.google.com/iam/docs/creating-managing-service-account-keys#creating_service_account_keys">here</a>.
     */
    serviceAccountInfo: pulumi.Input<string>;
}

export interface SourceGoogleSheetsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleSheetsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleSheetsResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleSheetsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleSheetsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleSheetsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleSheetsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleTasksConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * The maximum number of records to be returned per request. Default: "50"
     */
    recordsLimit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceGoogleTasksResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleTasksResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleTasksResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleTasksResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleTasksResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleTasksResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleTasksResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleWebfontsConfiguration {
    /**
     * Optional, Available params- json, media, proto
     */
    alt?: pulumi.Input<string>;
    /**
     * API key is required to access google apis, For getting your's goto google console and generate api key for Webfonts
     */
    apiKey: pulumi.Input<string>;
    /**
     * Optional, boolean type
     */
    prettyPrint?: pulumi.Input<string>;
    /**
     * Optional, to find how to sort
     */
    sort?: pulumi.Input<string>;
}

export interface SourceGoogleWebfontsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGoogleWebfontsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGoogleWebfontsResourceAllocationJobSpecific>[]>;
}

export interface SourceGoogleWebfontsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGoogleWebfontsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGoogleWebfontsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGoogleWebfontsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGorgiasConfiguration {
    /**
     * Domain name given for gorgias, found as your url prefix for accessing your website
     */
    domainName: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceGorgiasResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGorgiasResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGorgiasResourceAllocationJobSpecific>[]>;
}

export interface SourceGorgiasResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGorgiasResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGorgiasResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGorgiasResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGreenhouseConfiguration {
    /**
     * Greenhouse API Key. See the <a href="https://docs.airbyte.com/integrations/sources/greenhouse">docs</a> for more information on how to generate this key.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceGreenhouseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGreenhouseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGreenhouseResourceAllocationJobSpecific>[]>;
}

export interface SourceGreenhouseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGreenhouseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGreenhouseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGreenhouseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGreythrConfiguration {
    /**
     * https://api.greythr.com
     */
    baseUrl: pulumi.Input<string>;
    /**
     * Your GreytHR Host URL
     */
    domain: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceGreythrResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGreythrResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGreythrResourceAllocationJobSpecific>[]>;
}

export interface SourceGreythrResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGreythrResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGreythrResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGreythrResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGridlyConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * ID of a grid, or can be ID of a branch
     */
    gridId: pulumi.Input<string>;
}

export interface SourceGridlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGridlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGridlyResourceAllocationJobSpecific>[]>;
}

export interface SourceGridlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGridlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGridlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGridlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGuruConfiguration {
    password?: pulumi.Input<string>;
    /**
     * Query for searching cards
     */
    searchCardsQuery?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * Team ID received through response of /teams streams, make sure about access to the team
     */
    teamId?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceGuruResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGuruResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGuruResourceAllocationJobSpecific>[]>;
}

export interface SourceGuruResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGuruResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGuruResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGuruResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGutendexConfiguration {
    /**
     * (Optional) Defines the maximum birth year of the authors. Books by authors born after the end year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    authorYearEnd?: pulumi.Input<string>;
    /**
     * (Optional) Defines the minimum birth year of the authors. Books by authors born prior to the start year will not be returned. Supports both positive (CE) or negative (BCE) integer values
     */
    authorYearStart?: pulumi.Input<string>;
    /**
     * (Optional) Use this to find books with a certain copyright status - true for books with existing copyrights, false for books in the public domain in the USA, or null for books with no available copyright information.
     */
    copyright?: pulumi.Input<string>;
    /**
     * (Optional) Use this to find books in any of a list of languages. They must be comma-separated, two-character language codes.
     */
    languages?: pulumi.Input<string>;
    /**
     * (Optional) Use this to search author names and book titles with given words. They must be separated by a space (i.e. %20 in URL-encoded format) and are case-insensitive.
     */
    search?: pulumi.Input<string>;
    /**
     * (Optional) Use this to sort books - ascending for Project Gutenberg ID numbers from lowest to highest, descending for IDs highest to lowest, or popular (the default) for most popular to least popular by number of downloads.
     */
    sort?: pulumi.Input<string>;
    /**
     * (Optional) Use this to search for a case-insensitive key-phrase in books' bookshelves or subjects.
     */
    topic?: pulumi.Input<string>;
}

export interface SourceGutendexResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceGutendexResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceGutendexResourceAllocationJobSpecific>[]>;
}

export interface SourceGutendexResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceGutendexResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceGutendexResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceGutendexResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHardcodedRecordsConfiguration {
    /**
     * How many records per stream should be generated. Default: 1000
     */
    count?: pulumi.Input<number>;
}

export interface SourceHardcodedRecordsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHardcodedRecordsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHardcodedRecordsResourceAllocationJobSpecific>[]>;
}

export interface SourceHardcodedRecordsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHardcodedRecordsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHardcodedRecordsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHardcodedRecordsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHarnessConfiguration {
    /**
     * Harness Account ID
     */
    accountId: pulumi.Input<string>;
    apiKey: pulumi.Input<string>;
    /**
     * The API URL for fetching data from Harness. Default: "https://app.harness.io"
     */
    apiUrl?: pulumi.Input<string>;
}

export interface SourceHarnessResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHarnessResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHarnessResourceAllocationJobSpecific>[]>;
}

export interface SourceHarnessResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHarnessResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHarnessResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHarnessResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHarvestConfiguration {
    /**
     * Harvest account ID. Required for all Harvest requests in pair with Personal Access Token
     */
    accountId: pulumi.Input<string>;
    /**
     * Choose how to authenticate to Harvest.
     */
    credentials?: pulumi.Input<inputs.SourceHarvestConfigurationCredentials>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    replicationStartDate: pulumi.Input<string>;
}

export interface SourceHarvestConfigurationCredentials {
    authenticateViaHarvestOAuth?: pulumi.Input<inputs.SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth>;
    authenticateWithPersonalAccessToken?: pulumi.Input<inputs.SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken>;
}

export interface SourceHarvestConfigurationCredentialsAuthenticateViaHarvestOAuth {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The Client ID of your Harvest developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Harvest developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceHarvestConfigurationCredentialsAuthenticateWithPersonalAccessToken {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Log into Harvest and then create new <a href="https://id.getharvest.com/developers"> personal access token</a>.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceHarvestResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHarvestResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHarvestResourceAllocationJobSpecific>[]>;
}

export interface SourceHarvestResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHarvestResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHarvestResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHarvestResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHeightConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Search query to be used with search stream. Default: "task"
     */
    searchQuery?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceHeightResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHeightResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHeightResourceAllocationJobSpecific>[]>;
}

export interface SourceHeightResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHeightResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHeightResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHeightResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHellobatonConfiguration {
    /**
     * authentication key required to access the api endpoints
     */
    apiKey: pulumi.Input<string>;
    /**
     * Company name that generates your base api url
     */
    company: pulumi.Input<string>;
}

export interface SourceHellobatonResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHellobatonResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHellobatonResourceAllocationJobSpecific>[]>;
}

export interface SourceHellobatonResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHellobatonResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHellobatonResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHellobatonResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHelpScoutConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceHelpScoutResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHelpScoutResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHelpScoutResourceAllocationJobSpecific>[]>;
}

export interface SourceHelpScoutResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHelpScoutResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHelpScoutResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHelpScoutResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHibobConfiguration {
    /**
     * Toggle true if this instance is a HiBob sandbox
     */
    isSandbox: pulumi.Input<boolean>;
    password?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceHibobResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHibobResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHibobResourceAllocationJobSpecific>[]>;
}

export interface SourceHibobResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHibobResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHibobResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHibobResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHighLevelConfiguration {
    apiKey: pulumi.Input<string>;
    locationId: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceHighLevelResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHighLevelResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHighLevelResourceAllocationJobSpecific>[]>;
}

export interface SourceHighLevelResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHighLevelResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHighLevelResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHighLevelResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHoorayhrConfiguration {
    hoorayhrpassword: pulumi.Input<string>;
    hoorayhrusername: pulumi.Input<string>;
}

export interface SourceHoorayhrResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHoorayhrResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHoorayhrResourceAllocationJobSpecific>[]>;
}

export interface SourceHoorayhrResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHoorayhrResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHoorayhrResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHoorayhrResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHubplannerConfiguration {
    /**
     * Hubplanner API key. See https://github.com/hubplanner/API#authentication for more details.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceHubplannerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHubplannerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHubplannerResourceAllocationJobSpecific>[]>;
}

export interface SourceHubplannerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHubplannerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHubplannerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHubplannerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHubspotConfiguration {
    /**
     * Choose how to authenticate to HubSpot.
     */
    credentials: pulumi.Input<inputs.SourceHubspotConfigurationCredentials>;
    /**
     * If enabled then experimental streams become available for sync. Default: false
     */
    enableExperimentalStreams?: pulumi.Input<boolean>;
    /**
     * The number of worker threads to use for the sync. Default: 3
     */
    numWorker?: pulumi.Input<number>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. If not set, "2006-06-01T00:00:00Z" (Hubspot creation date) will be used as start date. It's recommended to provide relevant to your data start date value to optimize synchronization.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceHubspotConfigurationCredentials {
    oAuth?: pulumi.Input<inputs.SourceHubspotConfigurationCredentialsOAuth>;
    privateApp?: pulumi.Input<inputs.SourceHubspotConfigurationCredentialsPrivateApp>;
}

export interface SourceHubspotConfigurationCredentialsOAuth {
    /**
     * The Client ID of your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this ID.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret for your HubSpot developer application. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this secret.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh token to renew an expired access token. See the <a href="https://legacydocs.hubspot.com/docs/methods/oauth2/oauth2-quickstart">Hubspot docs</a> if you need help finding this token.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceHubspotConfigurationCredentialsPrivateApp {
    /**
     * HubSpot Access token. See the <a href="https://developers.hubspot.com/docs/api/private-apps">Hubspot docs</a> if you need help finding this token.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceHubspotResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHubspotResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHubspotResourceAllocationJobSpecific>[]>;
}

export interface SourceHubspotResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHubspotResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHubspotResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHubspotResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHuggingFaceDatasetsConfiguration {
    datasetName: pulumi.Input<string>;
    /**
     * Splits to import. Will import all of them if nothing is provided (see https://huggingface.co/docs/dataset-viewer/en/configs_and_splits for more details)
     */
    datasetSplits?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Dataset Subsets to import. Will import all of them if nothing is provided (see https://huggingface.co/docs/dataset-viewer/en/configs_and_splits for more details)
     */
    datasetSubsets?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceHuggingFaceDatasetsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHuggingFaceDatasetsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHuggingFaceDatasetsResourceAllocationJobSpecific>[]>;
}

export interface SourceHuggingFaceDatasetsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHuggingFaceDatasetsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHuggingFaceDatasetsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHuggingFaceDatasetsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHumanitixConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceHumanitixResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHumanitixResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHumanitixResourceAllocationJobSpecific>[]>;
}

export interface SourceHumanitixResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHumanitixResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHumanitixResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHumanitixResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHuntrConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceHuntrResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceHuntrResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceHuntrResourceAllocationJobSpecific>[]>;
}

export interface SourceHuntrResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceHuntrResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceHuntrResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceHuntrResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIlluminaBasespaceConfiguration {
    /**
     * BaseSpace access token. Instructions for obtaining your access token can be found in the BaseSpace Developer Documentation.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Domain name of the BaseSpace instance (e.g., euw2.sh.basespace.illumina.com)
     */
    domain: pulumi.Input<string>;
    /**
     * Providing a user ID restricts the returned data to what that user can access. If you use the default ('current'), all data accessible to the user associated with the API key will be shown. Default: "current"
     */
    user?: pulumi.Input<string>;
}

export interface SourceIlluminaBasespaceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceIlluminaBasespaceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceIlluminaBasespaceResourceAllocationJobSpecific>[]>;
}

export interface SourceIlluminaBasespaceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIlluminaBasespaceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceIlluminaBasespaceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceIlluminaBasespaceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceImaggaConfiguration {
    /**
     * Your Imagga API key, available in your Imagga dashboard. Could be found at `https://imagga.com/profile/dashboard`
     */
    apiKey: pulumi.Input<string>;
    /**
     * Your Imagga API secret, available in your Imagga dashboard. Could be found at `https://imagga.com/profile/dashboard`
     */
    apiSecret: pulumi.Input<string>;
    /**
     * An image for detection endpoints. Default: "https://imagga.com/static/images/categorization/child-476506_640.jpg"
     */
    imgForDetection?: pulumi.Input<string>;
}

export interface SourceImaggaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceImaggaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceImaggaResourceAllocationJobSpecific>[]>;
}

export interface SourceImaggaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceImaggaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceImaggaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceImaggaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIncidentIoConfiguration {
    /**
     * API key to use. Find it at https://app.incident.io/settings/api-keys
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceIncidentIoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceIncidentIoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceIncidentIoResourceAllocationJobSpecific>[]>;
}

export interface SourceIncidentIoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIncidentIoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceIncidentIoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceIncidentIoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInflowinventoryConfiguration {
    apiKey: pulumi.Input<string>;
    companyid: pulumi.Input<string>;
}

export interface SourceInflowinventoryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceInflowinventoryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceInflowinventoryResourceAllocationJobSpecific>[]>;
}

export interface SourceInflowinventoryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInflowinventoryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceInflowinventoryResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceInflowinventoryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInsightfulConfiguration {
    /**
     * Your API token for accessing the Insightful API. Generate it by logging in as an Admin to your organization's account, navigating to the API page, and creating a new token. Note that this token will only be shown once, so store it securely.
     */
    apiToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceInsightfulResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceInsightfulResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceInsightfulResourceAllocationJobSpecific>[]>;
}

export interface SourceInsightfulResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInsightfulResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceInsightfulResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceInsightfulResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInsightlyConfiguration {
    /**
     * The date from which you'd like to replicate data for Insightly in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only for incremental streams.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Your Insightly API token.
     */
    token?: pulumi.Input<string>;
}

export interface SourceInsightlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceInsightlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceInsightlyResourceAllocationJobSpecific>[]>;
}

export interface SourceInsightlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInsightlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceInsightlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceInsightlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInstagramConfiguration {
    /**
     * The value of the access token generated with <b>instagram_basic, instagram_manage_insights, pages_show_list, pages_read_engagement, Instagram Public Content Access</b> permissions. See the <a href="https://docs.airbyte.com/integrations/sources/instagram/#step-1-set-up-instagram">docs</a> for more information
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID for your Oauth application
     */
    clientId?: pulumi.Input<string>;
    /**
     * The Client Secret for your Oauth application
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * The number of worker threads to use for the sync. Default: 15
     */
    numWorkers?: pulumi.Input<number>;
    /**
     * The date from which you'd like to replicate data for User Insights, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. If left blank, the start date will be set to 2 years before the present date.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceInstagramResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceInstagramResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceInstagramResourceAllocationJobSpecific>[]>;
}

export interface SourceInstagramResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInstagramResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceInstagramResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceInstagramResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInstatusConfiguration {
    /**
     * Instatus REST API key
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceInstatusResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceInstatusResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceInstatusResourceAllocationJobSpecific>[]>;
}

export interface SourceInstatusResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInstatusResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceInstatusResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceInstatusResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIntercomConfiguration {
    /**
     * Access token for making authenticated requests. See the <a href="https://developers.intercom.com/building-apps/docs/authentication-types#how-to-get-your-access-token">Intercom docs</a> for more information.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Set lower value in case of failing long running sync of Activity Logs stream. Default: 30
     */
    activityLogsTimeStep?: pulumi.Input<number>;
    /**
     * Client Id for your Intercom application.
     */
    clientId?: pulumi.Input<string>;
    /**
     * Client Secret for your Intercom application.
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * The number of days to shift the state value backward for record sync. Default: 0
     */
    lookbackWindow?: pulumi.Input<number>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceIntercomResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceIntercomResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceIntercomResourceAllocationJobSpecific>[]>;
}

export interface SourceIntercomResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIntercomResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceIntercomResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceIntercomResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIntruderConfiguration {
    /**
     * Your API Access token. See <a href="https://developers.intruder.io/docs/authentication">here</a>.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceIntruderResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceIntruderResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceIntruderResourceAllocationJobSpecific>[]>;
}

export interface SourceIntruderResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIntruderResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceIntruderResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceIntruderResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInvoicedConfiguration {
    /**
     * API key to use. Find it at https://invoiced.com/account
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceInvoicedResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceInvoicedResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceInvoicedResourceAllocationJobSpecific>[]>;
}

export interface SourceInvoicedResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInvoicedResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceInvoicedResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceInvoicedResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInvoiceninjaConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceInvoiceninjaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceInvoiceninjaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceInvoiceninjaResourceAllocationJobSpecific>[]>;
}

export interface SourceInvoiceninjaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceInvoiceninjaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceInvoiceninjaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceInvoiceninjaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIp2whoisConfiguration {
    /**
     * Your API Key. See <a href="https://www.ip2whois.com/developers-api">here</a>.
     */
    apiKey?: pulumi.Input<string>;
    /**
     * Domain name. See <a href="https://www.ip2whois.com/developers-api">here</a>.
     */
    domain?: pulumi.Input<string>;
}

export interface SourceIp2whoisResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceIp2whoisResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceIp2whoisResourceAllocationJobSpecific>[]>;
}

export interface SourceIp2whoisResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIp2whoisResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceIp2whoisResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceIp2whoisResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIterableConfiguration {
    /**
     * Iterable API Key. See the <a href=\"https://docs.airbyte.com/integrations/sources/iterable\">docs</a>  for more information on how to obtain this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data for Iterable, in the format YYYY-MM-DDT00:00:00Z.  All data generated after this date will be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceIterableResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceIterableResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceIterableResourceAllocationJobSpecific>[]>;
}

export interface SourceIterableResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceIterableResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceIterableResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceIterableResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJamfProConfiguration {
    password?: pulumi.Input<string>;
    /**
     * The unique subdomain for your Jamf Pro instance.
     */
    subdomain: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceJamfProResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceJamfProResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceJamfProResourceAllocationJobSpecific>[]>;
}

export interface SourceJamfProResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJamfProResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceJamfProResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceJamfProResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJiraConfiguration {
    /**
     * Jira API Token. See the <a href="https://docs.airbyte.com/integrations/sources/jira">docs</a> for more information on how to generate this key. API Token is used for Authorization to your account by BasicAuth.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The Domain for your Jira account, e.g. airbyteio.atlassian.net, airbyteio.jira.com, jira.your-domain.com
     */
    domain: pulumi.Input<string>;
    /**
     * The user email for your Jira account which you used to generate the API token. This field is used for Authorization to your account by BasicAuth.
     */
    email: pulumi.Input<string>;
    /**
     * Allow the use of experimental streams which rely on undocumented Jira API endpoints. See https://docs.airbyte.com/integrations/sources/jira#experimental-tables for more info. Default: false
     */
    enableExperimentalStreams?: pulumi.Input<boolean>;
    /**
     * When set to N, the connector will always refresh resources created within the past N minutes. By default, updated objects that are not newly created are not incrementally synced. Default: 0
     */
    lookbackWindowMinutes?: pulumi.Input<number>;
    /**
     * The number of worker threads to use for the sync. Default: 3
     */
    numWorkers?: pulumi.Input<number>;
    /**
     * List of Jira project keys to replicate data for, or leave it empty if you want to replicate data for all projects.
     */
    projects?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The date from which you want to replicate data from Jira, use the format YYYY-MM-DDT00:00:00Z. Note that this field only applies to certain streams, and only data generated on or after the start date will be replicated. Or leave it empty if you want to replicate all data. For more information, refer to the <a href="https://docs.airbyte.com/integrations/sources/jira/">documentation</a>.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceJiraResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceJiraResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceJiraResourceAllocationJobSpecific>[]>;
}

export interface SourceJiraResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJiraResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceJiraResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceJiraResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJobnimbusConfiguration {
    /**
     * API key to use. Find it by logging into your JobNimbus account, navigating to settings, and creating a new API key under the API section.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceJobnimbusResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceJobnimbusResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceJobnimbusResourceAllocationJobSpecific>[]>;
}

export interface SourceJobnimbusResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJobnimbusResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceJobnimbusResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceJobnimbusResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJotformConfiguration {
    apiEndpoint: pulumi.Input<inputs.SourceJotformConfigurationApiEndpoint>;
    apiKey: pulumi.Input<string>;
    endDate: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceJotformConfigurationApiEndpoint {
    basic?: pulumi.Input<inputs.SourceJotformConfigurationApiEndpointBasic>;
    enterprise?: pulumi.Input<inputs.SourceJotformConfigurationApiEndpointEnterprise>;
}

export interface SourceJotformConfigurationApiEndpointBasic {
    /**
     * You can access our API through the following URLs - Standard API Usage (Use the default API URL - https://api.jotform.com), For EU (Use the EU API URL - https://eu-api.jotform.com), For HIPAA (Use the HIPAA API URL - https://hipaa-api.jotform.com). Default: "Standard"; must be one of ["Standard", "EU", "HIPAA"]
     */
    urlPrefix?: pulumi.Input<string>;
}

export interface SourceJotformConfigurationApiEndpointEnterprise {
    /**
     * Upgrade to Enterprise to make your API url your-domain.com/API or subdomain.jotform.com/API instead of api.jotform.com
     */
    enterpriseUrl: pulumi.Input<string>;
}

export interface SourceJotformResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceJotformResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceJotformResourceAllocationJobSpecific>[]>;
}

export interface SourceJotformResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJotformResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceJotformResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceJotformResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJustSiftConfiguration {
    /**
     * API token to use for accessing the Sift API. Obtain this token from your Sift account administrator.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceJustSiftResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceJustSiftResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceJustSiftResourceAllocationJobSpecific>[]>;
}

export interface SourceJustSiftResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJustSiftResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceJustSiftResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceJustSiftResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJustcallConfiguration {
    apiKey2: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceJustcallResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceJustcallResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceJustcallResourceAllocationJobSpecific>[]>;
}

export interface SourceJustcallResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceJustcallResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceJustcallResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceJustcallResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceK6CloudConfiguration {
    /**
     * Your API Token. See <a href="https://k6.io/docs/cloud/integrations/token/">here</a>. The key is case sensitive.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceK6CloudResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceK6CloudResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceK6CloudResourceAllocationJobSpecific>[]>;
}

export interface SourceK6CloudResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceK6CloudResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceK6CloudResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceK6CloudResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKatanaConfiguration {
    /**
     * API key to use. Find it at https://katanamrp.com/login/
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceKatanaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKatanaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKatanaResourceAllocationJobSpecific>[]>;
}

export interface SourceKatanaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKatanaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKatanaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKatanaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKekaConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Your client identifier for authentication.
     */
    clientId: pulumi.Input<string>;
    /**
     * Your client secret for secure authentication.
     */
    clientSecret: pulumi.Input<string>;
    grantType: pulumi.Input<string>;
    scope: pulumi.Input<string>;
}

export interface SourceKekaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKekaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKekaResourceAllocationJobSpecific>[]>;
}

export interface SourceKekaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKekaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKekaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKekaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKisiConfiguration {
    /**
     * Your KISI API Key
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceKisiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKisiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKisiResourceAllocationJobSpecific>[]>;
}

export interface SourceKisiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKisiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKisiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKisiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKissmetricsConfiguration {
    password?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceKissmetricsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKissmetricsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKissmetricsResourceAllocationJobSpecific>[]>;
}

export interface SourceKissmetricsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKissmetricsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKissmetricsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKissmetricsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKlarnaConfiguration {
    /**
     * A string which is associated with your Merchant ID and is used to authorize use of Klarna's APIs (https://developers.klarna.com/api/#authentication)
     */
    password: pulumi.Input<string>;
    /**
     * Propertie defining if connector is used against playground or production environment. Default: false
     */
    playground?: pulumi.Input<boolean>;
    /**
     * Base url region (For playground eu https://docs.klarna.com/klarna-payments/api/payments-api/#tag/API-URLs). Supported 'eu', 'na', 'oc'. must be one of ["eu", "na", "oc"]
     */
    region: pulumi.Input<string>;
    /**
     * Consists of your Merchant ID (eid) - a unique number that identifies your e-store, combined with a random string (https://developers.klarna.com/api/#authentication)
     */
    username: pulumi.Input<string>;
}

export interface SourceKlarnaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKlarnaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKlarnaResourceAllocationJobSpecific>[]>;
}

export interface SourceKlarnaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKlarnaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKlarnaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKlarnaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKlausApiConfiguration {
    /**
     * getting data by account
     */
    account: pulumi.Input<number>;
    /**
     * API access key used to retrieve data from the KLAUS API.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Start getting data from that date.
     */
    startDate?: pulumi.Input<string>;
    /**
     * getting data by workspace
     */
    workspace: pulumi.Input<number>;
}

export interface SourceKlausApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKlausApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKlausApiResourceAllocationJobSpecific>[]>;
}

export interface SourceKlausApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKlausApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKlausApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKlausApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKlaviyoConfiguration {
    /**
     * Klaviyo API Key. See our <a href="https://docs.airbyte.com/integrations/sources/klaviyo">docs</a> if you need help finding this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Certain streams like the profiles stream can retrieve predictive analytics data from Klaviyo's API. However, at high volume, this can lead to service availability issues on the API which can be improved by not fetching this field. WARNING: Enabling this setting will stop the  "predictive_analytics" column from being populated in your downstream destination.
     */
    disableFetchingPredictiveAnalytics?: pulumi.Input<boolean>;
    /**
     * The number of worker threads to use for the sync. The performance upper boundary is based on the limit of your Klaviyo plan. More info about the rate limit plan tiers can be found on Klaviyo's API <a href="https://developers.klaviyo.com/en/docs/rate_limits_and_error_handling">docs</a>. Default: 10
     */
    numWorkers?: pulumi.Input<number>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. This field is optional - if not provided, all data will be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceKlaviyoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKlaviyoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKlaviyoResourceAllocationJobSpecific>[]>;
}

export interface SourceKlaviyoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKlaviyoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKlaviyoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKlaviyoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKyveConfiguration {
    /**
     * The IDs of the KYVE storage pool you want to archive. (Comma separated)
     */
    poolIds: pulumi.Input<string>;
    /**
     * The start-id defines, from which bundle id the pipeline should start to extract the data. (Comma separated)
     */
    startIds: pulumi.Input<string>;
    /**
     * URL to the KYVE Chain API. Default: "https://api.kyve.network"
     */
    urlBase?: pulumi.Input<string>;
}

export interface SourceKyveResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceKyveResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceKyveResourceAllocationJobSpecific>[]>;
}

export interface SourceKyveResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceKyveResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceKyveResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceKyveResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLaunchdarklyConfiguration {
    /**
     * Your Access token. See <a href="https://apidocs.launchdarkly.com/#section/Overview/Authentication">here</a>.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceLaunchdarklyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLaunchdarklyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLaunchdarklyResourceAllocationJobSpecific>[]>;
}

export interface SourceLaunchdarklyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLaunchdarklyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLaunchdarklyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLaunchdarklyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLeadfeederConfiguration {
    apiToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceLeadfeederResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLeadfeederResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLeadfeederResourceAllocationJobSpecific>[]>;
}

export interface SourceLeadfeederResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLeadfeederResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLeadfeederResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLeadfeederResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLemlistConfiguration {
    /**
     * Lemlist API key,
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceLemlistResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLemlistResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLemlistResourceAllocationJobSpecific>[]>;
}

export interface SourceLemlistResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLemlistResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLemlistResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLemlistResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLessAnnoyingCrmConfiguration {
    /**
     * API key to use. Manage and create your API keys on the Programmer API settings page at https://account.lessannoyingcrm.com/app/Settings/Api.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceLessAnnoyingCrmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLessAnnoyingCrmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLessAnnoyingCrmResourceAllocationJobSpecific>[]>;
}

export interface SourceLessAnnoyingCrmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLessAnnoyingCrmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLessAnnoyingCrmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLessAnnoyingCrmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLeverHiringConfiguration {
    /**
     * Choose how to authenticate to Lever Hiring.
     */
    credentials?: pulumi.Input<inputs.SourceLeverHiringConfigurationCredentials>;
    /**
     * The environment in which you'd like to replicate data for Lever. This is used to determine which Lever API endpoint to use. Default: "Sandbox"; must be one of ["Production", "Sandbox"]
     */
    environment?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. Note that it will be used only in the following incremental streams: comments, commits, and issues.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceLeverHiringConfigurationCredentials {
    authenticateViaLeverApiKey?: pulumi.Input<inputs.SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey>;
    authenticateViaLeverOAuth?: pulumi.Input<inputs.SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth>;
}

export interface SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverApiKey {
    /**
     * The Api Key of your Lever Hiring account.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceLeverHiringConfigurationCredentialsAuthenticateViaLeverOAuth {
    /**
     * The Client ID of your Lever Hiring developer application.
     */
    clientId?: pulumi.Input<string>;
    /**
     * The Client Secret of your Lever Hiring developer application.
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * The token for obtaining new access token.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceLeverHiringResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLeverHiringResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLeverHiringResourceAllocationJobSpecific>[]>;
}

export interface SourceLeverHiringResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLeverHiringResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLeverHiringResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLeverHiringResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLightspeedRetailConfiguration {
    /**
     * API key or access token
     */
    apiKey: pulumi.Input<string>;
    /**
     * The subdomain for the retailer, e.g., 'example' in 'example.retail.lightspeed.app'.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceLightspeedRetailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLightspeedRetailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLightspeedRetailResourceAllocationJobSpecific>[]>;
}

export interface SourceLightspeedRetailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLightspeedRetailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLightspeedRetailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLightspeedRetailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinearConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceLinearResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLinearResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLinearResourceAllocationJobSpecific>[]>;
}

export interface SourceLinearResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinearResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLinearResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLinearResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinkedinAdsConfiguration {
    /**
     * Specify the account IDs to pull data from, separated by a space. Leave this field empty if you want to pull the data from all accounts accessible by the authenticated user. See the <a href="https://www.linkedin.com/help/linkedin/answer/a424270/find-linkedin-ads-account-details?lang=en">LinkedIn docs</a> to locate these IDs.
     */
    accountIds?: pulumi.Input<pulumi.Input<number>[]>;
    adAnalyticsReports?: pulumi.Input<pulumi.Input<inputs.SourceLinkedinAdsConfigurationAdAnalyticsReport>[]>;
    credentials?: pulumi.Input<inputs.SourceLinkedinAdsConfigurationCredentials>;
    /**
     * How far into the past to look for records. (in days). Default: 0
     */
    lookbackWindow?: pulumi.Input<number>;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceLinkedinAdsConfigurationAdAnalyticsReport {
    /**
     * The name for the custom report.
     */
    name: pulumi.Input<string>;
    /**
     * Choose a category to pivot your analytics report around. This selection will organize your data based on the chosen attribute, allowing you to analyze trends and performance from different perspectives. must be one of ["COMPANY", "ACCOUNT", "SHARE", "CAMPAIGN", "CREATIVE", "CAMPAIGN_GROUP", "CONVERSION", "CONVERSATION_NODE", "CONVERSATION_NODE_OPTION_INDEX", "SERVING_LOCATION", "CARD_INDEX", "MEMBER_COMPANY_SIZE", "MEMBER_INDUSTRY", "MEMBER_SENIORITY", "MEMBER_JOB_TITLE", "MEMBER_JOB_FUNCTION", "MEMBER_COUNTRY_V2", "MEMBER_REGION_V2", "MEMBER_COMPANY", "PLACEMENT_NAME", "IMPRESSION_DEVICE_TYPE"]
     */
    pivotBy: pulumi.Input<string>;
    /**
     * Choose how to group the data in your report by time. The options are:<br>- 'ALL': A single result summarizing the entire time range.<br>- 'DAILY': Group results by each day.<br>- 'MONTHLY': Group results by each month.<br>- 'YEARLY': Group results by each year.<br>Selecting a time grouping helps you analyze trends and patterns over different time periods. must be one of ["ALL", "DAILY", "MONTHLY", "YEARLY"]
     */
    timeGranularity: pulumi.Input<string>;
}

export interface SourceLinkedinAdsConfigurationCredentials {
    accessToken?: pulumi.Input<inputs.SourceLinkedinAdsConfigurationCredentialsAccessToken>;
    oAuth20?: pulumi.Input<inputs.SourceLinkedinAdsConfigurationCredentialsOAuth20>;
}

export interface SourceLinkedinAdsConfigurationCredentialsAccessToken {
    /**
     * The access token generated for your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceLinkedinAdsConfigurationCredentialsOAuth20 {
    /**
     * The client ID of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret of your developer application. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The key to refresh the expired access token. Refer to our <a href='https://docs.airbyte.com/integrations/sources/linkedin-ads#setup-guide'>documentation</a> for more information.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceLinkedinAdsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLinkedinAdsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLinkedinAdsResourceAllocationJobSpecific>[]>;
}

export interface SourceLinkedinAdsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinkedinAdsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLinkedinAdsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLinkedinAdsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinkedinPagesConfiguration {
    credentials?: pulumi.Input<inputs.SourceLinkedinPagesConfigurationCredentials>;
    /**
     * Specify the Organization ID
     */
    orgId: pulumi.Input<string>;
    /**
     * Start date for getting metrics per time period. Must be atmost 12 months before the request date (UTC) and atleast 2 days prior to the request date (UTC). See https://bit.ly/linkedin-pages-date-rules {{ "\n" }} {{ response.errorDetails }}. Default: "2023-01-01T00:00:00Z"
     */
    startDate?: pulumi.Input<string>;
    /**
     * Granularity of the statistics for metrics per time period. Must be either "DAY" or "MONTH". Default: "DAY"; must be one of ["DAY", "MONTH"]
     */
    timeGranularityType?: pulumi.Input<string>;
}

export interface SourceLinkedinPagesConfigurationCredentials {
    accessToken?: pulumi.Input<inputs.SourceLinkedinPagesConfigurationCredentialsAccessToken>;
    oAuth20?: pulumi.Input<inputs.SourceLinkedinPagesConfigurationCredentialsOAuth20>;
}

export interface SourceLinkedinPagesConfigurationCredentialsAccessToken {
    /**
     * The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceLinkedinPagesConfigurationCredentialsOAuth20 {
    /**
     * The client ID of the LinkedIn developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret of the LinkedIn developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The token value generated using the LinkedIn Developers OAuth Token Tools. See the <a href="https://docs.airbyte.com/integrations/sources/linkedin-pages/">docs</a> to obtain yours.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceLinkedinPagesResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLinkedinPagesResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLinkedinPagesResourceAllocationJobSpecific>[]>;
}

export interface SourceLinkedinPagesResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinkedinPagesResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLinkedinPagesResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLinkedinPagesResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinnworksConfiguration {
    /**
     * Linnworks Application ID
     */
    applicationId: pulumi.Input<string>;
    /**
     * Linnworks Application Secret
     */
    applicationSecret: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
    token: pulumi.Input<string>;
}

export interface SourceLinnworksResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLinnworksResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLinnworksResourceAllocationJobSpecific>[]>;
}

export interface SourceLinnworksResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLinnworksResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLinnworksResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLinnworksResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLobConfiguration {
    /**
     * API key to use for authentication. You can find your account's API keys in your Dashboard Settings at https://dashboard.lob.com/settings/api-keys.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Max records per page limit. Default: "50"
     */
    limit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceLobResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLobResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLobResourceAllocationJobSpecific>[]>;
}

export interface SourceLobResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLobResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLobResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLobResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLokaliseConfiguration {
    /**
     * Lokalise API Key with read-access. Available at Profile settings > API tokens. See <a href="https://docs.lokalise.com/en/articles/1929556-api-tokens">here</a>.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Lokalise project ID. Available at Project Settings > General.
     */
    projectId: pulumi.Input<string>;
}

export interface SourceLokaliseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLokaliseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLokaliseResourceAllocationJobSpecific>[]>;
}

export interface SourceLokaliseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLokaliseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLokaliseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLokaliseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLookerConfiguration {
    /**
     * The Client ID is first part of an API3 key that is specific to each Looker user. See the <a href="https://docs.airbyte.com/integrations/sources/looker">docs</a> for more information on how to generate this key.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret is second part of an API3 key.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Domain for your Looker account, e.g. airbyte.cloud.looker.com,looker.[clientname].com,IP address
     */
    domain: pulumi.Input<string>;
    /**
     * The IDs of any Looks to run
     */
    runLookIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceLookerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLookerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLookerResourceAllocationJobSpecific>[]>;
}

export interface SourceLookerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLookerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLookerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLookerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLumaConfiguration {
    /**
     * Get your API key on lu.ma Calendars dashboard â†’ Settings.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceLumaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceLumaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceLumaResourceAllocationJobSpecific>[]>;
}

export interface SourceLumaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceLumaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceLumaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceLumaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailchimpConfiguration {
    credentials?: pulumi.Input<inputs.SourceMailchimpConfigurationCredentials>;
    /**
     * The date from which you want to start syncing data for Incremental streams. Only records that have been created or modified since this date will be synced. If left blank, all data will by synced.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceMailchimpConfigurationCredentials {
    apiKey?: pulumi.Input<inputs.SourceMailchimpConfigurationCredentialsApiKey>;
    oAuth20?: pulumi.Input<inputs.SourceMailchimpConfigurationCredentialsOAuth20>;
}

export interface SourceMailchimpConfigurationCredentialsApiKey {
    /**
     * Mailchimp API Key. See the <a href="https://docs.airbyte.com/integrations/sources/mailchimp">docs</a> for information on how to generate this key.
     */
    apikey: pulumi.Input<string>;
}

export interface SourceMailchimpConfigurationCredentialsOAuth20 {
    /**
     * An access token generated using the above client ID and secret.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of your OAuth application.
     */
    clientId?: pulumi.Input<string>;
    /**
     * The Client Secret of your OAuth application.
     */
    clientSecret?: pulumi.Input<string>;
}

export interface SourceMailchimpResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailchimpResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailchimpResourceAllocationJobSpecific>[]>;
}

export interface SourceMailchimpResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailchimpResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailchimpResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailchimpResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailerliteConfiguration {
    /**
     * Your API Token. See <a href="https://developers.mailerlite.com/docs/#authentication">here</a>.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceMailerliteResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailerliteResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailerliteResourceAllocationJobSpecific>[]>;
}

export interface SourceMailerliteResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailerliteResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailerliteResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailerliteResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailersendConfiguration {
    /**
     * Your API Token. See <a href="https://www.mailersend.com/help/managing-api-tokens">here</a>.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The domain entity in mailersend
     */
    domainId: pulumi.Input<string>;
    /**
     * Timestamp is assumed to be UTC.
     */
    startDate?: pulumi.Input<number>;
}

export interface SourceMailersendResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailersendResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailersendResourceAllocationJobSpecific>[]>;
}

export interface SourceMailersendResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailersendResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailersendResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailersendResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailgunConfiguration {
    /**
     * Domain region code. 'EU' or 'US' are possible values. The default is 'US'. Default: "US"; must be one of ["US", "EU"]
     */
    domainRegion?: pulumi.Input<string>;
    /**
     * Primary account API key to access your Mailgun data.
     */
    privateKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2020-10-01 00:00:00. Any data before this date will not be replicated. If omitted, defaults to 3 days ago.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceMailgunResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailgunResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailgunResourceAllocationJobSpecific>[]>;
}

export interface SourceMailgunResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailgunResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailgunResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailgunResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailjetMailConfiguration {
    /**
     * Your API Key. See <a href="https://dev.mailjet.com/email/guides/#authentication">here</a>.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Your API Secret Key. See <a href="https://dev.mailjet.com/email/guides/#authentication">here</a>.
     */
    apiKeySecret: pulumi.Input<string>;
}

export interface SourceMailjetMailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailjetMailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailjetMailResourceAllocationJobSpecific>[]>;
}

export interface SourceMailjetMailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailjetMailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailjetMailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailjetMailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailjetSmsConfiguration {
    /**
     * Retrieve SMS messages created before the specified timestamp. Required format - Unix timestamp.
     */
    endDate?: pulumi.Input<number>;
    /**
     * Retrieve SMS messages created after the specified timestamp. Required format - Unix timestamp.
     */
    startDate?: pulumi.Input<number>;
    /**
     * Your access token. See <a href="https://dev.mailjet.com/sms/reference/overview/authentication">here</a>.
     */
    token: pulumi.Input<string>;
}

export interface SourceMailjetSmsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailjetSmsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailjetSmsResourceAllocationJobSpecific>[]>;
}

export interface SourceMailjetSmsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailjetSmsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailjetSmsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailjetSmsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailosaurConfiguration {
    /**
     * Enter your api key here
     */
    password?: pulumi.Input<string>;
    /**
     * Enter "api" here
     */
    username: pulumi.Input<string>;
}

export interface SourceMailosaurResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailosaurResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailosaurResourceAllocationJobSpecific>[]>;
}

export interface SourceMailosaurResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailosaurResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailosaurResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailosaurResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailtrapConfiguration {
    /**
     * API token to use. Find it at https://mailtrap.io/account
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceMailtrapResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMailtrapResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMailtrapResourceAllocationJobSpecific>[]>;
}

export interface SourceMailtrapResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMailtrapResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMailtrapResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMailtrapResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMarketoConfiguration {
    /**
     * The Client ID of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Marketo developer application. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Your Marketo Base URL. See <a href="https://docs.airbyte.com/integrations/sources/marketo"> the docs </a> for info on how to obtain this.
     */
    domainUrl: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceMarketoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMarketoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMarketoResourceAllocationJobSpecific>[]>;
}

export interface SourceMarketoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMarketoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMarketoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMarketoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMarketstackConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceMarketstackResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMarketstackResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMarketstackResourceAllocationJobSpecific>[]>;
}

export interface SourceMarketstackResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMarketstackResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMarketstackResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMarketstackResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMendeleyConfiguration {
    /**
     * Could be found at `https://dev.mendeley.com/myapps.html`
     */
    clientId: pulumi.Input<string>;
    /**
     * Use cURL or Postman with the OAuth 2.0 Authorization tab. Set the Auth URL to https://api.mendeley.com/oauth/authorize, the Token URL to https://api.mendeley.com/oauth/token, and use all as the scope.
     */
    clientRefreshToken: pulumi.Input<string>;
    /**
     * Could be found at `https://dev.mendeley.com/myapps.html`
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The name parameter for institutions search. Default: "City University"
     */
    nameForInstitution?: pulumi.Input<string>;
    /**
     * Query for catalog search. Default: "Polar Bear"
     */
    queryForCatalog?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceMendeleyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMendeleyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMendeleyResourceAllocationJobSpecific>[]>;
}

export interface SourceMendeleyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMendeleyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMendeleyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMendeleyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMentionConfiguration {
    apiKey: pulumi.Input<string>;
    statsEndDate?: pulumi.Input<string>;
    /**
     * Periodicity of statistics returned. it may be daily(P1D), weekly(P1W) or monthly(P1M). Default: "P1D"; must be one of ["P1D", "P1W", "P1M"]
     */
    statsInterval?: pulumi.Input<string>;
    statsStartDate: pulumi.Input<string>;
}

export interface SourceMentionResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMentionResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMentionResourceAllocationJobSpecific>[]>;
}

export interface SourceMentionResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMentionResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMentionResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMentionResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMergeConfiguration {
    /**
     * Link your other integrations with account credentials on accounts section to get account token (ref - https://app.merge.dev/linked-accounts/accounts)
     */
    accountToken: pulumi.Input<string>;
    /**
     * API token can be seen at  https://app.merge.dev/keys
     */
    apiToken: pulumi.Input<string>;
    /**
     * Date time filter for incremental filter, Specify which date to extract from.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceMergeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMergeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMergeResourceAllocationJobSpecific>[]>;
}

export interface SourceMergeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMergeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMergeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMergeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMetabaseConfiguration {
    /**
     * URL to your metabase instance API
     */
    instanceApiUrl: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    /**
     * To generate your session token, you need to run the following command: ``` curl -X POST \
     *   -H "Content-Type: application/json" \
     *   -d '{"username": "person@metabase.com", "password": "fakepassword"}' \
     *   http://localhost:3000/api/session
     * ``` Then copy the value of the `id` field returned by a successful call to that API.
     * Note that by default, sessions are good for 14 days and needs to be regenerated.
     */
    sessionToken?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceMetabaseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMetabaseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMetabaseResourceAllocationJobSpecific>[]>;
}

export interface SourceMetabaseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMetabaseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMetabaseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMetabaseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftDataverseConfiguration {
    /**
     * App Registration Client Id
     */
    clientId: pulumi.Input<string>;
    /**
     * App Registration Client Secret
     */
    clientSecretValue: pulumi.Input<string>;
    /**
     * Max number of results per page. Default=5000. Default: 5000
     */
    odataMaxpagesize?: pulumi.Input<number>;
    /**
     * Tenant Id of your Microsoft Dataverse Instance
     */
    tenantId: pulumi.Input<string>;
    /**
     * URL to Microsoft Dataverse API
     */
    url: pulumi.Input<string>;
}

export interface SourceMicrosoftDataverseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMicrosoftDataverseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftDataverseResourceAllocationJobSpecific>[]>;
}

export interface SourceMicrosoftDataverseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftDataverseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMicrosoftDataverseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMicrosoftDataverseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftEntraIdConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    tenantId: pulumi.Input<string>;
    userId: pulumi.Input<string>;
}

export interface SourceMicrosoftEntraIdResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMicrosoftEntraIdResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftEntraIdResourceAllocationJobSpecific>[]>;
}

export interface SourceMicrosoftEntraIdResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftEntraIdResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMicrosoftEntraIdResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMicrosoftEntraIdResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftListsConfiguration {
    applicationIdUri: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    domain: pulumi.Input<string>;
    siteId: pulumi.Input<string>;
    tenantId: pulumi.Input<string>;
}

export interface SourceMicrosoftListsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMicrosoftListsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftListsResourceAllocationJobSpecific>[]>;
}

export interface SourceMicrosoftListsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftListsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMicrosoftListsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMicrosoftListsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftOnedriveConfiguration {
    /**
     * Credentials for connecting to the One Drive API
     */
    credentials: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationCredentials>;
    /**
     * Name of the Microsoft OneDrive drive where the file(s) exist. Default: "OneDrive"
     */
    driveName?: pulumi.Input<string>;
    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
     */
    folderPath?: pulumi.Input<string>;
    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' to search in the selected OneDrive drive, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. Default: "ALL"; must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]
     */
    searchScope?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStream>[]>;
}

export interface SourceMicrosoftOnedriveConfigurationCredentials {
    /**
     * OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
     * This class uses pydantic for data validation and settings management.
     */
    authenticateViaMicrosoftOAuth?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth>;
    /**
     * ServiceCredentials class for service key authentication.
     * This class is structured similarly to OAuthCredentials but for a different authentication method.
     */
    serviceKeyAuthentication?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication>;
}

export interface SourceMicrosoftOnedriveConfigurationCredentialsAuthenticateViaMicrosoftOAuth {
    /**
     * Client ID of your Microsoft developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token of your Microsoft developer application
     */
    refreshToken: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft OneDrive user
     */
    tenantId: pulumi.Input<string>;
}

export interface SourceMicrosoftOnedriveConfigurationCredentialsServiceKeyAuthentication {
    /**
     * Client ID of your Microsoft developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft OneDrive user
     */
    tenantId: pulumi.Input<string>;
    /**
     * Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
     */
    userPrincipalName: pulumi.Input<string>;
}

export interface SourceMicrosoftOnedriveConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatJsonlFormat {
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceMicrosoftOnedriveConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
}

export interface SourceMicrosoftOnedriveConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceMicrosoftOnedriveResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMicrosoftOnedriveResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftOnedriveResourceAllocationJobSpecific>[]>;
}

export interface SourceMicrosoftOnedriveResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftOnedriveResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMicrosoftOnedriveResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMicrosoftOnedriveResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftSharepointConfiguration {
    /**
     * Credentials for connecting to the One Drive API
     */
    credentials: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationCredentials>;
    deliveryMethod?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationDeliveryMethod>;
    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
     */
    folderPath?: pulumi.Input<string>;
    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' for all SharePoint drives the user can access, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. Default: "ALL"; must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]
     */
    searchScope?: pulumi.Input<string>;
    /**
     * Url of SharePoint site to search for files. Leave empty to search in the main site. Use 'https://<tenant_name>.sharepoint.com/sites/' to iterate over all sites. Default: ""
     */
    siteUrl?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStream>[]>;
}

export interface SourceMicrosoftSharepointConfigurationCredentials {
    /**
     * OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
     * This class uses pydantic for data validation and settings management.
     */
    authenticateViaMicrosoftOAuth?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth>;
    /**
     * ServiceCredentials class for service key authentication.
     * This class is structured similarly to OAuthCredentials but for a different authentication method.
     */
    serviceKeyAuthentication?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication>;
}

export interface SourceMicrosoftSharepointConfigurationCredentialsAuthenticateViaMicrosoftOAuth {
    /**
     * Client ID of your Microsoft developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token of your Microsoft developer application
     */
    refreshToken?: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft SharePoint user
     */
    tenantId: pulumi.Input<string>;
}

export interface SourceMicrosoftSharepointConfigurationCredentialsServiceKeyAuthentication {
    /**
     * Client ID of your Microsoft developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft SharePoint user
     */
    tenantId: pulumi.Input<string>;
    /**
     * Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
     */
    userPrincipalName: pulumi.Input<string>;
}

export interface SourceMicrosoftSharepointConfigurationDeliveryMethod {
    /**
     * Copy raw files without parsing their contents. Bits are copied into the destination exactly as they appeared in the source. Recommended for use with unstructured text data, non-text and compressed files.
     */
    copyRawFiles?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationDeliveryMethodCopyRawFiles>;
    /**
     * Recommended - Extract and load structured records into your destination of choice. This is the classic method of moving data in Airbyte. It allows for blocking and hashing individual fields or files from a structured schema. Data can be flattened, typed and deduped depending on the destination.
     */
    replicateRecords?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationDeliveryMethodReplicateRecords>;
}

export interface SourceMicrosoftSharepointConfigurationDeliveryMethodCopyRawFiles {
    /**
     * If enabled, sends subdirectory folder structure along with source file names to the destination. Otherwise, files will be synced by their names only. This option is ignored when file-based replication is not enabled. Default: true
     */
    preserveDirectoryStructure?: pulumi.Input<boolean>;
}

export interface SourceMicrosoftSharepointConfigurationDeliveryMethodReplicateRecords {
}

export interface SourceMicrosoftSharepointConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * The number of resent files which will be used to discover the schema for this stream.
     */
    recentNFilesToReadForSchemaDiscovery?: pulumi.Input<number>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat>;
    excelFormat?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatExcelFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatExcelFormat {
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatJsonlFormat {
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceMicrosoftSharepointConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
}

export interface SourceMicrosoftSharepointConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceMicrosoftSharepointResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMicrosoftSharepointResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftSharepointResourceAllocationJobSpecific>[]>;
}

export interface SourceMicrosoftSharepointResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftSharepointResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMicrosoftSharepointResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMicrosoftSharepointResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftTeamsConfiguration {
    /**
     * Choose how to authenticate to Microsoft
     */
    credentials?: pulumi.Input<inputs.SourceMicrosoftTeamsConfigurationCredentials>;
    /**
     * Specifies the length of time over which the Team Device Report stream is aggregated. The supported values are: D7, D30, D90, and D180.
     */
    period: pulumi.Input<string>;
}

export interface SourceMicrosoftTeamsConfigurationCredentials {
    authenticateViaMicrosoft?: pulumi.Input<inputs.SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft>;
    authenticateViaMicrosoftOAuth20?: pulumi.Input<inputs.SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20>;
}

export interface SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoft {
    /**
     * The Client ID of your Microsoft Teams developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Microsoft Teams developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the â€¦ next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
     */
    tenantId: pulumi.Input<string>;
}

export interface SourceMicrosoftTeamsConfigurationCredentialsAuthenticateViaMicrosoftOAuth20 {
    /**
     * The Client ID of your Microsoft Teams developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Microsoft Teams developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * A Refresh Token to renew the expired Access Token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * A globally unique identifier (GUID) that is different than your organization name or domain. Follow these steps to obtain: open one of the Teams where you belong inside the Teams Application > Click on the â€¦ next to the Team title > Click on Get link to team > Copy the link to the team and grab the tenant ID form the URL
     */
    tenantId: pulumi.Input<string>;
}

export interface SourceMicrosoftTeamsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMicrosoftTeamsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMicrosoftTeamsResourceAllocationJobSpecific>[]>;
}

export interface SourceMicrosoftTeamsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMicrosoftTeamsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMicrosoftTeamsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMicrosoftTeamsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMiroConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceMiroResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMiroResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMiroResourceAllocationJobSpecific>[]>;
}

export interface SourceMiroResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMiroResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMiroResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMiroResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMissiveConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Kind parameter for `contact_groups` stream. Default: "group"; must be one of ["group", "organization"]
     */
    kind?: pulumi.Input<string>;
    /**
     * Max records per page limit. Default: "50"
     */
    limit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceMissiveResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMissiveResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMissiveResourceAllocationJobSpecific>[]>;
}

export interface SourceMissiveResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMissiveResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMissiveResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMissiveResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMixmaxConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceMixmaxResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMixmaxResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMixmaxResourceAllocationJobSpecific>[]>;
}

export interface SourceMixmaxResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMixmaxResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMixmaxResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMixmaxResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMixpanelConfiguration {
    /**
     * A period of time for attributing results to ads and the lookback period after those actions occur during which ad results are counted. Default attribution window is 5 days. (This value should be non-negative integer). Default: 5
     */
    attributionWindow?: pulumi.Input<number>;
    /**
     * Choose how to authenticate to Mixpanel
     */
    credentials: pulumi.Input<inputs.SourceMixpanelConfigurationCredentials>;
    /**
     * Defines window size in days, that used to slice through data. You can reduce it, if amount of data in each window is too big for your environment. (This value should be positive integer). Default: 30
     */
    dateWindowSize?: pulumi.Input<number>;
    /**
     * The date in the format YYYY-MM-DD. Any data after this date will not be replicated. Left empty to always sync to most recent date
     */
    endDate?: pulumi.Input<string>;
    /**
     * The number of seconds to look back from the last synced timestamp during incremental syncs of the Export stream. This ensures no data is missed due to delays in event recording. Default is 0 seconds. Must be a non-negative integer. Default: 0
     */
    exportLookbackWindow?: pulumi.Input<number>;
    /**
     * The number of records to fetch per request for the engage stream. Default is 1000. If you are experiencing long sync times with this stream, try increasing this value. Default: 1000
     */
    pageSize?: pulumi.Input<number>;
    /**
     * Time zone in which integer date times are stored. The project timezone may be found in the project settings in the <a href="https://help.mixpanel.com/hc/en-us/articles/115004547203-Manage-Timezones-for-Projects-in-Mixpanel">Mixpanel console</a>. Default: "US/Pacific"
     */
    projectTimezone?: pulumi.Input<string>;
    /**
     * The region of mixpanel domain instance either US or EU. Default: "US"; must be one of ["US", "EU"]
     */
    region?: pulumi.Input<string>;
    /**
     * Setting this config parameter to TRUE ensures that new properties on events and engage records are captured. Otherwise new properties will be ignored. Default: true
     */
    selectPropertiesByDefault?: pulumi.Input<boolean>;
    /**
     * The date in the format YYYY-MM-DD. Any data before this date will not be replicated. If this option is not set, the connector will replicate data from up to one year ago by default.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceMixpanelConfigurationCredentials {
    projectSecret?: pulumi.Input<inputs.SourceMixpanelConfigurationCredentialsProjectSecret>;
    serviceAccount?: pulumi.Input<inputs.SourceMixpanelConfigurationCredentialsServiceAccount>;
}

export interface SourceMixpanelConfigurationCredentialsProjectSecret {
    /**
     * Mixpanel project secret. See the <a href="https://developer.mixpanel.com/reference/project-secret#managing-a-projects-secret">docs</a> for more information on how to obtain this.
     */
    apiSecret: pulumi.Input<string>;
}

export interface SourceMixpanelConfigurationCredentialsServiceAccount {
    /**
     * Your project ID number. See the <a href="https://help.mixpanel.com/hc/en-us/articles/115004490503-Project-Settings#project-id">docs</a> for more information on how to obtain this.
     */
    projectId: pulumi.Input<number>;
    /**
     * Mixpanel Service Account Secret. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
     */
    secret: pulumi.Input<string>;
    /**
     * Mixpanel Service Account Username. See the <a href="https://developer.mixpanel.com/reference/service-accounts">docs</a> for more information on how to obtain this.
     */
    username: pulumi.Input<string>;
}

export interface SourceMixpanelResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMixpanelResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMixpanelResourceAllocationJobSpecific>[]>;
}

export interface SourceMixpanelResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMixpanelResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMixpanelResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMixpanelResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceModeConfiguration {
    /**
     * API secret to use as the password for Basic Authentication.
     */
    apiSecret: pulumi.Input<string>;
    /**
     * API token to use as the username for Basic Authentication.
     */
    apiToken: pulumi.Input<string>;
    workspace: pulumi.Input<string>;
}

export interface SourceModeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceModeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceModeResourceAllocationJobSpecific>[]>;
}

export interface SourceModeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceModeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceModeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceModeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMondayConfiguration {
    /**
     * The IDs of the boards that the Items and Boards streams will extract records from. When left empty, streams will extract records from all boards that exist within the account.
     */
    boardIds?: pulumi.Input<pulumi.Input<number>[]>;
    credentials?: pulumi.Input<inputs.SourceMondayConfigurationCredentials>;
    /**
     * The number of worker threads to use for the sync. Default: 4
     */
    numWorkers?: pulumi.Input<number>;
}

export interface SourceMondayConfigurationCredentials {
    apiToken?: pulumi.Input<inputs.SourceMondayConfigurationCredentialsApiToken>;
    oAuth20?: pulumi.Input<inputs.SourceMondayConfigurationCredentialsOAuth20>;
}

export interface SourceMondayConfigurationCredentialsApiToken {
    /**
     * API Token for making authenticated requests.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceMondayConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of your OAuth application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your OAuth application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Slug/subdomain of the account, or the first part of the URL that comes before .monday.com. Default: ""
     */
    subdomain?: pulumi.Input<string>;
}

export interface SourceMondayResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMondayResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMondayResourceAllocationJobSpecific>[]>;
}

export interface SourceMondayResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMondayResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMondayResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMondayResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMongodbV2Configuration {
    /**
     * Configures the MongoDB cluster type.
     */
    databaseConfig: pulumi.Input<inputs.SourceMongodbV2ConfigurationDatabaseConfig>;
    /**
     * The maximum number of documents to sample when attempting to discover the unique fields for a collection. Default: 10000
     */
    discoverSampleSize?: pulumi.Input<number>;
    /**
     * The amount of time the connector will wait when it discovers a document. Defaults to 600 seconds. Valid range: 5 seconds to 1200 seconds. Default: 600
     */
    discoverTimeoutSeconds?: pulumi.Input<number>;
    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs. Default: 8
     */
    initialLoadTimeoutHours?: pulumi.Input<number>;
    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 1200 seconds. Default: 300
     */
    initialWaitingSeconds?: pulumi.Input<number>;
    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. Default: "Fail sync"; must be one of ["Fail sync", "Re-sync data"]
     */
    invalidCdcCursorPositionBehavior?: pulumi.Input<string>;
    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
     */
    queueSize?: pulumi.Input<number>;
    /**
     * Determines how Airbyte looks up the value of an updated document. If 'Lookup' is chosen, the current value of the document will be read. If 'Post Image' is chosen, then the version of the document immediately after an update will be read. WARNING : Severe data loss will occur if this option is chosen and the appropriate settings are not set on your Mongo instance : https://www.mongodb.com/docs/manual/changeStreams/#change-streams-with-document-pre-and-post-images. Default: "Lookup"; must be one of ["Lookup", "Post Image"]
     */
    updateCaptureMode?: pulumi.Input<string>;
}

export interface SourceMongodbV2ConfigurationDatabaseConfig {
    /**
     * MongoDB Atlas-hosted cluster configured as a replica set
     */
    mongoDbAtlasReplicaSet?: pulumi.Input<inputs.SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet>;
    /**
     * MongoDB self-hosted cluster configured as a replica set
     */
    selfManagedReplicaSet?: pulumi.Input<inputs.SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet>;
}

export interface SourceMongodbV2ConfigurationDatabaseConfigMongoDbAtlasReplicaSet {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The authentication source where the user information is stored.  See https://www.mongodb.com/docs/manual/reference/connection-string/#mongodb-urioption-urioption.authSource for more details. Default: "admin"
     */
    authSource?: pulumi.Input<string>;
    /**
     * The connection string of the cluster that you want to replicate.
     */
    connectionString: pulumi.Input<string>;
    /**
     * The name of the MongoDB database that contains the collection(s) to replicate.
     */
    database: pulumi.Input<string>;
    /**
     * The password associated with this username.
     */
    password: pulumi.Input<string>;
    /**
     * When enabled, syncs will validate and structure records against the stream's schema. Default: true
     */
    schemaEnforced?: pulumi.Input<boolean>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceMongodbV2ConfigurationDatabaseConfigSelfManagedReplicaSet {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The authentication source where the user information is stored. Default: "admin"
     */
    authSource?: pulumi.Input<string>;
    /**
     * The connection string of the cluster that you want to replicate.  https://www.mongodb.com/docs/manual/reference/connection-string/#find-your-self-hosted-deployment-s-connection-string for more information.
     */
    connectionString: pulumi.Input<string>;
    /**
     * The name of the MongoDB database that contains the collection(s) to replicate.
     */
    database: pulumi.Input<string>;
    /**
     * The password associated with this username.
     */
    password?: pulumi.Input<string>;
    /**
     * When enabled, syncs will validate and structure records against the stream's schema. Default: true
     */
    schemaEnforced?: pulumi.Input<boolean>;
    /**
     * The username which is used to access the database.
     */
    username?: pulumi.Input<string>;
}

export interface SourceMongodbV2ResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMongodbV2ResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMongodbV2ResourceAllocationJobSpecific>[]>;
}

export interface SourceMongodbV2ResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMongodbV2ResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMongodbV2ResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMongodbV2ResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMssqlConfiguration {
    /**
     * The name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * The hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * The port of the database.
     */
    port: pulumi.Input<number>;
    /**
     * Configures how data is extracted from the database.
     */
    replicationMethod?: pulumi.Input<inputs.SourceMssqlConfigurationReplicationMethod>;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The encryption method which is used when communicating with the database.
     */
    sslMethod?: pulumi.Input<inputs.SourceMssqlConfigurationSslMethod>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.SourceMssqlConfigurationTunnelMethod>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceMssqlConfigurationReplicationMethod {
    /**
     * <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the SQL Server's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc">change data capture feature</a>. This must be enabled on your database.
     */
    readChangesUsingChangeDataCaptureCdc?: pulumi.Input<inputs.SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc>;
    /**
     * Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
     */
    scanChangesWithUserDefinedCursor?: pulumi.Input<inputs.SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor>;
}

export interface SourceMssqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc {
    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs. Default: 8
     */
    initialLoadTimeoutHours?: pulumi.Input<number>;
    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 300 seconds. Valid range: 120 seconds to 3600 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/mysql/#change-data-capture-cdc">initial waiting time</a>. Default: 300
     */
    initialWaitingSeconds?: pulumi.Input<number>;
    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. Default: "Fail sync"; must be one of ["Fail sync", "Re-sync data"]
     */
    invalidCdcCursorPositionBehavior?: pulumi.Input<string>;
    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
     */
    queueSize?: pulumi.Input<number>;
}

export interface SourceMssqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor {
}

export interface SourceMssqlConfigurationSslMethod {
    /**
     * Use the certificate provided by the server without verification. (For testing purposes only!)
     */
    encryptedTrustServerCertificate?: pulumi.Input<inputs.SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificate>;
    /**
     * Verify and use the certificate provided by the server.
     */
    encryptedVerifyCertificate?: pulumi.Input<inputs.SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate>;
    /**
     * Data transfer will not be encrypted.
     */
    unencrypted?: pulumi.Input<inputs.SourceMssqlConfigurationSslMethodUnencrypted>;
}

export interface SourceMssqlConfigurationSslMethodEncryptedTrustServerCertificate {
}

export interface SourceMssqlConfigurationSslMethodEncryptedVerifyCertificate {
    /**
     * certificate of the server, or of the CA that signed the server certificate
     */
    certificate?: pulumi.Input<string>;
    /**
     * Specifies the host name of the server. The value of this property must match the subject property of the certificate.
     */
    hostNameInCertificate?: pulumi.Input<string>;
}

export interface SourceMssqlConfigurationSslMethodUnencrypted {
}

export interface SourceMssqlConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.SourceMssqlConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.SourceMssqlConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.SourceMssqlConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourceMssqlConfigurationTunnelMethodNoTunnel {
}

export interface SourceMssqlConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourceMssqlConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourceMssqlResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMssqlResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMssqlResourceAllocationJobSpecific>[]>;
}

export interface SourceMssqlResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMssqlResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMssqlResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMssqlResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMuxConfiguration {
    password?: pulumi.Input<string>;
    /**
     * The playback id for your video asset shown in website details
     */
    playbackId?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceMuxResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMuxResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMuxResourceAllocationJobSpecific>[]>;
}

export interface SourceMuxResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMuxResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMuxResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMuxResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMyHoursConfiguration {
    /**
     * Your My Hours username
     */
    email: pulumi.Input<string>;
    /**
     * Pagination size used for retrieving logs in days. Default: 30
     */
    logsBatchSize?: pulumi.Input<number>;
    /**
     * The password associated to the username
     */
    password: pulumi.Input<string>;
    /**
     * Start date for collecting time logs
     */
    startDate: pulumi.Input<string>;
}

export interface SourceMyHoursResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMyHoursResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMyHoursResourceAllocationJobSpecific>[]>;
}

export interface SourceMyHoursResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMyHoursResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMyHoursResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMyHoursResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMysqlConfiguration {
    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature. Default: true
     */
    checkPrivileges?: pulumi.Input<boolean>;
    /**
     * How often (in seconds) a stream should checkpoint, when possible. Default: 300
     */
    checkpointTargetIntervalSeconds?: pulumi.Input<number>;
    /**
     * Maximum number of concurrent queries to the database. Default: 1
     */
    concurrency?: pulumi.Input<number>;
    /**
     * The database name.
     */
    database: pulumi.Input<string>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database. Default: 3306
     */
    port?: pulumi.Input<number>;
    /**
     * Configures how data is extracted from the database.
     */
    replicationMethod: pulumi.Input<inputs.SourceMysqlConfigurationReplicationMethod>;
    /**
     * The encryption method which is used when communicating with the database.
     */
    sslMode?: pulumi.Input<inputs.SourceMysqlConfigurationSslMode>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.SourceMysqlConfigurationTunnelMethod>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationReplicationMethod {
    /**
     * <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using MySQL's <a href="https://docs.airbyte.com/integrations/sources/mssql/#change-data-capture-cdc"> change data capture feature</a>. This must be enabled on your database.
     */
    readChangesUsingChangeDataCaptureCdc?: pulumi.Input<inputs.SourceMysqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc>;
    /**
     * Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
     */
    scanChangesWithUserDefinedCursor?: pulumi.Input<inputs.SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor>;
}

export interface SourceMysqlConfigurationReplicationMethodReadChangesUsingChangeDataCaptureCdc {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs. Default: 8
     */
    initialLoadTimeoutHours?: pulumi.Input<number>;
    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. Default: "Fail sync"; must be one of ["Fail sync", "Re-sync data"]
     */
    invalidCdcCursorPositionBehavior?: pulumi.Input<string>;
    /**
     * Default: "CDC"; must be "CDC"
     */
    method?: pulumi.Input<string>;
    /**
     * Enter the configured MySQL server timezone. This should only be done if the configured timezone in your MySQL instance does not conform to IANNA standard.
     */
    serverTimezone?: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationReplicationMethodScanChangesWithUserDefinedCursor {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "STANDARD"; must be "STANDARD"
     */
    method?: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationSslMode {
    /**
     * To allow unencrypted communication only when the source doesn't support encryption.
     */
    preferred?: pulumi.Input<inputs.SourceMysqlConfigurationSslModePreferred>;
    /**
     * To always require encryption. Note: The connection will fail if the source doesn't support encryption.
     */
    required?: pulumi.Input<inputs.SourceMysqlConfigurationSslModeRequired>;
    /**
     * To always require encryption and verify that the source has a valid SSL certificate.
     */
    verifyCa?: pulumi.Input<inputs.SourceMysqlConfigurationSslModeVerifyCa>;
    /**
     * To always require encryption and verify that the source has a valid SSL certificate.
     */
    verifyIdentity?: pulumi.Input<inputs.SourceMysqlConfigurationSslModeVerifyIdentity>;
}

export interface SourceMysqlConfigurationSslModePreferred {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "preferred"; must be "preferred"
     */
    mode?: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationSslModeRequired {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "required"; must be "required"
     */
    mode?: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationSslModeVerifyCa {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
     */
    clientCertificate?: pulumi.Input<string>;
    /**
     * Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
     */
    clientKey?: pulumi.Input<string>;
    /**
     * Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
    /**
     * Default: "verify_ca"; must be "verify_ca"
     */
    mode?: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationSslModeVerifyIdentity {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Client certificate (this is not a required field, but if you want to use it, you will need to add the Client key as well)
     */
    clientCertificate?: pulumi.Input<string>;
    /**
     * Client key (this is not a required field, but if you want to use it, you will need to add the Client certificate as well)
     */
    clientKey?: pulumi.Input<string>;
    /**
     * Password for keystorage. This field is optional. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
    /**
     * Default: "verify_identity"; must be "verify_identity"
     */
    mode?: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationTunnelMethod {
    /**
     * No ssh tunnel needed to connect to database
     */
    noTunnel?: pulumi.Input<inputs.SourceMysqlConfigurationTunnelMethodNoTunnel>;
    /**
     * Connect through a jump server tunnel host using username and password authentication
     */
    passwordAuthentication?: pulumi.Input<inputs.SourceMysqlConfigurationTunnelMethodPasswordAuthentication>;
    /**
     * Connect through a jump server tunnel host using username and ssh key
     */
    sshKeyAuthentication?: pulumi.Input<inputs.SourceMysqlConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourceMysqlConfigurationTunnelMethodNoTunnel {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "NO_TUNNEL"; must be "NO_TUNNEL"
     */
    tunnelMethod?: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_PASSWORD_AUTH"; must be "SSH_PASSWORD_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourceMysqlConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_KEY_AUTH"; must be "SSH_KEY_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourceMysqlResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceMysqlResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceMysqlResourceAllocationJobSpecific>[]>;
}

export interface SourceMysqlResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceMysqlResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceMysqlResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceMysqlResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceN8nConfiguration {
    /**
     * Your API KEY. See <a href="https://docs.n8n.io/api/authentication">here</a>
     */
    apiKey: pulumi.Input<string>;
    /**
     * Hostname of the n8n instance
     */
    host: pulumi.Input<string>;
}

export interface SourceN8nResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceN8nResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceN8nResourceAllocationJobSpecific>[]>;
}

export interface SourceN8nResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceN8nResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceN8nResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceN8nResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNasaConfiguration {
    /**
     * API access key used to retrieve data from the NASA APOD API.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Indicates whether concept tags should be returned with the rest of the response.  The concept tags are not necessarily included in the explanation, but rather derived from common search tags that are associated with the description text. (Better than just pure text search.) Defaults to False. Default: false
     */
    conceptTags?: pulumi.Input<boolean>;
    /**
     * A positive integer, no greater than 100. If this is specified then `count` randomly  chosen images will be returned in a JSON array. Cannot be used in conjunction with  `date` or `start_date` and `end_date`.
     */
    count?: pulumi.Input<number>;
    /**
     * Indicates that end of a date range. If `start_date` is specified without an `end_date` then `end_date` defaults to the current date.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Indicates the start of a date range. All images in the range from `start_date` to  `end_date` will be returned in a JSON array. Must be after 1995-06-16, the first day an APOD picture was posted. There are no images for tomorrow available through this API.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Indicates whether the API should return a thumbnail image URL for video files. If set to True, the API returns URL of video thumbnail. If an APOD is not a video, this parameter is ignored. Default: false
     */
    thumbs?: pulumi.Input<boolean>;
}

export interface SourceNasaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNasaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNasaResourceAllocationJobSpecific>[]>;
}

export interface SourceNasaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNasaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNasaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNasaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNavanConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceNavanResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNavanResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNavanResourceAllocationJobSpecific>[]>;
}

export interface SourceNavanResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNavanResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNavanResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNavanResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNebiusAiConfiguration {
    /**
     * API key or access token
     */
    apiKey: pulumi.Input<string>;
    /**
     * Limit for each response objects. Default: "20"
     */
    limit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceNebiusAiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNebiusAiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNebiusAiResourceAllocationJobSpecific>[]>;
}

export interface SourceNebiusAiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNebiusAiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNebiusAiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNebiusAiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNetsuiteConfiguration {
    /**
     * Consumer key associated with your integration
     */
    consumerKey: pulumi.Input<string>;
    /**
     * Consumer secret associated with your integration
     */
    consumerSecret: pulumi.Input<string>;
    /**
     * The API names of the Netsuite objects you want to sync. Setting this speeds up the connection setup process by limiting the number of schemas that need to be retrieved from Netsuite.
     */
    objectTypes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Netsuite realm e.g. 2344535, as for `production` or 2344535_SB1, as for the `sandbox`
     */
    realm: pulumi.Input<string>;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DDTHH:mm:ssZ"
     */
    startDatetime: pulumi.Input<string>;
    /**
     * Access token key
     */
    tokenKey: pulumi.Input<string>;
    /**
     * Access token secret
     */
    tokenSecret: pulumi.Input<string>;
    /**
     * The amount of days used to query the data with date chunks. Set smaller value, if you have lots of data. Default: 30
     */
    windowInDays?: pulumi.Input<number>;
}

export interface SourceNetsuiteEnterpriseConfiguration {
    /**
     * The username which is used to access the database.
     */
    accountId: pulumi.Input<string>;
    /**
     * Configure how to authenticate to Netsuite. Options include username/password or token-based authentication.
     */
    authenticationMethod: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationAuthenticationMethod>;
    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature. Default: true
     */
    checkPrivileges?: pulumi.Input<boolean>;
    /**
     * How often (in seconds) a stream should checkpoint, when possible. Default: 300
     */
    checkpointTargetIntervalSeconds?: pulumi.Input<number>;
    /**
     * Maximum number of concurrent queries to the database. Default: 1
     */
    concurrency?: pulumi.Input<number>;
    /**
     * Configures how data is extracted from the database.
     */
    cursor: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationCursor>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Port of the database. Default: 1708
     */
    port?: pulumi.Input<number>;
    /**
     * The username which is used to access the database.
     */
    roleId: pulumi.Input<string>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationTunnelMethod>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseConfigurationAuthenticationMethod {
    /**
     * Authenticate using a password.
     */
    passwordAuthentication?: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationAuthenticationMethodPasswordAuthentication>;
    /**
     * Authenticate using a token-based authentication method. This requires a consumer key and secret, as well as a token ID and secret.
     */
    tokenBasedAuthentication?: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationAuthenticationMethodTokenBasedAuthentication>;
}

export interface SourceNetsuiteEnterpriseConfigurationAuthenticationMethodPasswordAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "password_authentication"; must be "password_authentication"
     */
    authenticationMethod?: pulumi.Input<string>;
    /**
     * The password associated with the username.
     */
    password: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseConfigurationAuthenticationMethodTokenBasedAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "token_based_authentication"; must be "token_based_authentication"
     */
    authenticationMethod?: pulumi.Input<string>;
    /**
     * The consumer key used for token-based authentication. This is generated in NetSuite when creating an integration record.
     */
    clientId: pulumi.Input<string>;
    /**
     * The consumer secret used for token-based authentication. This is generated in NetSuite when creating an integration record.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The token ID used for token-based authentication. This is generated in NetSuite when creating a token-based role.
     */
    tokenId: pulumi.Input<string>;
    /**
     * The token secret used for token-based authentication. This is generated in NetSuite when creating a token-based role.Ensure to keep this value secure.
     */
    tokenSecret: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseConfigurationCursor {
    /**
     * Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
     */
    scanChangesWithUserDefinedCursor?: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationCursorScanChangesWithUserDefinedCursor>;
}

export interface SourceNetsuiteEnterpriseConfigurationCursorScanChangesWithUserDefinedCursor {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "user_defined"; must be "user_defined"
     */
    cursorMethod?: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseConfigurationTunnelMethod {
    /**
     * No ssh tunnel needed to connect to database
     */
    noTunnel?: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationTunnelMethodNoTunnel>;
    /**
     * Connect through a jump server tunnel host using username and password authentication
     */
    passwordAuthentication?: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationTunnelMethodPasswordAuthentication>;
    /**
     * Connect through a jump server tunnel host using username and ssh key
     */
    sshKeyAuthentication?: pulumi.Input<inputs.SourceNetsuiteEnterpriseConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourceNetsuiteEnterpriseConfigurationTunnelMethodNoTunnel {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "NO_TUNNEL"; must be "NO_TUNNEL"
     */
    tunnelMethod?: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_PASSWORD_AUTH"; must be "SSH_PASSWORD_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_KEY_AUTH"; must be "SSH_KEY_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNetsuiteEnterpriseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNetsuiteEnterpriseResourceAllocationJobSpecific>[]>;
}

export interface SourceNetsuiteEnterpriseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNetsuiteEnterpriseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNetsuiteEnterpriseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNetsuiteEnterpriseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNetsuiteResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNetsuiteResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNetsuiteResourceAllocationJobSpecific>[]>;
}

export interface SourceNetsuiteResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNetsuiteResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNetsuiteResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNetsuiteResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNewsApiConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * The category you want to get top headlines for. Default: "business"; must be one of ["business", "entertainment", "general", "health", "science", "sports", "technology"]
     */
    category?: pulumi.Input<string>;
    /**
     * The 2-letter ISO 3166-1 code of the country you want to get headlines
     * for. You can't mix this with the sources parameter.
     * Default: "us"; must be one of ["ae", "ar", "at", "au", "be", "bg", "br", "ca", "ch", "cn", "co", "cu", "cz", "de", "eg", "fr", "gb", "gr", "hk", "hu", "id", "ie", "il", "in", "it", "jp", "kr", "lt", "lv", "ma", "mx", "my", "ng", "nl", "no", "nz", "ph", "pl", "pt", "ro", "rs", "ru", "sa", "se", "sg", "si", "sk", "th", "tr", "tw", "ua", "us", "ve", "za"]
     */
    country?: pulumi.Input<string>;
    /**
     * A comma-seperated string of domains (eg bbc.co.uk, techcrunch.com,
     * engadget.com) to restrict the search to.
     */
    domains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A date and optional time for the newest article allowed. This should
     * be in ISO 8601 format.
     */
    endDate?: pulumi.Input<string>;
    /**
     * A comma-seperated string of domains (eg bbc.co.uk, techcrunch.com,
     * engadget.com) to remove from the results.
     */
    excludeDomains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The 2-letter ISO-639-1 code of the language you want to get headlines
     * for. Possible options: ar de en es fr he it nl no pt ru se ud zh.
     * must be one of ["ar", "de", "en", "es", "fr", "he", "it", "nl", "no", "pt", "ru", "se", "ud", "zh"]
     */
    language?: pulumi.Input<string>;
    /**
     * Where to apply search query. Possible values are: title, description,
     * content.
     */
    searchIns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Search query. See https://newsapi.org/docs/endpoints/everything for 
     * information.
     */
    searchQuery?: pulumi.Input<string>;
    /**
     * The order to sort the articles in. Possible options: relevancy,
     * popularity, publishedAt.
     * Default: "publishedAt"; must be one of ["relevancy", "popularity", "publishedAt"]
     */
    sortBy?: pulumi.Input<string>;
    /**
     * Identifiers (maximum 20) for the news sources or blogs you want
     * headlines from. Use the `/sources` endpoint to locate these
     * programmatically or look at the sources index:
     * https://newsapi.com/sources. Will override both country and category.
     */
    sources?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A date and optional time for the oldest article allowed. This should
     * be in ISO 8601 format.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceNewsApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNewsApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNewsApiResourceAllocationJobSpecific>[]>;
}

export interface SourceNewsApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNewsApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNewsApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNewsApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNewsdataConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * Categories (maximum 5) to restrict the search to.
     */
    categories?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * 2-letter ISO 3166-1 countries (maximum 5) to restrict the search to.
     */
    countries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Domains (maximum 5) to restrict the search to. Use the sources stream to find top sources id.
     */
    domains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Languages (maximum 5) to restrict the search to.
     */
    languages?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Parsed as JSON.
     */
    oneOf?: pulumi.Input<string>;
}

export interface SourceNewsdataIoConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Search the news articles for a specific category. You can add up to 5 categories in a single query.
     */
    categories?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Search the news articles from a specific country. You can add up to 5 countries in a single query. Example: au, jp, br
     */
    countries?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Search the news articles for specific domains or news sources. You can add up to 5 domains in a single query.
     */
    domains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Choose an end date. Now UTC is default value
     */
    endDate?: pulumi.Input<string>;
    /**
     * Search the news articles for a specific language. You can add up to 5 languages in a single query.
     */
    languages?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Search news articles for specific keywords or phrases present in the news title, content, URL, meta keywords and meta description.
     */
    searchQuery?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceNewsdataIoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNewsdataIoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNewsdataIoResourceAllocationJobSpecific>[]>;
}

export interface SourceNewsdataIoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNewsdataIoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNewsdataIoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNewsdataIoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNewsdataResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNewsdataResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNewsdataResourceAllocationJobSpecific>[]>;
}

export interface SourceNewsdataResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNewsdataResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNewsdataResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNewsdataResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNexiopayConfiguration {
    /**
     * Your Nexio API key (password). You can find it in the Nexio Dashboard under Settings > User Management. Select the API user and copy the API key.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * The subdomain for the Nexio API environment, such as 'nexiopaysandbox' or 'nexiopay'. Default: "nexiopay"; must be one of ["nexiopaysandbox", "nexiopay"]
     */
    subdomain?: pulumi.Input<string>;
    /**
     * Your Nexio API username. You can find it in the Nexio Dashboard under Settings > User Management. Select the API user and copy the username.
     */
    username: pulumi.Input<string>;
}

export interface SourceNexiopayResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNexiopayResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNexiopayResourceAllocationJobSpecific>[]>;
}

export interface SourceNexiopayResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNexiopayResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNexiopayResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNexiopayResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNinjaoneRmmConfiguration {
    /**
     * Token could be generated natively by authorize section of NinjaOne swagger documentation `https://app.ninjarmm.com/apidocs/?links.active=authorization`
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceNinjaoneRmmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNinjaoneRmmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNinjaoneRmmResourceAllocationJobSpecific>[]>;
}

export interface SourceNinjaoneRmmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNinjaoneRmmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNinjaoneRmmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNinjaoneRmmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNocrmConfiguration {
    /**
     * API key to use. Generate it from the admin section of your noCRM.io account.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The subdomain specific to your noCRM.io account, e.g., 'yourcompany' in 'yourcompany.nocrm.io'.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceNocrmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNocrmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNocrmResourceAllocationJobSpecific>[]>;
}

export interface SourceNocrmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNocrmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNocrmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNocrmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNorthpassLmsConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceNorthpassLmsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNorthpassLmsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNorthpassLmsResourceAllocationJobSpecific>[]>;
}

export interface SourceNorthpassLmsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNorthpassLmsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNorthpassLmsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNorthpassLmsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNotionConfiguration {
    /**
     * Choose either OAuth (recommended for Airbyte Cloud) or Access Token. See our <a href='https://docs.airbyte.com/integrations/sources/notion#setup-guide'>docs</a> for more information.
     */
    credentials?: pulumi.Input<inputs.SourceNotionConfigurationCredentials>;
    /**
     * UTC date and time in the format YYYY-MM-DDTHH:MM:SS.000Z. During incremental sync, any data generated before this date will not be replicated. If left blank, the start date will be set to 2 years before the present date.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceNotionConfigurationCredentials {
    accessToken?: pulumi.Input<inputs.SourceNotionConfigurationCredentialsAccessToken>;
    oAuth20?: pulumi.Input<inputs.SourceNotionConfigurationCredentialsOAuth20>;
}

export interface SourceNotionConfigurationCredentialsAccessToken {
    /**
     * The Access Token for your private Notion integration. See the <a href='https://docs.airbyte.com/integrations/sources/notion#step-1-create-an-integration-in-notion'>docs</a> for more information on how to obtain this token.
     */
    token: pulumi.Input<string>;
}

export interface SourceNotionConfigurationCredentialsOAuth20 {
    /**
     * The Access Token received by completing the OAuth flow for your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Notion integration. See our <a href='https://docs.airbyte.com/integrations/sources/notion#step-2-set-permissions-and-acquire-authorization-credentials'>docs</a> for more information.
     */
    clientSecret: pulumi.Input<string>;
}

export interface SourceNotionResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNotionResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNotionResourceAllocationJobSpecific>[]>;
}

export interface SourceNotionResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNotionResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNotionResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNotionResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNutshellConfiguration {
    password?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceNutshellResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNutshellResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNutshellResourceAllocationJobSpecific>[]>;
}

export interface SourceNutshellResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNutshellResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNutshellResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNutshellResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNylasConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * must be one of ["us", "eu"]
     */
    apiServer: pulumi.Input<string>;
    endDate: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceNylasResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNylasResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNylasResourceAllocationJobSpecific>[]>;
}

export interface SourceNylasResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNylasResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNylasResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNylasResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNytimesConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * End date to stop the article retrieval (format YYYY-MM)
     */
    endDate?: pulumi.Input<string>;
    /**
     * Period of time (in days). must be one of ["1", "7", "30"]
     */
    period: pulumi.Input<number>;
    /**
     * Share Type. must be "facebook"
     */
    shareType?: pulumi.Input<string>;
    /**
     * Start date to begin the article retrieval (format YYYY-MM)
     */
    startDate: pulumi.Input<string>;
}

export interface SourceNytimesResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceNytimesResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceNytimesResourceAllocationJobSpecific>[]>;
}

export interface SourceNytimesResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceNytimesResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceNytimesResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceNytimesResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOktaConfiguration {
    credentials?: pulumi.Input<inputs.SourceOktaConfigurationCredentials>;
    /**
     * The Okta domain. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to find it.
     */
    domain?: pulumi.Input<string>;
    /**
     * UTC date and time in the format YYYY-MM-DDTHH:MM:SSZ. Any data before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceOktaConfigurationCredentials {
    apiToken?: pulumi.Input<inputs.SourceOktaConfigurationCredentialsApiToken>;
    oAuth20?: pulumi.Input<inputs.SourceOktaConfigurationCredentialsOAuth20>;
    oAuth20WithPrivateKey?: pulumi.Input<inputs.SourceOktaConfigurationCredentialsOAuth20WithPrivateKey>;
}

export interface SourceOktaConfigurationCredentialsApiToken {
    /**
     * An Okta token. See the <a href="https://docs.airbyte.com/integrations/sources/okta">docs</a> for instructions on how to generate it.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceOktaConfigurationCredentialsOAuth20 {
    /**
     * The Client ID of your OAuth application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your OAuth application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token to obtain new Access Token, when it's expired.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceOktaConfigurationCredentialsOAuth20WithPrivateKey {
    /**
     * The Client ID of your OAuth application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The key ID (kid).
     */
    keyId: pulumi.Input<string>;
    /**
     * The private key in PEM format
     */
    privateKey: pulumi.Input<string>;
    /**
     * The OAuth scope.
     */
    scope: pulumi.Input<string>;
}

export interface SourceOktaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOktaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOktaResourceAllocationJobSpecific>[]>;
}

export interface SourceOktaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOktaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOktaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOktaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOmnisendConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceOmnisendResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOmnisendResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOmnisendResourceAllocationJobSpecific>[]>;
}

export interface SourceOmnisendResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOmnisendResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOmnisendResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOmnisendResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOncehubConfiguration {
    /**
     * API key to use. Find it in your OnceHub account under the API & Webhooks Integration page.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceOncehubResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOncehubResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOncehubResourceAllocationJobSpecific>[]>;
}

export interface SourceOncehubResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOncehubResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOncehubResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOncehubResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOnepagecrmConfiguration {
    /**
     * Enter your API Key of your API app
     */
    password?: pulumi.Input<string>;
    /**
     * Enter the user ID of your API app
     */
    username: pulumi.Input<string>;
}

export interface SourceOnepagecrmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOnepagecrmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOnepagecrmResourceAllocationJobSpecific>[]>;
}

export interface SourceOnepagecrmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOnepagecrmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOnepagecrmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOnepagecrmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOnesignalConfiguration {
    /**
     * Applications keys, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys">docs</a> for more information on how to obtain this data
     */
    applications: pulumi.Input<pulumi.Input<inputs.SourceOnesignalConfigurationApplication>[]>;
    /**
     * Comma-separated list of names and the value (sum/count) for the returned outcome data. See the <a href="https://documentation.onesignal.com/reference/view-outcomes">docs</a> for more details
     */
    outcomeNames: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data for OneSignal API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: pulumi.Input<string>;
    /**
     * OneSignal User Auth Key, see the <a href="https://documentation.onesignal.com/docs/accounts-and-keys#user-auth-key">docs</a> for more information on how to obtain this key.
     */
    userAuthKey: pulumi.Input<string>;
}

export interface SourceOnesignalConfigurationApplication {
    appApiKey: pulumi.Input<string>;
    appId: pulumi.Input<string>;
    appName?: pulumi.Input<string>;
}

export interface SourceOnesignalResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOnesignalResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOnesignalResourceAllocationJobSpecific>[]>;
}

export interface SourceOnesignalResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOnesignalResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOnesignalResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOnesignalResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOnfleetConfiguration {
    /**
     * API key to use for authenticating requests. You can create and manage your API keys in the API section of the Onfleet dashboard.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Placeholder for basic HTTP auth password - should be set to empty string. Default: "x"
     */
    password?: pulumi.Input<string>;
}

export interface SourceOnfleetResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOnfleetResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOnfleetResourceAllocationJobSpecific>[]>;
}

export interface SourceOnfleetResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOnfleetResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOnfleetResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOnfleetResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenDataDcConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * address or place or block
     */
    location?: pulumi.Input<string>;
    /**
     * A unique identifier (Master Address Repository).
     */
    marid?: pulumi.Input<string>;
}

export interface SourceOpenDataDcResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOpenDataDcResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOpenDataDcResourceAllocationJobSpecific>[]>;
}

export interface SourceOpenDataDcResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenDataDcResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOpenDataDcResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOpenDataDcResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenaqConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * The list of IDs of countries (comma separated) you need the data for, check more: https://docs.openaq.org/resources/countries
     */
    countryIds: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceOpenaqResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOpenaqResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOpenaqResourceAllocationJobSpecific>[]>;
}

export interface SourceOpenaqResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenaqResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOpenaqResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOpenaqResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenfdaConfiguration {
}

export interface SourceOpenfdaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOpenfdaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOpenfdaResourceAllocationJobSpecific>[]>;
}

export interface SourceOpenfdaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenfdaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOpenfdaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOpenfdaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenweatherConfiguration {
    /**
     * API KEY
     */
    appid: pulumi.Input<string>;
    /**
     * You can use lang parameter to get the output in your language. The contents of the description field will be translated. See <a href="https://openweathermap.org/api/one-call-api#multi">here</a> for the list of supported languages. must be one of ["af", "al", "ar", "az", "bg", "ca", "cz", "da", "de", "el", "en", "eu", "fa", "fi", "fr", "gl", "he", "hi", "hr", "hu", "id", "it", "ja", "kr", "la", "lt", "mk", "no", "nl", "pl", "pt", "pt_br", "ro", "ru", "sv", "se", "sk", "sl", "sp", "es", "sr", "th", "tr", "ua", "uk", "vi", "zh_cn", "zh_tw", "zu"]
     */
    lang?: pulumi.Input<string>;
    /**
     * Latitude, decimal (-90; 90). If you need the geocoder to automatic convert city names and zip-codes to geo coordinates and the other way around, please use the OpenWeather Geocoding API
     */
    lat: pulumi.Input<string>;
    /**
     * Longitude, decimal (-180; 180). If you need the geocoder to automatic convert city names and zip-codes to geo coordinates and the other way around, please use the OpenWeather Geocoding API
     */
    lon: pulumi.Input<string>;
    /**
     * True for particular day
     */
    onlyCurrent?: pulumi.Input<boolean>;
    /**
     * Units of measurement. standard, metric and imperial units are available. If you do not use the units parameter, standard units will be applied by default. must be one of ["standard", "metric", "imperial"]
     */
    units?: pulumi.Input<string>;
}

export interface SourceOpenweatherResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOpenweatherResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOpenweatherResourceAllocationJobSpecific>[]>;
}

export interface SourceOpenweatherResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpenweatherResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOpenweatherResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOpenweatherResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpinionStageConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceOpinionStageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOpinionStageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOpinionStageResourceAllocationJobSpecific>[]>;
}

export interface SourceOpinionStageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpinionStageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOpinionStageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOpinionStageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpsgenieConfiguration {
    /**
     * API token used to access the Opsgenie platform
     */
    apiToken: pulumi.Input<string>;
    /**
     * Service endpoint to use for API calls. Default: "api.opsgenie.com"
     */
    endpoint?: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data from Opsgenie in the format of YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated. Note that it will be used only in the following incremental streams: issues.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceOpsgenieResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOpsgenieResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOpsgenieResourceAllocationJobSpecific>[]>;
}

export interface SourceOpsgenieResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpsgenieResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOpsgenieResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOpsgenieResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpuswatchConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Default: "20250101"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceOpuswatchResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOpuswatchResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOpuswatchResourceAllocationJobSpecific>[]>;
}

export interface SourceOpuswatchResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOpuswatchResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOpuswatchResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOpuswatchResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOracleConfiguration {
    /**
     * Connect data that will be used for DB connection
     */
    connectionData?: pulumi.Input<inputs.SourceOracleConfigurationConnectionData>;
    /**
     * The encryption method with is used when communicating with the database.
     */
    encryption?: pulumi.Input<inputs.SourceOracleConfigurationEncryption>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database.
     * Oracle Corporations recommends the following port numbers:
     * 1521 - Default listening port for client connections to the listener. 
     * 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL
     * Default: 1521
     */
    port?: pulumi.Input<number>;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.SourceOracleConfigurationTunnelMethod>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceOracleConfigurationConnectionData {
    /**
     * Use service name
     */
    serviceName?: pulumi.Input<inputs.SourceOracleConfigurationConnectionDataServiceName>;
    /**
     * Use SID (Oracle System Identifier)
     */
    systemIdsid?: pulumi.Input<inputs.SourceOracleConfigurationConnectionDataSystemIdsid>;
}

export interface SourceOracleConfigurationConnectionDataServiceName {
    serviceName: pulumi.Input<string>;
}

export interface SourceOracleConfigurationConnectionDataSystemIdsid {
    sid: pulumi.Input<string>;
}

export interface SourceOracleConfigurationEncryption {
    /**
     * The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
     */
    nativeNetworkEncryptionNne?: pulumi.Input<inputs.SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne>;
    /**
     * Verify and use the certificate provided by the server.
     */
    tlsEncryptedVerifyCertificate?: pulumi.Input<inputs.SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate>;
    /**
     * Data transfer will not be encrypted.
     */
    unencrypted?: pulumi.Input<inputs.SourceOracleConfigurationEncryptionUnencrypted>;
}

export interface SourceOracleConfigurationEncryptionNativeNetworkEncryptionNne {
    /**
     * This parameter defines what encryption algorithm is used. Default: "AES256"; must be one of ["AES256", "RC4_56", "3DES168"]
     */
    encryptionAlgorithm?: pulumi.Input<string>;
}

export interface SourceOracleConfigurationEncryptionTlsEncryptedVerifyCertificate {
    /**
     * Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
     */
    sslCertificate: pulumi.Input<string>;
}

export interface SourceOracleConfigurationEncryptionUnencrypted {
}

export interface SourceOracleConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.SourceOracleConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.SourceOracleConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.SourceOracleConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourceOracleConfigurationTunnelMethodNoTunnel {
}

export interface SourceOracleConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourceOracleConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfiguration {
    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature. Default: true
     */
    checkPrivileges?: pulumi.Input<boolean>;
    /**
     * How often (in seconds) a stream should checkpoint, when possible. Default: 300
     */
    checkpointTargetIntervalSeconds?: pulumi.Input<number>;
    /**
     * Maximum number of concurrent queries to the database. Default: 1
     */
    concurrency?: pulumi.Input<number>;
    /**
     * The scheme by which to establish a database connection.
     */
    connectionData: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationConnectionData>;
    /**
     * Configures how data is extracted from the database.
     */
    cursor: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationCursor>;
    /**
     * The encryption method with is used when communicating with the database.
     */
    encryption: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationEncryption>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database.
     * Oracle Corporations recommends the following port numbers:
     * 1521 - Default listening port for client connections to the listener. 
     * 2484 - Recommended and officially registered listening port for client connections to the listener using TCP/IP with SSL.
     * Default: 1521
     */
    port?: pulumi.Input<number>;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationTunnelMethod>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationConnectionData {
    /**
     * Use service name.
     */
    serviceName?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationConnectionDataServiceName>;
    /**
     * Use Oracle System Identifier.
     */
    systemIdsid?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationConnectionDataSystemIdsid>;
}

export interface SourceOracleEnterpriseConfigurationConnectionDataServiceName {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "service_name"; must be "service_name"
     */
    connectionType?: pulumi.Input<string>;
    serviceName: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationConnectionDataSystemIdsid {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "sid"; must be "sid"
     */
    connectionType?: pulumi.Input<string>;
    sid: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationCursor {
    /**
     * <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using Oracle's <a href="https://docs.airbyte.com/integrations/enterprise-connectors/source-oracle#getting-started"> change data capture feature</a>. This must be enabled on your database.
     */
    readChangesUsingChangeDataCaptureCdc?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationCursorReadChangesUsingChangeDataCaptureCdc>;
    /**
     * Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
     */
    scanChangesWithUserDefinedCursor?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationCursorScanChangesWithUserDefinedCursor>;
}

export interface SourceOracleEnterpriseConfigurationCursorReadChangesUsingChangeDataCaptureCdc {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "cdc"; must be "cdc"
     */
    cursorMethod?: pulumi.Input<string>;
    /**
     * The amount of time to allow the Debezium Engine to shut down, in seconds. Default: 60
     */
    debeziumShutdownTimeoutSeconds?: pulumi.Input<number>;
    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC events. Default: 8
     */
    initialLoadTimeoutHours?: pulumi.Input<number>;
    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. Default: "Fail sync"; must be one of ["Fail sync", "Re-sync data"]
     */
    invalidCdcCursorPositionBehavior?: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationCursorScanChangesWithUserDefinedCursor {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "user_defined"; must be "user_defined"
     */
    cursorMethod?: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationEncryption {
    /**
     * The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
     */
    nativeNetworkEncryptionNne?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationEncryptionNativeNetworkEncryptionNne>;
    /**
     * Verify and use the certificate provided by the server.
     */
    tlsEncryptedVerifyCertificate?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationEncryptionTlsEncryptedVerifyCertificate>;
    /**
     * Data transfer will not be encrypted.
     */
    unencrypted?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationEncryptionUnencrypted>;
}

export interface SourceOracleEnterpriseConfigurationEncryptionNativeNetworkEncryptionNne {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * This parameter defines what encryption algorithm is used. Default: "AES256"; must be one of ["AES256", "AES192", "AES128", "3DES168", "3DES112", "DES"]
     */
    encryptionAlgorithm?: pulumi.Input<string>;
    /**
     * Default: "client_nne"; must be "client_nne"
     */
    encryptionMethod?: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationEncryptionTlsEncryptedVerifyCertificate {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "encrypted_verify_certificate"; must be "encrypted_verify_certificate"
     */
    encryptionMethod?: pulumi.Input<string>;
    /**
     * Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
     */
    sslCertificate: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationEncryptionUnencrypted {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "unencrypted"; must be "unencrypted"
     */
    encryptionMethod?: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationTunnelMethod {
    /**
     * No ssh tunnel needed to connect to database
     */
    noTunnel?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationTunnelMethodNoTunnel>;
    /**
     * Connect through a jump server tunnel host using username and password authentication
     */
    passwordAuthentication?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationTunnelMethodPasswordAuthentication>;
    /**
     * Connect through a jump server tunnel host using username and ssh key
     */
    sshKeyAuthentication?: pulumi.Input<inputs.SourceOracleEnterpriseConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourceOracleEnterpriseConfigurationTunnelMethodNoTunnel {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "NO_TUNNEL"; must be "NO_TUNNEL"
     */
    tunnelMethod?: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_PASSWORD_AUTH"; must be "SSH_PASSWORD_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_KEY_AUTH"; must be "SSH_KEY_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOracleEnterpriseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOracleEnterpriseResourceAllocationJobSpecific>[]>;
}

export interface SourceOracleEnterpriseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOracleEnterpriseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOracleEnterpriseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOracleEnterpriseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOracleResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOracleResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOracleResourceAllocationJobSpecific>[]>;
}

export interface SourceOracleResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOracleResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOracleResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOracleResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOrbConfiguration {
    /**
     * Orb API Key, issued from the Orb admin console.
     */
    apiKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at after this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
     */
    endDate?: pulumi.Input<string>;
    /**
     * When set to N, the connector will always refresh resources created within the past N days. By default, updated objects that are not newly created are not incrementally synced. Default: 0
     */
    lookbackWindowDays?: pulumi.Input<number>;
    /**
     * Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
     */
    numericEventPropertiesKeys?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Orb Plan ID to filter subscriptions that should have usage fetched.
     */
    planId?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2022-03-01T00:00:00Z. Any data with created_at before this data will not be synced. For Subscription Usage, this becomes the `timeframe_start` API parameter.
     */
    startDate: pulumi.Input<string>;
    /**
     * Property key names to extract from all events, in order to enrich ledger entries corresponding to an event deduction.
     */
    stringEventPropertiesKeys?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Property key name to group subscription usage by.
     */
    subscriptionUsageGroupingKey?: pulumi.Input<string>;
}

export interface SourceOrbResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOrbResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOrbResourceAllocationJobSpecific>[]>;
}

export interface SourceOrbResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOrbResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOrbResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOrbResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOuraConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * End datetime to sync until. Default is current UTC datetime.
     */
    endDatetime?: pulumi.Input<string>;
    /**
     * Start datetime to sync from. Default is current UTC datetime minus 1
     * day.
     */
    startDatetime?: pulumi.Input<string>;
}

export interface SourceOuraResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOuraResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOuraResourceAllocationJobSpecific>[]>;
}

export interface SourceOuraResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOuraResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOuraResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOuraResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOutbrainAmplifyConfiguration {
    /**
     * The definition of conversion count in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>. must be one of ["click/view_time", "conversion_time"]
     */
    conversionCount?: pulumi.Input<string>;
    /**
     * Credentials for making authenticated requests requires either username/password or access_token.
     */
    credentials: pulumi.Input<inputs.SourceOutbrainAmplifyConfigurationCredentials>;
    /**
     * Date in the format YYYY-MM-DD.
     */
    endDate?: pulumi.Input<string>;
    /**
     * The granularity used for geo location data in reports. must be one of ["country", "region", "subregion"]
     */
    geoLocationBreakdown?: pulumi.Input<string>;
    /**
     * The granularity used for periodic data in reports. See <a href="https://amplifyv01.docs.apiary.io/#reference/performance-reporting/periodic/retrieve-performance-statistics-for-all-marketer-campaigns-by-periodic-breakdown">the docs</a>. must be one of ["daily", "weekly", "monthly"]
     */
    reportGranularity?: pulumi.Input<string>;
    /**
     * Date in the format YYYY-MM-DD eg. 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceOutbrainAmplifyConfigurationCredentials {
    accessToken?: pulumi.Input<inputs.SourceOutbrainAmplifyConfigurationCredentialsAccessToken>;
    usernamePassword?: pulumi.Input<inputs.SourceOutbrainAmplifyConfigurationCredentialsUsernamePassword>;
}

export interface SourceOutbrainAmplifyConfigurationCredentialsAccessToken {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceOutbrainAmplifyConfigurationCredentialsUsernamePassword {
    /**
     * Add Password for authentication.
     */
    password: pulumi.Input<string>;
    /**
     * Add Username for authentication.
     */
    username: pulumi.Input<string>;
}

export interface SourceOutbrainAmplifyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOutbrainAmplifyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOutbrainAmplifyResourceAllocationJobSpecific>[]>;
}

export interface SourceOutbrainAmplifyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOutbrainAmplifyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOutbrainAmplifyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOutbrainAmplifyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOutreachConfiguration {
    /**
     * The Client ID of your Outreach developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Outreach developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * A Redirect URI is the location where the authorization server sends the user once the app has been successfully authorized and granted an authorization code or access token.
     */
    redirectUri: pulumi.Input<string>;
    /**
     * The token for obtaining the new access token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data for Outreach API, in the format YYYY-MM-DDT00:00:00.000Z. All data generated after this date will be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceOutreachResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOutreachResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOutreachResourceAllocationJobSpecific>[]>;
}

export interface SourceOutreachResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOutreachResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOutreachResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOutreachResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOveitConfiguration {
    /**
     * Oveit's login Email
     */
    email: pulumi.Input<string>;
    /**
     * Oveit's login Password
     */
    password: pulumi.Input<string>;
}

export interface SourceOveitResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceOveitResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceOveitResourceAllocationJobSpecific>[]>;
}

export interface SourceOveitResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceOveitResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceOveitResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceOveitResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePabblySubscriptionsBillingConfiguration {
    password?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourcePabblySubscriptionsBillingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePabblySubscriptionsBillingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePabblySubscriptionsBillingResourceAllocationJobSpecific>[]>;
}

export interface SourcePabblySubscriptionsBillingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePabblySubscriptionsBillingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePabblySubscriptionsBillingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePabblySubscriptionsBillingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaddleConfiguration {
    /**
     * Your Paddle API key. You can generate it by navigating to Paddle > Developer tools > Authentication > Generate API key. Treat this key like a password and keep it secure.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The environment for the Paddle API, either 'sandbox' or 'live'. Default: "api"; must be one of ["api", "sandbox-api"]
     */
    environment?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourcePaddleResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePaddleResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePaddleResourceAllocationJobSpecific>[]>;
}

export interface SourcePaddleResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaddleResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePaddleResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePaddleResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePagerdutyConfiguration {
    /**
     * Fetch pipelines updated in the last number of days. Default: 90
     */
    cutoffDays?: pulumi.Input<number>;
    /**
     * A default severity category if not present
     */
    defaultSeverity?: pulumi.Input<string>;
    /**
     * List of PagerDuty service names to ignore incidents from. If not set, all incidents will be pulled.
     */
    excludeServices?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * If true, will return a subset of log entries that show only the most important changes to the incident. Default: true
     */
    incidentLogEntriesOverview?: pulumi.Input<boolean>;
    /**
     * Maximum number of PagerDuty API request retries to perform upon connection errors. The source will pause for an exponentially increasing number of seconds before retrying. Default: 5
     */
    maxRetries?: pulumi.Input<number>;
    /**
     * page size to use when querying PagerDuty API. Default: 25
     */
    pageSize?: pulumi.Input<number>;
    /**
     * List of PagerDuty service additional details to include.
     */
    serviceDetails?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * API key for PagerDuty API authentication
     */
    token: pulumi.Input<string>;
}

export interface SourcePagerdutyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePagerdutyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePagerdutyResourceAllocationJobSpecific>[]>;
}

export interface SourcePagerdutyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePagerdutyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePagerdutyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePagerdutyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePandadocConfiguration {
    /**
     * API key to use. Find it at https://app.pandadoc.com/a/#/settings/api-dashboard/configuration
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourcePandadocResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePandadocResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePandadocResourceAllocationJobSpecific>[]>;
}

export interface SourcePandadocResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePandadocResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePandadocResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePandadocResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaperformConfiguration {
    /**
     * API key to use. Generate it on your account page at https://paperform.co/account/developer.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourcePaperformResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePaperformResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePaperformResourceAllocationJobSpecific>[]>;
}

export interface SourcePaperformResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaperformResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePaperformResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePaperformResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePapersignConfiguration {
    /**
     * API key to use. Generate it on your account page at https://paperform.co/account/developer.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourcePapersignResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePapersignResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePapersignResourceAllocationJobSpecific>[]>;
}

export interface SourcePapersignResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePapersignResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePapersignResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePapersignResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePardotConfiguration {
    /**
     * The Consumer Key that can be found when viewing your app in Salesforce
     */
    clientId: pulumi.Input<string>;
    /**
     * The Consumer Secret that can be found when viewing your app in Salesforce
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Whether or not the the app is in a Salesforce sandbox. If you do not know what this, assume it is false. Default: false
     */
    isSandbox?: pulumi.Input<boolean>;
    /**
     * The maximum number of records to return per request. Default: "1000"
     */
    pageSize?: pulumi.Input<string>;
    /**
     * Pardot Business ID, can be found at Setup > Pardot > Pardot Account Setup
     */
    pardotBusinessUnitId: pulumi.Input<string>;
    /**
     * Salesforce Refresh Token used for Airbyte to access your Salesforce account. If you don't know what this is, follow this <a href="https://medium.com/@bpmmendis94/obtain-access-refresh-tokens-from-salesforce-rest-api-a324fe4ccd9b">guide</a> to retrieve it.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2000-01-01T00:00:00Z. Any data before this date will not be replicated. Defaults to the year Pardot was released. Default: "2007-01-01T00:00:00Z"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourcePardotResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePardotResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePardotResourceAllocationJobSpecific>[]>;
}

export interface SourcePardotResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePardotResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePardotResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePardotResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePartnerizeConfiguration {
    /**
     * The application key identifies the network you are making the request against. Find it in your account settings under 'User Application Key' at https://console.partnerize.com.
     */
    applicationKey: pulumi.Input<string>;
    /**
     * The user API key identifies the user on whose behalf the request is made. Find it in your account settings under 'User API Key' at https://console.partnerize.com.
     */
    userApiKey: pulumi.Input<string>;
}

export interface SourcePartnerizeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePartnerizeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePartnerizeResourceAllocationJobSpecific>[]>;
}

export interface SourcePartnerizeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePartnerizeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePartnerizeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePartnerizeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePartnerstackConfiguration {
    /**
     * The Live Private Key for a Partnerstack account.
     */
    privateKey: pulumi.Input<string>;
    /**
     * The Live Public Key for a Partnerstack account.
     */
    publicKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourcePartnerstackResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePartnerstackResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePartnerstackResourceAllocationJobSpecific>[]>;
}

export interface SourcePartnerstackResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePartnerstackResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePartnerstackResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePartnerstackResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePayfitConfiguration {
    apiKey: pulumi.Input<string>;
    companyId: pulumi.Input<string>;
}

export interface SourcePayfitResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePayfitResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePayfitResourceAllocationJobSpecific>[]>;
}

export interface SourcePayfitResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePayfitResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePayfitResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePayfitResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaypalTransactionConfiguration {
    /**
     * The Client ID of your Paypal developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Paypal developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Start Date parameter for the list dispute endpoint in <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\">ISO format</a>. This Start Date must be in range within 180 days before present time, and requires ONLY 3 miliseconds(mandatory). If you don't use this option, it defaults to a start date set 180 days in the past.
     */
    disputeStartDate?: pulumi.Input<string>;
    /**
     * End Date for data extraction in <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\">ISO format</a>. This can be help you select specific range of time, mainly for test purposes  or data integrity tests. When this is not used, now_utc() is used by the streams. This does not apply to Disputes and Product streams.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Determines whether to use the sandbox or production environment. Default: false
     */
    isSandbox?: pulumi.Input<boolean>;
    /**
     * The key to refresh the expired access token.
     */
    refreshToken?: pulumi.Input<string>;
    /**
     * Start Date for data extraction in <a href=\"https://datatracker.ietf.org/doc/html/rfc3339#section-5.6\">ISO format</a>. Date must be in range from 3 years till 12 hrs before present time.
     */
    startDate: pulumi.Input<string>;
    /**
     * The number of days per request. Must be a number between 1 and 31. Default: 7
     */
    timeWindow?: pulumi.Input<number>;
}

export interface SourcePaypalTransactionResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePaypalTransactionResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePaypalTransactionResourceAllocationJobSpecific>[]>;
}

export interface SourcePaypalTransactionResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaypalTransactionResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePaypalTransactionResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePaypalTransactionResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaystackConfiguration {
    /**
     * When set, the connector will always reload data from the past N days, where N is the value set here. This is useful if your data is updated after creation. Default: 0
     */
    lookbackWindowDays?: pulumi.Input<number>;
    /**
     * The Paystack API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.paystack.com/#/settings/developer">here</a>).
     */
    secretKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourcePaystackResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePaystackResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePaystackResourceAllocationJobSpecific>[]>;
}

export interface SourcePaystackResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePaystackResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePaystackResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePaystackResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePendoConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourcePendoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePendoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePendoResourceAllocationJobSpecific>[]>;
}

export interface SourcePendoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePendoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePendoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePendoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePennylaneConfiguration {
    apiKey: pulumi.Input<string>;
    startTime: pulumi.Input<string>;
}

export interface SourcePennylaneResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePennylaneResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePennylaneResourceAllocationJobSpecific>[]>;
}

export interface SourcePennylaneResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePennylaneResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePennylaneResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePennylaneResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePerigonConfiguration {
    /**
     * Your API key for authenticating with the Perigon API. Obtain it by creating an account at https://www.perigon.io/sign-up and verifying your email. The API key will be visible on your account dashboard.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourcePerigonResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePerigonResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePerigonResourceAllocationJobSpecific>[]>;
}

export interface SourcePerigonResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePerigonResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePerigonResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePerigonResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePersistiqConfiguration {
    /**
     * PersistIq API Key. See the <a href="https://apidocs.persistiq.com/#authentication">docs</a> for more information on where to find that key.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourcePersistiqResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePersistiqResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePersistiqResourceAllocationJobSpecific>[]>;
}

export interface SourcePersistiqResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePersistiqResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePersistiqResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePersistiqResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePersonaConfiguration {
    /**
     * API key or access token
     */
    apiKey: pulumi.Input<string>;
}

export interface SourcePersonaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePersonaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePersonaResourceAllocationJobSpecific>[]>;
}

export interface SourcePersonaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePersonaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePersonaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePersonaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePexelsApiConfiguration {
    /**
     * API key is required to access pexels api, For getting your's goto https://www.pexels.com/api/documentation and create account for free.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Optional, Desired photo color. Supported colors red, orange, yellow, green, turquoise, blue, violet, pink, brown, black, gray, white or any hexidecimal color code.
     */
    color?: pulumi.Input<string>;
    /**
     * Optional, The locale of the search you are performing. The current supported locales are 'en-US' 'pt-BR' 'es-ES' 'ca-ES' 'de-DE' 'it-IT' 'fr-FR' 'sv-SE' 'id-ID' 'pl-PL' 'ja-JP' 'zh-TW' 'zh-CN' 'ko-KR' 'th-TH' 'nl-NL' 'hu-HU' 'vi-VN' 'cs-CZ' 'da-DK' 'fi-FI' 'uk-UA' 'el-GR' 'ro-RO' 'nb-NO' 'sk-SK' 'tr-TR' 'ru-RU'.
     */
    locale?: pulumi.Input<string>;
    /**
     * Optional, Desired photo orientation. The current supported orientations are landscape, portrait or square
     */
    orientation?: pulumi.Input<string>;
    /**
     * Optional, the search query, Example Ocean, Tigers, Pears, etc.
     */
    query: pulumi.Input<string>;
    /**
     * Optional, Minimum photo size. The current supported sizes are large(24MP), medium(12MP) or small(4MP).
     */
    size?: pulumi.Input<string>;
}

export interface SourcePexelsApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePexelsApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePexelsApiResourceAllocationJobSpecific>[]>;
}

export interface SourcePexelsApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePexelsApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePexelsApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePexelsApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePhylloConfiguration {
    /**
     * Your Client ID for the Phyllo API. You can find this in the Phyllo Developer Dashboard under API credentials.
     */
    clientId: pulumi.Input<string>;
    /**
     * Your Client Secret for the Phyllo API. You can find this in the Phyllo Developer Dashboard under API credentials.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The environment for the API (e.g., 'api.sandbox', 'api.staging', 'api'). Default: "api"; must be one of ["api.sandbox", "api.staging", "api"]
     */
    environment?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourcePhylloResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePhylloResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePhylloResourceAllocationJobSpecific>[]>;
}

export interface SourcePhylloResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePhylloResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePhylloResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePhylloResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePicqerConfiguration {
    /**
     * The organization name which is used to login to picqer
     */
    organizationName: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourcePicqerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePicqerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePicqerResourceAllocationJobSpecific>[]>;
}

export interface SourcePicqerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePicqerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePicqerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePicqerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePingdomConfiguration {
    apiKey: pulumi.Input<string>;
    probes?: pulumi.Input<string>;
    /**
     * Default: "hour"; must be one of ["hour", "day", "week"]
     */
    resolution?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourcePingdomResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePingdomResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePingdomResourceAllocationJobSpecific>[]>;
}

export interface SourcePingdomResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePingdomResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePingdomResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePingdomResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePinterestConfiguration {
    /**
     * The Pinterest account ID you want to fetch data for. This ID must be provided to filter the data for a specific account.
     */
    accountId?: pulumi.Input<string>;
    credentials?: pulumi.Input<inputs.SourcePinterestConfigurationCredentials>;
    /**
     * A list which contains ad statistics entries, each entry must have a name and can contains fields, breakdowns or action_breakdowns. Click on "add" to fill this field.
     */
    customReports?: pulumi.Input<pulumi.Input<inputs.SourcePinterestConfigurationCustomReport>[]>;
    /**
     * A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by api (89 days from today).
     */
    startDate?: pulumi.Input<string>;
    /**
     * For the ads, ad_groups, and campaigns streams, specifying a status will filter out records that do not match the specified ones. If a status is not specified, the source will default to records with a status of either ACTIVE or PAUSED.
     */
    statuses?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourcePinterestConfigurationCredentials {
    /**
     * The Client ID of your OAuth application
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your OAuth application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token to obtain new Access Token, when it's expired.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourcePinterestConfigurationCustomReport {
    /**
     * List of types of attribution for the conversion report
     */
    attributionTypes?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Number of days to use as the conversion attribution window for a pin click action. Default: 30; must be one of ["0", "1", "7", "14", "30", "60"]
     */
    clickWindowDays?: pulumi.Input<number>;
    /**
     * A list of chosen columns
     */
    columns?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.. Default: "TIME_OF_AD_ACTION"; must be one of ["TIME_OF_AD_ACTION", "TIME_OF_CONVERSION"]
     */
    conversionReportTime?: pulumi.Input<string>;
    /**
     * Number of days to use as the conversion attribution window for an engagement action. must be one of ["0", "1", "7", "14", "30", "60"]
     */
    engagementWindowDays?: pulumi.Input<number>;
    /**
     * Chosen granularity for API. Default: "TOTAL"; must be one of ["TOTAL", "DAY", "HOUR", "WEEK", "MONTH"]
     */
    granularity?: pulumi.Input<string>;
    /**
     * Chosen level for API. Default: "ADVERTISER"; must be one of ["ADVERTISER", "ADVERTISER_TARGETING", "CAMPAIGN", "CAMPAIGN_TARGETING", "AD_GROUP", "AD_GROUP_TARGETING", "PIN_PROMOTION", "PIN_PROMOTION_TARGETING", "KEYWORD", "PRODUCT_GROUP", "PRODUCT_GROUP_TARGETING", "PRODUCT_ITEM"]
     */
    level?: pulumi.Input<string>;
    /**
     * The name value of report
     */
    name: pulumi.Input<string>;
    /**
     * A date in the format YYYY-MM-DD. If you have not set a date, it would be defaulted to latest allowed date by report api (913 days from today).
     */
    startDate?: pulumi.Input<string>;
    /**
     * Number of days to use as the conversion attribution window for a view action. must be one of ["0", "1", "7", "14", "30", "60"]
     */
    viewWindowDays?: pulumi.Input<number>;
}

export interface SourcePinterestResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePinterestResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePinterestResourceAllocationJobSpecific>[]>;
}

export interface SourcePinterestResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePinterestResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePinterestResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePinterestResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePipedriveConfiguration {
    /**
     * The Pipedrive API Token.
     */
    apiToken: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
     */
    replicationStartDate: pulumi.Input<string>;
}

export interface SourcePipedriveResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePipedriveResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePipedriveResourceAllocationJobSpecific>[]>;
}

export interface SourcePipedriveResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePipedriveResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePipedriveResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePipedriveResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePipelinerConfiguration {
    password?: pulumi.Input<string>;
    /**
     * must be one of ["eu-central", "us-east", "ca-central", "ap-southeast"]
     */
    service: pulumi.Input<string>;
    spaceid: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourcePipelinerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePipelinerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePipelinerResourceAllocationJobSpecific>[]>;
}

export interface SourcePipelinerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePipelinerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePipelinerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePipelinerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePivotalTrackerConfiguration {
    /**
     * Pivotal Tracker API token
     */
    apiToken: pulumi.Input<string>;
}

export interface SourcePivotalTrackerResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePivotalTrackerResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePivotalTrackerResourceAllocationJobSpecific>[]>;
}

export interface SourcePivotalTrackerResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePivotalTrackerResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePivotalTrackerResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePivotalTrackerResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePiwikConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The organization id appearing at URL of your piwik website
     */
    organizationId: pulumi.Input<string>;
}

export interface SourcePiwikResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePiwikResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePiwikResourceAllocationJobSpecific>[]>;
}

export interface SourcePiwikResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePiwikResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePiwikResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePiwikResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePlaidConfiguration {
    /**
     * The end-user's Link access token.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Plaid API key to use to hit the API.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The Plaid client id.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Plaid environment. must be one of ["sandbox", "development", "production"]
     */
    plaidEnv: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data for Plaid in the format YYYY-MM-DD. All data generated after this date will be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourcePlaidResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePlaidResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePlaidResourceAllocationJobSpecific>[]>;
}

export interface SourcePlaidResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePlaidResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePlaidResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePlaidResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePlanhatConfiguration {
    /**
     * Your Planhat <a href="https://docs.planhat.com/#authentication">API Access Token</a>
     */
    apiToken: pulumi.Input<string>;
}

export interface SourcePlanhatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePlanhatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePlanhatResourceAllocationJobSpecific>[]>;
}

export interface SourcePlanhatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePlanhatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePlanhatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePlanhatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePlausibleConfiguration {
    /**
     * Plausible API Key. See the <a href="https://plausible.io/docs/stats-api">docs</a> for information on how to generate this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The API URL of your plausible instance. Change this if you self-host plausible. The default is https://plausible.io/api/v1/stats
     */
    apiUrl?: pulumi.Input<string>;
    /**
     * The domain of the site you want to retrieve data for. Enter the name of your site as configured on Plausible, i.e., excluding "https://" and "www". Can be retrieved from the 'domain' field in your Plausible site settings.
     */
    siteId: pulumi.Input<string>;
    /**
     * Start date for data to retrieve, in ISO-8601 format.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourcePlausibleResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePlausibleResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePlausibleResourceAllocationJobSpecific>[]>;
}

export interface SourcePlausibleResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePlausibleResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePlausibleResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePlausibleResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePocketConfiguration {
    /**
     * The user's Pocket access token.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Your application's Consumer Key.
     */
    consumerKey: pulumi.Input<string>;
    /**
     * Select the content type of the items to retrieve. must be one of ["article", "video", "image"]
     */
    contentType?: pulumi.Input<string>;
    /**
     * Select the granularity of the information about each item. must be one of ["simple", "complete"]
     */
    detailType?: pulumi.Input<string>;
    /**
     * Only return items from a particular `domain`.
     */
    domain?: pulumi.Input<string>;
    /**
     * Retrieve only favorited items. Default: false
     */
    favorite?: pulumi.Input<boolean>;
    /**
     * Only return items whose title or url contain the `search` string.
     */
    search?: pulumi.Input<string>;
    /**
     * Only return items modified since the given timestamp.
     */
    since?: pulumi.Input<string>;
    /**
     * Sort retrieved items by the given criteria. must be one of ["newest", "oldest", "title", "site"]
     */
    sort?: pulumi.Input<string>;
    /**
     * Select the state of the items to retrieve. must be one of ["unread", "archive", "all"]
     */
    state?: pulumi.Input<string>;
    /**
     * Return only items tagged with this tag name. Use _untagged_ for retrieving only untagged items.
     */
    tag?: pulumi.Input<string>;
}

export interface SourcePocketResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePocketResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePocketResourceAllocationJobSpecific>[]>;
}

export interface SourcePocketResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePocketResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePocketResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePocketResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePokeapiConfiguration {
    /**
     * Pokemon requested from the API. must be one of ["bulbasaur", "ivysaur", "venusaur", "charmander", "charmeleon", "charizard", "squirtle", "wartortle", "blastoise", "caterpie", "metapod", "butterfree", "weedle", "kakuna", "beedrill", "pidgey", "pidgeotto", "pidgeot", "rattata", "raticate", "spearow", "fearow", "ekans", "arbok", "pikachu", "raichu", "sandshrew", "sandslash", "nidoranf", "nidorina", "nidoqueen", "nidoranm", "nidorino", "nidoking", "clefairy", "clefable", "vulpix", "ninetales", "jigglypuff", "wigglytuff", "zubat", "golbat", "oddish", "gloom", "vileplume", "paras", "parasect", "venonat", "venomoth", "diglett", "dugtrio", "meowth", "persian", "psyduck", "golduck", "mankey", "primeape", "growlithe", "arcanine", "poliwag", "poliwhirl", "poliwrath", "abra", "kadabra", "alakazam", "machop", "machoke", "machamp", "bellsprout", "weepinbell", "victreebel", "tentacool", "tentacruel", "geodude", "graveler", "golem", "ponyta", "rapidash", "slowpoke", "slowbro", "magnemite", "magneton", "farfetchd", "doduo", "dodrio", "seel", "dewgong", "grimer", "muk", "shellder", "cloyster", "gastly", "haunter", "gengar", "onix", "drowzee", "hypno", "krabby", "kingler", "voltorb", "electrode", "exeggcute", "exeggutor", "cubone", "marowak", "hitmonlee", "hitmonchan", "lickitung", "koffing", "weezing", "rhyhorn", "rhydon", "chansey", "tangela", "kangaskhan", "horsea", "seadra", "goldeen", "seaking", "staryu", "starmie", "mrmime", "scyther", "jynx", "electabuzz", "magmar", "pinsir", "tauros", "magikarp", "gyarados", "lapras", "ditto", "eevee", "vaporeon", "jolteon", "flareon", "porygon", "omanyte", "omastar", "kabuto", "kabutops", "aerodactyl", "snorlax", "articuno", "zapdos", "moltres", "dratini", "dragonair", "dragonite", "mewtwo", "mew", "chikorita", "bayleef", "meganium", "cyndaquil", "quilava", "typhlosion", "totodile", "croconaw", "feraligatr", "sentret", "furret", "hoothoot", "noctowl", "ledyba", "ledian", "spinarak", "ariados", "crobat", "chinchou", "lanturn", "pichu", "cleffa", "igglybuff", "togepi", "togetic", "natu", "xatu", "mareep", "flaaffy", "ampharos", "bellossom", "marill", "azumarill", "sudowoodo", "politoed", "hoppip", "skiploom", "jumpluff", "aipom", "sunkern", "sunflora", "yanma", "wooper", "quagsire", "espeon", "umbreon", "murkrow", "slowking", "misdreavus", "unown", "wobbuffet", "girafarig", "pineco", "forretress", "dunsparce", "gligar", "steelix", "snubbull", "granbull", "qwilfish", "scizor", "shuckle", "heracross", "sneasel", "teddiursa", "ursaring", "slugma", "magcargo", "swinub", "piloswine", "corsola", "remoraid", "octillery", "delibird", "mantine", "skarmory", "houndour", "houndoom", "kingdra", "phanpy", "donphan", "porygon2", "stantler", "smeargle", "tyrogue", "hitmontop", "smoochum", "elekid", "magby", "miltank", "blissey", "raikou", "entei", "suicune", "larvitar", "pupitar", "tyranitar", "lugia", "ho-oh", "celebi", "treecko", "grovyle", "sceptile", "torchic", "combusken", "blaziken", "mudkip", "marshtomp", "swampert", "poochyena", "mightyena", "zigzagoon", "linoone", "wurmple", "silcoon", "beautifly", "cascoon", "dustox", "lotad", "lombre", "ludicolo", "seedot", "nuzleaf", "shiftry", "taillow", "swellow", "wingull", "pelipper", "ralts", "kirlia", "gardevoir", "surskit", "masquerain", "shroomish", "breloom", "slakoth", "vigoroth", "slaking", "nincada", "ninjask", "shedinja", "whismur", "loudred", "exploud", "makuhita", "hariyama", "azurill", "nosepass", "skitty", "delcatty", "sableye", "mawile", "aron", "lairon", "aggron", "meditite", "medicham", "electrike", "manectric", "plusle", "minun", "volbeat", "illumise", "roselia", "gulpin", "swalot", "carvanha", "sharpedo", "wailmer", "wailord", "numel", "camerupt", "torkoal", "spoink", "grumpig", "spinda", "trapinch", "vibrava", "flygon", "cacnea", "cacturne", "swablu", "altaria", "zangoose", "seviper", "lunatone", "solrock", "barboach", "whiscash", "corphish", "crawdaunt", "baltoy", "claydol", "lileep", "cradily", "anorith", "armaldo", "feebas", "milotic", "castform", "kecleon", "shuppet", "banette", "duskull", "dusclops", "tropius", "chimecho", "absol", "wynaut", "snorunt", "glalie", "spheal", "sealeo", "walrein", "clamperl", "huntail", "gorebyss", "relicanth", "luvdisc", "bagon", "shelgon", "salamence", "beldum", "metang", "metagross", "regirock", "regice", "registeel", "latias", "latios", "kyogre", "groudon", "rayquaza", "jirachi", "deoxys", "turtwig", "grotle", "torterra", "chimchar", "monferno", "infernape", "piplup", "prinplup", "empoleon", "starly", "staravia", "staraptor", "bidoof", "bibarel", "kricketot", "kricketune", "shinx", "luxio", "luxray", "budew", "roserade", "cranidos", "rampardos", "shieldon", "bastiodon", "burmy", "wormadam", "mothim", "combee", "vespiquen", "pachirisu", "buizel", "floatzel", "cherubi", "cherrim", "shellos", "gastrodon", "ambipom", "drifloon", "drifblim", "buneary", "lopunny", "mismagius", "honchkrow", "glameow", "purugly", "chingling", "stunky", "skuntank", "bronzor", "bronzong", "bonsly", "mimejr", "happiny", "chatot", "spiritomb", "gible", "gabite", "garchomp", "munchlax", "riolu", "lucario", "hippopotas", "hippowdon", "skorupi", "drapion", "croagunk", "toxicroak", "carnivine", "finneon", "lumineon", "mantyke", "snover", "abomasnow", "weavile", "magnezone", "lickilicky", "rhyperior", "tangrowth", "electivire", "magmortar", "togekiss", "yanmega", "leafeon", "glaceon", "gliscor", "mamoswine", "porygon-z", "gallade", "probopass", "dusknoir", "froslass", "rotom", "uxie", "mesprit", "azelf", "dialga", "palkia", "heatran", "regigigas", "giratina", "cresselia", "phione", "manaphy", "darkrai", "shaymin", "arceus", "victini", "snivy", "servine", "serperior", "tepig", "pignite", "emboar", "oshawott", "dewott", "samurott", "patrat", "watchog", "lillipup", "herdier", "stoutland", "purrloin", "liepard", "pansage", "simisage", "pansear", "simisear", "panpour", "simipour", "munna", "musharna", "pidove", "tranquill", "unfezant", "blitzle", "zebstrika", "roggenrola", "boldore", "gigalith", "woobat", "swoobat", "drilbur", "excadrill", "audino", "timburr", "gurdurr", "conkeldurr", "tympole", "palpitoad", "seismitoad", "throh", "sawk", "sewaddle", "swadloon", "leavanny", "venipede", "whirlipede", "scolipede", "cottonee", "whimsicott", "petilil", "lilligant", "basculin", "sandile", "krokorok", "krookodile", "darumaka", "darmanitan", "maractus", "dwebble", "crustle", "scraggy", "scrafty", "sigilyph", "yamask", "cofagrigus", "tirtouga", "carracosta", "archen", "archeops", "trubbish", "garbodor", "zorua", "zoroark", "minccino", "cinccino", "gothita", "gothorita", "gothitelle", "solosis", "duosion", "reuniclus", "ducklett", "swanna", "vanillite", "vanillish", "vanilluxe", "deerling", "sawsbuck", "emolga", "karrablast", "escavalier", "foongus", "amoonguss", "frillish", "jellicent", "alomomola", "joltik", "galvantula", "ferroseed", "ferrothorn", "klink", "klang", "klinklang", "tynamo", "eelektrik", "eelektross", "elgyem", "beheeyem", "litwick", "lampent", "chandelure", "axew", "fraxure", "haxorus", "cubchoo", "beartic", "cryogonal", "shelmet", "accelgor", "stunfisk", "mienfoo", "mienshao", "druddigon", "golett", "golurk", "pawniard", "bisharp", "bouffalant", "rufflet", "braviary", "vullaby", "mandibuzz", "heatmor", "durant", "deino", "zweilous", "hydreigon", "larvesta", "volcarona", "cobalion", "terrakion", "virizion", "tornadus", "thundurus", "reshiram", "zekrom", "landorus", "kyurem", "keldeo", "meloetta", "genesect", "chespin", "quilladin", "chesnaught", "fennekin", "braixen", "delphox", "froakie", "frogadier", "greninja", "bunnelby", "diggersby", "fletchling", "fletchinder", "talonflame", "scatterbug", "spewpa", "vivillon", "litleo", "pyroar", "flabebe", "floette", "florges", "skiddo", "gogoat", "pancham", "pangoro", "furfrou", "espurr", "meowstic", "honedge", "doublade", "aegislash", "spritzee", "aromatisse", "swirlix", "slurpuff", "inkay", "malamar", "binacle", "barbaracle", "skrelp", "dragalge", "clauncher", "clawitzer", "helioptile", "heliolisk", "tyrunt", "tyrantrum", "amaura", "aurorus", "sylveon", "hawlucha", "dedenne", "carbink", "goomy", "sliggoo", "goodra", "klefki", "phantump", "trevenant", "pumpkaboo", "gourgeist", "bergmite", "avalugg", "noibat", "noivern", "xerneas", "yveltal", "zygarde", "diancie", "hoopa", "volcanion", "rowlet", "dartrix", "decidueye", "litten", "torracat", "incineroar", "popplio", "brionne", "primarina", "pikipek", "trumbeak", "toucannon", "yungoos", "gumshoos", "grubbin", "charjabug", "vikavolt", "crabrawler", "crabominable", "oricorio", "cutiefly", "ribombee", "rockruff", "lycanroc", "wishiwashi", "mareanie", "toxapex", "mudbray", "mudsdale", "dewpider", "araquanid", "fomantis", "lurantis", "morelull", "shiinotic", "salandit", "salazzle", "stufful", "bewear", "bounsweet", "steenee", "tsareena", "comfey", "oranguru", "passimian", "wimpod", "golisopod", "sandygast", "palossand", "pyukumuku", "typenull", "silvally", "minior", "komala", "turtonator", "togedemaru", "mimikyu", "bruxish", "drampa", "dhelmise", "jangmo-o", "hakamo-o", "kommo-o", "tapukoko", "tapulele", "tapubulu", "tapufini", "cosmog", "cosmoem", "solgaleo", "lunala", "nihilego", "buzzwole", "pheromosa", "xurkitree", "celesteela", "kartana", "guzzlord", "necrozma", "magearna", "marshadow", "poipole", "naganadel", "stakataka", "blacephalon", "zeraora", "meltan", "melmetal", "grookey", "thwackey", "rillaboom", "scorbunny", "raboot", "cinderace", "sobble", "drizzile", "inteleon", "skwovet", "greedent", "rookidee", "corvisquire", "corviknight", "blipbug", "dottler", "orbeetle", "nickit", "thievul", "gossifleur", "eldegoss", "wooloo", "dubwool", "chewtle", "drednaw", "yamper", "boltund", "rolycoly", "carkol", "coalossal", "applin", "flapple", "appletun", "silicobra", "sandaconda", "cramorant", "arrokuda", "barraskewda", "toxel", "toxtricity", "sizzlipede", "centiskorch", "clobbopus", "grapploct", "sinistea", "polteageist", "hatenna", "hattrem", "hatterene", "impidimp", "morgrem", "grimmsnarl", "obstagoon", "perrserker", "cursola", "sirfetchd", "mrrime", "runerigus", "milcery", "alcremie", "falinks", "pincurchin", "snom", "frosmoth", "stonjourner", "eiscue", "indeedee", "morpeko", "cufant", "copperajah", "dracozolt", "arctozolt", "dracovish", "arctovish", "duraludon", "dreepy", "drakloak", "dragapult", "zacian", "zamazenta", "eternatus", "kubfu", "urshifu", "zarude", "regieleki", "regidrago", "glastrier", "spectrier", "calyrex"]
     */
    pokemonName: pulumi.Input<string>;
}

export interface SourcePokeapiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePokeapiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePokeapiResourceAllocationJobSpecific>[]>;
}

export interface SourcePokeapiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePokeapiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePokeapiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePokeapiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePolygonStockApiConfiguration {
    /**
     * Determines whether or not the results are adjusted for splits. By default, results are adjusted and set to true. Set this to false to get results that are NOT adjusted for splits.
     */
    adjusted?: pulumi.Input<string>;
    /**
     * Your API ACCESS Key
     */
    apiKey: pulumi.Input<string>;
    /**
     * The target date for the aggregate window.
     */
    endDate: pulumi.Input<string>;
    /**
     * The target date for the aggregate window.
     */
    limit?: pulumi.Input<number>;
    /**
     * The size of the timespan multiplier.
     */
    multiplier: pulumi.Input<number>;
    /**
     * Sort the results by timestamp. asc will return results in ascending order (oldest at the top), desc will return results in descending order (newest at the top).
     */
    sort?: pulumi.Input<string>;
    /**
     * The beginning date for the aggregate window.
     */
    startDate: pulumi.Input<string>;
    /**
     * The exchange symbol that this item is traded under.
     */
    stocksTicker: pulumi.Input<string>;
    /**
     * The size of the time window.
     */
    timespan: pulumi.Input<string>;
}

export interface SourcePolygonStockApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePolygonStockApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePolygonStockApiResourceAllocationJobSpecific>[]>;
}

export interface SourcePolygonStockApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePolygonStockApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePolygonStockApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePolygonStockApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePoplarConfiguration {
    /**
     * Your Poplar API Access Token. Generate it from the [API Credentials page](https://app.heypoplar.com/credentials) in your account. Use a production token for live data or a test token for testing purposes.
     */
    accessToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourcePoplarResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePoplarResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePoplarResourceAllocationJobSpecific>[]>;
}

export interface SourcePoplarResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePoplarResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePoplarResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePoplarResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePostgresConfiguration {
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (Eg. key1=value1&key2=value2&key3=value3). For more information read about <a href="https://jdbc.postgresql.org/documentation/head/connect.html">JDBC URL parameters</a>.
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database. Default: 5432
     */
    port?: pulumi.Input<number>;
    /**
     * Configures how data is extracted from the database.
     */
    replicationMethod?: pulumi.Input<inputs.SourcePostgresConfigurationReplicationMethod>;
    /**
     * The list of schemas (case sensitive) to sync from. Defaults to public.
     */
    schemas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * SSL connection modes. 
     *   Read more <a href="https://jdbc.postgresql.org/documentation/head/ssl-client.html"> in the docs</a>.
     */
    sslMode?: pulumi.Input<inputs.SourcePostgresConfigurationSslMode>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod?: pulumi.Input<inputs.SourcePostgresConfigurationTunnelMethod>;
    /**
     * Username to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationReplicationMethod {
    /**
     * <i>Recommended</i> - Incrementally reads new inserts and updates via Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#xmin">Xmin system column</a>. Suitable for databases that have low transaction pressure.
     */
    detectChangesWithXminSystemColumn?: pulumi.Input<inputs.SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumn>;
    /**
     * <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using the Postgres <a href="https://docs.airbyte.com/integrations/sources/postgres/#cdc">write-ahead log (WAL)</a>. This needs to be configured on the source database itself. Recommended for tables of any size.
     */
    readChangesUsingWriteAheadLogCdc?: pulumi.Input<inputs.SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc>;
    /**
     * Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
     */
    scanChangesWithUserDefinedCursor?: pulumi.Input<inputs.SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursor>;
}

export interface SourcePostgresConfigurationReplicationMethodDetectChangesWithXminSystemColumn {
}

export interface SourcePostgresConfigurationReplicationMethodReadChangesUsingWriteAheadLogCdc {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Specifies a query that the connector executes on the source database when the connector sends a heartbeat message. Please see the <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-wal-disk-consumption-and-heartbeat-action-query">setup guide</a> for how and when to configure this setting. Default: ""
     */
    heartbeatActionQuery?: pulumi.Input<string>;
    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC logs. Default: 8
     */
    initialLoadTimeoutHours?: pulumi.Input<number>;
    /**
     * The amount of time the connector will wait when it launches to determine if there is new data to sync or not. Defaults to 1200 seconds. Valid range: 120 seconds to 2400 seconds. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres/postgres-troubleshooting#advanced-setting-up-initial-cdc-waiting-time">initial waiting time</a>. Default: 1200
     */
    initialWaitingSeconds?: pulumi.Input<number>;
    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value into the WAL. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. Default: "Fail sync"; must be one of ["Fail sync", "Re-sync data"]
     */
    invalidCdcCursorPositionBehavior?: pulumi.Input<string>;
    /**
     * Determines when Airbyte should flush the LSN of processed WAL logs in the source database. `After loading Data in the destination` is default. If `While reading Data` is selected, in case of a downstream failure (while loading data into the destination), next sync would result in a full sync. Default: "After loading Data in the destination"; must be one of ["While reading Data", "After loading Data in the destination"]
     */
    lsnCommitBehaviour?: pulumi.Input<string>;
    /**
     * A logical decoding plugin installed on the PostgreSQL server. Default: "pgoutput"; must be "pgoutput"
     */
    plugin?: pulumi.Input<string>;
    /**
     * A Postgres publication used for consuming changes. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-4-create-publications-and-replication-identities-for-tables">publications and replication identities</a>.
     */
    publication: pulumi.Input<string>;
    /**
     * The size of the internal queue. This may interfere with memory consumption and efficiency of the connector, please be careful. Default: 10000
     */
    queueSize?: pulumi.Input<number>;
    /**
     * A plugin logical replication slot. Read about <a href="https://docs.airbyte.com/integrations/sources/postgres#step-3-create-replication-slot">replication slots</a>.
     */
    replicationSlot: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationReplicationMethodScanChangesWithUserDefinedCursor {
}

export interface SourcePostgresConfigurationSslMode {
    /**
     * Enables encryption only when required by the source database.
     */
    allow?: pulumi.Input<inputs.SourcePostgresConfigurationSslModeAllow>;
    /**
     * Disables encryption of communication between Airbyte and source database.
     */
    disable?: pulumi.Input<inputs.SourcePostgresConfigurationSslModeDisable>;
    /**
     * Allows unencrypted connection only if the source database does not support encryption.
     */
    prefer?: pulumi.Input<inputs.SourcePostgresConfigurationSslModePrefer>;
    /**
     * Always require encryption. If the source database server does not support encryption, connection will fail.
     */
    require?: pulumi.Input<inputs.SourcePostgresConfigurationSslModeRequire>;
    /**
     * Always require encryption and verifies that the source database server has a valid SSL certificate.
     */
    verifyCa?: pulumi.Input<inputs.SourcePostgresConfigurationSslModeVerifyCa>;
    /**
     * This is the most secure mode. Always require encryption and verifies the identity of the source database server.
     */
    verifyFull?: pulumi.Input<inputs.SourcePostgresConfigurationSslModeVerifyFull>;
}

export interface SourcePostgresConfigurationSslModeAllow {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationSslModeDisable {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationSslModePrefer {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationSslModeRequire {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationSslModeVerifyCa {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Client certificate
     */
    clientCertificate?: pulumi.Input<string>;
    /**
     * Client key
     */
    clientKey?: pulumi.Input<string>;
    /**
     * Password for keystorage. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationSslModeVerifyFull {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * CA certificate
     */
    caCertificate: pulumi.Input<string>;
    /**
     * Client certificate
     */
    clientCertificate?: pulumi.Input<string>;
    /**
     * Client key
     */
    clientKey?: pulumi.Input<string>;
    /**
     * Password for keystorage. If you do not add it - the password will be generated automatically.
     */
    clientKeyPassword?: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationTunnelMethod {
    noTunnel?: pulumi.Input<inputs.SourcePostgresConfigurationTunnelMethodNoTunnel>;
    passwordAuthentication?: pulumi.Input<inputs.SourcePostgresConfigurationTunnelMethodPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.SourcePostgresConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourcePostgresConfigurationTunnelMethodNoTunnel {
}

export interface SourcePostgresConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourcePostgresConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host.
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourcePostgresResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePostgresResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePostgresResourceAllocationJobSpecific>[]>;
}

export interface SourcePostgresResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePostgresResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePostgresResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePostgresResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePosthogConfiguration {
    /**
     * API Key. See the <a href="https://docs.airbyte.com/integrations/sources/posthog">docs</a> for information on how to generate this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Base PostHog url. Defaults to PostHog Cloud (https://app.posthog.com). Default: "https://app.posthog.com"
     */
    baseUrl?: pulumi.Input<string>;
    /**
     * Set lower value in case of failing long running sync of events stream. Default: 30
     */
    eventsTimeStep?: pulumi.Input<number>;
    /**
     * The date from which you'd like to replicate the data. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourcePosthogResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePosthogResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePosthogResourceAllocationJobSpecific>[]>;
}

export interface SourcePosthogResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePosthogResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePosthogResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePosthogResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePostmarkappConfiguration {
    /**
     * API Key for account
     */
    xPostmarkAccountToken: pulumi.Input<string>;
    /**
     * API Key for server
     */
    xPostmarkServerToken: pulumi.Input<string>;
}

export interface SourcePostmarkappResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePostmarkappResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePostmarkappResourceAllocationJobSpecific>[]>;
}

export interface SourcePostmarkappResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePostmarkappResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePostmarkappResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePostmarkappResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePrestashopConfiguration {
    /**
     * Your PrestaShop access key. See <a href="https://devdocs.prestashop.com/1.7/webservice/tutorials/creating-access/#create-an-access-key"> the docs </a> for info on how to obtain this.
     */
    accessKey: pulumi.Input<string>;
    /**
     * The Start date in the format YYYY-MM-DD.
     */
    startDate: pulumi.Input<string>;
    /**
     * Shop URL without trailing slash.
     */
    url: pulumi.Input<string>;
}

export interface SourcePrestashopResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePrestashopResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePrestashopResourceAllocationJobSpecific>[]>;
}

export interface SourcePrestashopResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePrestashopResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePrestashopResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePrestashopResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePretixConfiguration {
    /**
     * API token to use. Obtain it from the pretix web interface by creating a new token under your team settings.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourcePretixResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePretixResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePretixResourceAllocationJobSpecific>[]>;
}

export interface SourcePretixResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePretixResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePretixResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePretixResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePrimetricConfiguration {
    /**
     * The Client ID of your Primetric developer application. The Client ID is visible <a href=\"https://app.primetric.com/administrator/integrations">here</a>.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Primetric developer application. You can manage your client's credentials <a href=\"https://app.primetric.com/administrator/integrations">here</a>.
     */
    clientSecret: pulumi.Input<string>;
}

export interface SourcePrimetricResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePrimetricResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePrimetricResourceAllocationJobSpecific>[]>;
}

export interface SourcePrimetricResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePrimetricResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePrimetricResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePrimetricResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePrintifyConfiguration {
    /**
     * Your Printify API token. Obtain it from your Printify account settings.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourcePrintifyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePrintifyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePrintifyResourceAllocationJobSpecific>[]>;
}

export interface SourcePrintifyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePrintifyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePrintifyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePrintifyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceProductboardConfiguration {
    /**
     * Your Productboard access token. See https://developer.productboard.com/reference/authentication for steps to generate one.
     */
    accessToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceProductboardResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceProductboardResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceProductboardResourceAllocationJobSpecific>[]>;
}

export interface SourceProductboardResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceProductboardResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceProductboardResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceProductboardResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceProductiveConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * The organization ID which could be seen from `https://app.productive.io/xxxx-xxxx/settings/api-integrations` page
     */
    organizationId: pulumi.Input<string>;
}

export interface SourceProductiveResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceProductiveResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceProductiveResourceAllocationJobSpecific>[]>;
}

export interface SourceProductiveResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceProductiveResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceProductiveResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceProductiveResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePypiConfiguration {
    /**
     * Name of the project/package. Can only be in lowercase with hyphen. This is the name used using pip command for installing the package.
     */
    projectName: pulumi.Input<string>;
    /**
     * Version of the project/package.  Use it to find a particular release instead of all releases.
     */
    version?: pulumi.Input<string>;
}

export interface SourcePypiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourcePypiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourcePypiResourceAllocationJobSpecific>[]>;
}

export interface SourcePypiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourcePypiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourcePypiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourcePypiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceQualarooConfiguration {
    /**
     * A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
     */
    key: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
    /**
     * IDs of the surveys from which you'd like to replicate data. If left empty, data from all surveys to which you have access will be replicated.
     */
    surveyIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * A Qualaroo token. See the <a href="https://help.qualaroo.com/hc/en-us/articles/201969438-The-REST-Reporting-API">docs</a> for instructions on how to generate it.
     */
    token: pulumi.Input<string>;
}

export interface SourceQualarooResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceQualarooResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceQualarooResourceAllocationJobSpecific>[]>;
}

export interface SourceQualarooResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceQualarooResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceQualarooResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceQualarooResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceQuickbooksConfiguration {
    /**
     * Access token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Identifies which app is making the request. Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    clientId: pulumi.Input<string>;
    /**
     * Obtain this value from the Keys tab on the app profile via My Apps on the developer site. There are two versions of this key: development and production.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Labeled Company ID. The Make API Calls panel is populated with the realm id and the current access token.
     */
    realmId: pulumi.Input<string>;
    /**
     * A token used when refreshing the access token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * Determines whether to use the sandbox or production environment. Default: false
     */
    sandbox?: pulumi.Input<boolean>;
    /**
     * The default value to use if no bookmark exists for an endpoint (rfc3339 date string). E.g, 2021-03-20T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
    /**
     * The date-time when the access token should be refreshed.
     */
    tokenExpiryDate: pulumi.Input<string>;
}

export interface SourceQuickbooksResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceQuickbooksResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceQuickbooksResourceAllocationJobSpecific>[]>;
}

export interface SourceQuickbooksResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceQuickbooksResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceQuickbooksResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceQuickbooksResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRailzConfiguration {
    /**
     * Client ID (client_id)
     */
    clientId: pulumi.Input<string>;
    /**
     * Secret key (secret_key)
     */
    secretKey: pulumi.Input<string>;
    /**
     * Start date
     */
    startDate: pulumi.Input<string>;
}

export interface SourceRailzResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRailzResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRailzResourceAllocationJobSpecific>[]>;
}

export interface SourceRailzResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRailzResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRailzResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRailzResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRdStationMarketingConfiguration {
    /**
     * Choose one of the possible authorization method
     */
    authorization?: pulumi.Input<inputs.SourceRdStationMarketingConfigurationAuthorization>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated. When specified and not None, then stream will behave as incremental
     */
    startDate: pulumi.Input<string>;
}

export interface SourceRdStationMarketingConfigurationAuthorization {
    signInViaRdStationOAuth?: pulumi.Input<inputs.SourceRdStationMarketingConfigurationAuthorizationSignInViaRdStationOAuth>;
}

export interface SourceRdStationMarketingConfigurationAuthorizationSignInViaRdStationOAuth {
    /**
     * The Client ID of your RD Station developer application.
     */
    clientId?: pulumi.Input<string>;
    /**
     * The Client Secret of your RD Station developer application
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * The token for obtaining the new access token.
     */
    refreshToken?: pulumi.Input<string>;
}

export interface SourceRdStationMarketingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRdStationMarketingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRdStationMarketingResourceAllocationJobSpecific>[]>;
}

export interface SourceRdStationMarketingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRdStationMarketingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRdStationMarketingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRdStationMarketingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRechargeConfiguration {
    /**
     * The value of the Access Token generated. See the <a href="https://docs.airbyte.com/integrations/sources/recharge">docs</a> for more information.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The date from which you'd like to replicate data for Recharge API, in the format YYYY-MM-DDT00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
    /**
     * Define whether or not the `Orders` stream should use the deprecated `2021-01` API version, or use `2021-11`, otherwise. Default: true
     */
    useOrdersDeprecatedApi?: pulumi.Input<boolean>;
}

export interface SourceRechargeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRechargeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRechargeResourceAllocationJobSpecific>[]>;
}

export interface SourceRechargeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRechargeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRechargeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRechargeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRecreationConfiguration {
    /**
     * API Key
     */
    apikey: pulumi.Input<string>;
    queryCampsites?: pulumi.Input<string>;
}

export interface SourceRecreationResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRecreationResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRecreationResourceAllocationJobSpecific>[]>;
}

export interface SourceRecreationResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRecreationResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRecreationResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRecreationResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRecruiteeConfiguration {
    /**
     * Recruitee API Key. See <a href="https://docs.recruitee.com/reference/getting-started#generate-api-token">here</a>.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Recruitee Company ID. You can also find this ID on the <a href="https://app.recruitee.com/#/settings/api_tokens">Recruitee API tokens page</a>.
     */
    companyId: pulumi.Input<number>;
}

export interface SourceRecruiteeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRecruiteeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRecruiteeResourceAllocationJobSpecific>[]>;
}

export interface SourceRecruiteeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRecruiteeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRecruiteeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRecruiteeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRecurlyConfiguration {
    /**
     * Recurly API Key. See the  <a href="https://docs.airbyte.com/integrations/sources/recurly">docs</a> for more information on how to generate this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * ISO8601 timestamp from which the replication from Recurly API will start from.
     */
    beginTime?: pulumi.Input<string>;
    /**
     * ISO8601 timestamp to which the replication from Recurly API will stop. Records after that date won't be imported.
     */
    endTime?: pulumi.Input<string>;
}

export interface SourceRecurlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRecurlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRecurlyResourceAllocationJobSpecific>[]>;
}

export interface SourceRecurlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRecurlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRecurlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRecurlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRedditConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Specifies exact keyword and reduces distractions
     */
    exact?: pulumi.Input<boolean>;
    /**
     * Includes mature content. Default: false
     */
    includeOver18?: pulumi.Input<boolean>;
    /**
     * Max records per page limit
     */
    limit?: pulumi.Input<number>;
    /**
     * Specifies the query for searching in reddits and subreddits. Default: "airbyte"
     */
    query?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * Subreddits for exploration
     */
    subreddits?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceRedditResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRedditResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRedditResourceAllocationJobSpecific>[]>;
}

export interface SourceRedditResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRedditResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRedditResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRedditResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRedshiftConfiguration {
    /**
     * Name of the database.
     */
    database: pulumi.Input<string>;
    /**
     * Host Endpoint of the Redshift Cluster (must include the cluster-id, region and end with .redshift.amazonaws.com).
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * Password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * Port of the database. Default: 5439
     */
    port?: pulumi.Input<number>;
    /**
     * The list of schemas to sync from. Specify one or more explicitly or keep empty to process all schemas. Schema names are case sensitive.
     */
    schemas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Username to use to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceRedshiftResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRedshiftResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRedshiftResourceAllocationJobSpecific>[]>;
}

export interface SourceRedshiftResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRedshiftResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRedshiftResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRedshiftResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceReferralheroConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceReferralheroResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceReferralheroResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceReferralheroResourceAllocationJobSpecific>[]>;
}

export interface SourceReferralheroResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceReferralheroResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceReferralheroResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceReferralheroResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRentcastConfiguration {
    /**
     * The full address of the property, in the format of Street, City, State, Zip. Used to retrieve data for a specific property, or together with the radius parameter to search for listings in a specific area
     */
    address?: pulumi.Input<string>;
    apiKey: pulumi.Input<string>;
    /**
     * The number of bathrooms, used to search for listings matching this criteria. Supports fractions to indicate partial bathrooms
     */
    bathRooms?: pulumi.Input<number>;
    /**
     * The number of bedrooms, used to search for listings matching this criteria. Use 0 to indicate a studio layout
     */
    bedrooms?: pulumi.Input<number>;
    /**
     * The name of the city, used to search for listings in a specific city. This parameter is case-sensitive
     */
    city?: pulumi.Input<string>;
    /**
     * The type of aggregate market data to return. Defaults to "All" if not provided : All , Sale , Rental
     */
    dataType?: pulumi.Input<string>;
    /**
     * The maximum number of days since a property was listed on the market, with a minimum of 1 or The maximum number of days since a property was last sold, with a minimum of 1. Used to search for properties that were sold within the specified date range
     */
    daysOld?: pulumi.Input<string>;
    /**
     * The time range for historical record entries, in months. Defaults to 12 if not provided
     */
    historyRange?: pulumi.Input<string>;
    /**
     * The latitude of the search area. Use the latitude/longitude and radius parameters to search for listings in a specific area
     */
    latitude?: pulumi.Input<string>;
    /**
     * The longitude of the search area. Use the latitude/longitude and radius parameters to search for listings in a specific area
     */
    longitude?: pulumi.Input<string>;
    /**
     * The type of the property, used to search for listings matching this criteria : Single Family , Condo , Townhouse , Manufactured ,  Multi-Family , Apartment , Land ,
     */
    propertyType?: pulumi.Input<string>;
    /**
     * The radius of the search area in miles, with a maximum of 100. Use in combination with the latitude/longitude or address parameters to search for listings in a specific area
     */
    radius?: pulumi.Input<string>;
    /**
     * The 2-character state abbreviation, used to search for listings in a specific state. This parameter is case-sensitive
     */
    state?: pulumi.Input<string>;
    /**
     * The current listing status, used to search for listings matching this criteria : Active or Inactive
     */
    status?: pulumi.Input<string>;
    /**
     * The 5-digit zip code, used to search for listings in a specific zip code
     */
    zipcode?: pulumi.Input<string>;
}

export interface SourceRentcastResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRentcastResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRentcastResourceAllocationJobSpecific>[]>;
}

export interface SourceRentcastResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRentcastResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRentcastResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRentcastResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRepairshoprConfiguration {
    apiKey: pulumi.Input<string>;
    subdomain: pulumi.Input<string>;
}

export interface SourceRepairshoprResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRepairshoprResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRepairshoprResourceAllocationJobSpecific>[]>;
}

export interface SourceRepairshoprResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRepairshoprResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRepairshoprResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRepairshoprResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceReplyIoConfiguration {
    /**
     * The API Token for Reply
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceReplyIoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceReplyIoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceReplyIoResourceAllocationJobSpecific>[]>;
}

export interface SourceReplyIoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceReplyIoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceReplyIoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceReplyIoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRetailexpressByMaropostConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceRetailexpressByMaropostResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRetailexpressByMaropostResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRetailexpressByMaropostResourceAllocationJobSpecific>[]>;
}

export interface SourceRetailexpressByMaropostResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRetailexpressByMaropostResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRetailexpressByMaropostResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRetailexpressByMaropostResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRetentlyConfiguration {
    /**
     * Choose how to authenticate to Retently
     */
    credentials?: pulumi.Input<inputs.SourceRetentlyConfigurationCredentials>;
}

export interface SourceRetentlyConfigurationCredentials {
    authenticateViaRetentlyOAuth?: pulumi.Input<inputs.SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth>;
    authenticateWithApiToken?: pulumi.Input<inputs.SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken>;
}

export interface SourceRetentlyConfigurationCredentialsAuthenticateViaRetentlyOAuth {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The Client ID of your Retently developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Retently developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Retently Refresh Token which can be used to fetch new Bearer Tokens when the current one expires.
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceRetentlyConfigurationCredentialsAuthenticateWithApiToken {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Retently API Token. See the <a href="https://app.retently.com/settings/api/tokens">docs</a> for more information on how to obtain this key.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceRetentlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRetentlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRetentlyResourceAllocationJobSpecific>[]>;
}

export interface SourceRetentlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRetentlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRetentlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRetentlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRevenuecatConfiguration {
    /**
     * API key or access token
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceRevenuecatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRevenuecatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRevenuecatResourceAllocationJobSpecific>[]>;
}

export interface SourceRevenuecatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRevenuecatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRevenuecatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRevenuecatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRevolutMerchantConfiguration {
    /**
     * Specify the API version to use. This is required for certain API calls. Example: '2024-09-01'.
     */
    apiVersion: pulumi.Input<string>;
    /**
     * The base url of your environment. Either sandbox or production. must be one of ["sandbox-merchant", "merchant"]
     */
    environment: pulumi.Input<string>;
    /**
     * Secret API key to use for authenticating with the Revolut Merchant API. Find it in your Revolut Business account under APIs > Merchant API.
     */
    secretApiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceRevolutMerchantResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRevolutMerchantResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRevolutMerchantResourceAllocationJobSpecific>[]>;
}

export interface SourceRevolutMerchantResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRevolutMerchantResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRevolutMerchantResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRevolutMerchantResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRingcentralConfiguration {
    /**
     * Could be seen at response to basic api call to an endpoint with ~ operator.  Example- (https://platform.devtest.ringcentral.com/restapi/v1.0/account/~/extension/~/business-hours)
     */
    accountId: pulumi.Input<string>;
    /**
     * Token could be recieved by following instructions at https://developers.ringcentral.com/api-reference/authentication
     */
    authToken: pulumi.Input<string>;
    /**
     * Could be seen at response to basic api call to an endpoint with ~ operator.  Example- (https://platform.devtest.ringcentral.com/restapi/v1.0/account/~/extension/~/business-hours)
     */
    extensionId: pulumi.Input<string>;
}

export interface SourceRingcentralResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRingcentralResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRingcentralResourceAllocationJobSpecific>[]>;
}

export interface SourceRingcentralResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRingcentralResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRingcentralResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRingcentralResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRkiCovidConfiguration {
    /**
     * UTC date in the format 2017-01-25. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceRkiCovidResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRkiCovidResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRkiCovidResourceAllocationJobSpecific>[]>;
}

export interface SourceRkiCovidResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRkiCovidResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRkiCovidResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRkiCovidResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRocketChatConfiguration {
    /**
     * Your rocket.chat instance URL.
     */
    endpoint: pulumi.Input<string>;
    /**
     * Your API Token. See <a href="https://developer.rocket.chat/reference/api/rest-api/endpoints/other-important-endpoints/access-tokens-endpoints">here</a>. The token is case sensitive.
     */
    token: pulumi.Input<string>;
    /**
     * Your User Id.
     */
    userId: pulumi.Input<string>;
}

export interface SourceRocketChatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRocketChatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRocketChatResourceAllocationJobSpecific>[]>;
}

export interface SourceRocketChatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRocketChatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRocketChatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRocketChatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRocketlaneConfiguration {
    /**
     * API key to use. Generate it from the API section in Settings of your Rocketlane account.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceRocketlaneResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRocketlaneResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRocketlaneResourceAllocationJobSpecific>[]>;
}

export interface SourceRocketlaneResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRocketlaneResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRocketlaneResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRocketlaneResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRollbarConfiguration {
    accountAccessToken: pulumi.Input<string>;
    projectAccessToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceRollbarResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRollbarResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRollbarResourceAllocationJobSpecific>[]>;
}

export interface SourceRollbarResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRollbarResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRollbarResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRollbarResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRootlyConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceRootlyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRootlyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRootlyResourceAllocationJobSpecific>[]>;
}

export interface SourceRootlyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRootlyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRootlyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRootlyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRssConfiguration {
    /**
     * RSS Feed URL
     */
    url: pulumi.Input<string>;
}

export interface SourceRssResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRssResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRssResourceAllocationJobSpecific>[]>;
}

export interface SourceRssResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRssResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRssResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRssResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRuddrConfiguration {
    /**
     * API token to use. Generate it in the API Keys section of your Ruddr workspace settings.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceRuddrResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceRuddrResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceRuddrResourceAllocationJobSpecific>[]>;
}

export interface SourceRuddrResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceRuddrResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceRuddrResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceRuddrResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceS3Configuration {
    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    awsAccessKeyId?: pulumi.Input<string>;
    /**
     * In order to access private Buckets stored on AWS S3, this connector requires credentials with the proper permissions. If accessing publicly available data, this field is not necessary.
     */
    awsSecretAccessKey?: pulumi.Input<string>;
    /**
     * Name of the S3 bucket where the file(s) exist.
     */
    bucket: pulumi.Input<string>;
    deliveryMethod?: pulumi.Input<inputs.SourceS3ConfigurationDeliveryMethod>;
    /**
     * Endpoint to an S3 compatible service. Leave empty to use AWS. Default: ""
     */
    endpoint?: pulumi.Input<string>;
    /**
     * AWS region where the S3 bucket is located. If not provided, the region will be determined automatically.
     */
    regionName?: pulumi.Input<string>;
    /**
     * Specifies the Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations requested using this profile. Set the External ID to the Airbyte workspace ID, which can be found in the URL of this page.
     */
    roleArn?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceS3ConfigurationStream>[]>;
}

export interface SourceS3ConfigurationDeliveryMethod {
    /**
     * Copy raw files without parsing their contents. Bits are copied into the destination exactly as they appeared in the source. Recommended for use with unstructured text data, non-text and compressed files.
     */
    copyRawFiles?: pulumi.Input<inputs.SourceS3ConfigurationDeliveryMethodCopyRawFiles>;
    /**
     * Recommended - Extract and load structured records into your destination of choice. This is the classic method of moving data in Airbyte. It allows for blocking and hashing individual fields or files from a structured schema. Data can be flattened, typed and deduped depending on the destination.
     */
    replicateRecords?: pulumi.Input<inputs.SourceS3ConfigurationDeliveryMethodReplicateRecords>;
}

export interface SourceS3ConfigurationDeliveryMethodCopyRawFiles {
    /**
     * If enabled, sends subdirectory folder structure along with source file names to the destination. Otherwise, files will be synced by their names only. This option is ignored when file-based replication is not enabled. Default: true
     */
    preserveDirectoryStructure?: pulumi.Input<boolean>;
}

export interface SourceS3ConfigurationDeliveryMethodReplicateRecords {
}

export interface SourceS3ConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceS3ConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * The number of resent files which will be used to discover the schema for this stream.
     */
    recentNFilesToReadForSchemaDiscovery?: pulumi.Input<number>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceS3ConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatCsvFormat>;
    excelFormat?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatExcelFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceS3ConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceS3ConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceS3ConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceS3ConfigurationStreamFormatExcelFormat {
}

export interface SourceS3ConfigurationStreamFormatJsonlFormat {
}

export interface SourceS3ConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceS3ConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceS3ConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceS3ConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
}

export interface SourceS3ConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceS3ResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceS3ResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceS3ResourceAllocationJobSpecific>[]>;
}

export interface SourceS3ResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceS3ResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceS3ResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceS3ResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSafetycultureConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceSafetycultureResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSafetycultureResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSafetycultureResourceAllocationJobSpecific>[]>;
}

export interface SourceSafetycultureResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSafetycultureResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSafetycultureResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSafetycultureResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSageHrConfiguration {
    apiKey: pulumi.Input<string>;
    subdomain: pulumi.Input<string>;
}

export interface SourceSageHrResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSageHrResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSageHrResourceAllocationJobSpecific>[]>;
}

export interface SourceSageHrResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSageHrResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSageHrResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSageHrResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSalesflareConfiguration {
    /**
     * Enter you api key like this : Bearer YOUR_API_KEY
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSalesflareResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSalesflareResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSalesflareResourceAllocationJobSpecific>[]>;
}

export interface SourceSalesflareResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSalesflareResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSalesflareResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSalesflareResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSalesforceConfiguration {
    /**
     * Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client ID</a>
     */
    clientId: pulumi.Input<string>;
    /**
     * Enter your Salesforce developer application's <a href="https://developer.salesforce.com/forums/?id=9062I000000DLgbQAG">Client secret</a>
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Toggle to use Bulk API (this might cause empty fields for some streams). Default: false
     */
    forceUseBulkApi?: pulumi.Input<boolean>;
    /**
     * Toggle if you're using a <a href="https://help.salesforce.com/s/articleView?id=sf.deploy_sandboxes_parent.htm&type=5">Salesforce Sandbox</a>. Default: false
     */
    isSandbox?: pulumi.Input<boolean>;
    /**
     * Enter your application's <a href="https://developer.salesforce.com/docs/atlas.en-us.mobile_sdk.meta/mobile_sdk/oauth_refresh_token_flow.htm">Salesforce Refresh Token</a> used for Airbyte to access your Salesforce account.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * Enter the date (or date-time) in the YYYY-MM-DD or YYYY-MM-DDTHH:mm:ssZ format. Airbyte will replicate the data updated on and after this date. If this field is blank, Airbyte will replicate the data for last two years.
     */
    startDate?: pulumi.Input<string>;
    /**
     * The size of the time window (ISO8601 duration) to slice requests. Default: "P30D"
     */
    streamSliceStep?: pulumi.Input<string>;
    /**
     * Add filters to select only required stream based on `SObject` name. Use this field to filter which tables are displayed by this connector. This is useful if your Salesforce account has a large number of tables (>1000), in which case you may find it easier to navigate the UI and speed up the connector's performance if you restrict the tables displayed by this connector.
     */
    streamsCriterias?: pulumi.Input<pulumi.Input<inputs.SourceSalesforceConfigurationStreamsCriteria>[]>;
}

export interface SourceSalesforceConfigurationStreamsCriteria {
    /**
     * Default: "contains"; must be one of ["starts with", "ends with", "contains", "exacts", "starts not with", "ends not with", "not contains", "not exacts"]
     */
    criteria?: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface SourceSalesforceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSalesforceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSalesforceResourceAllocationJobSpecific>[]>;
}

export interface SourceSalesforceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSalesforceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSalesforceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSalesforceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSalesloftConfiguration {
    credentials: pulumi.Input<inputs.SourceSalesloftConfigurationCredentials>;
    /**
     * The date from which you'd like to replicate data for Salesloft API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceSalesloftConfigurationCredentials {
    authenticateViaApiKey?: pulumi.Input<inputs.SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey>;
    authenticateViaOAuth?: pulumi.Input<inputs.SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth>;
}

export interface SourceSalesloftConfigurationCredentialsAuthenticateViaApiKey {
    /**
     * API Key for making authenticated requests. More instruction on how to find this value in our <a href="https://docs.airbyte.com/integrations/sources/salesloft#setup-guide">docs</a>
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSalesloftConfigurationCredentialsAuthenticateViaOAuth {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of your Salesloft developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Salesloft developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The token for obtaining a new access token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The date-time when the access token should be refreshed.
     */
    tokenExpiryDate: pulumi.Input<string>;
}

export interface SourceSalesloftResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSalesloftResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSalesloftResourceAllocationJobSpecific>[]>;
}

export interface SourceSalesloftResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSalesloftResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSalesloftResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSalesloftResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSapFieldglassConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSapFieldglassResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSapFieldglassResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSapFieldglassResourceAllocationJobSpecific>[]>;
}

export interface SourceSapFieldglassResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSapFieldglassResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSapFieldglassResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSapFieldglassResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfiguration {
    /**
     * When this feature is enabled, during schema discovery the connector will query each table or view individually to check access privileges and inaccessible tables, views, or columns therein will be removed. In large schemas, this might cause schema discovery to take too long, in which case it might be advisable to disable this feature. Default: true
     */
    checkPrivileges?: pulumi.Input<boolean>;
    /**
     * How often (in seconds) a stream should checkpoint, when possible. Default: 300
     */
    checkpointTargetIntervalSeconds?: pulumi.Input<number>;
    /**
     * Maximum number of concurrent queries to the database. Default: 1
     */
    concurrency?: pulumi.Input<number>;
    /**
     * Configures how data is extracted from the database.
     */
    cursor: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationCursor>;
    /**
     * The encryption method with is used when communicating with the database.
     */
    encryption: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationEncryption>;
    /**
     * Hostname of the database.
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The password associated with the username.
     */
    password?: pulumi.Input<string>;
    /**
     * Port of the database.
     * SapHana Corporations recommends the following port numbers:
     * 443 - Default listening port for SAP HANA cloud client connections to the listener.
     * Default: 443
     */
    port?: pulumi.Input<number>;
    /**
     * The list of schemas to sync from. Defaults to user. Case sensitive.
     */
    schemas?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Whether to initiate an SSH tunnel before connecting to the database, and if so, which kind of authentication to use.
     */
    tunnelMethod: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationTunnelMethod>;
    /**
     * The username which is used to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationCursor {
    /**
     * <i>Recommended</i> - Incrementally reads new inserts, updates, and deletes using change data capture feature. This must be enabled on your database.
     */
    readChangesUsingChangeDataCaptureCdc?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationCursorReadChangesUsingChangeDataCaptureCdc>;
    /**
     * Incrementally detects new inserts and updates using the <a href="https://docs.airbyte.com/understanding-airbyte/connections/incremental-append/#user-defined-cursor">cursor column</a> chosen when configuring a connection (e.g. created_at, updated_at).
     */
    scanChangesWithUserDefinedCursor?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationCursorScanChangesWithUserDefinedCursor>;
}

export interface SourceSapHanaEnterpriseConfigurationCursorReadChangesUsingChangeDataCaptureCdc {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "cdc"; must be "cdc"
     */
    cursorMethod?: pulumi.Input<string>;
    /**
     * The amount of time an initial load is allowed to continue for before catching up on CDC events. Default: 8
     */
    initialLoadTimeoutHours?: pulumi.Input<number>;
    /**
     * Determines whether Airbyte should fail or re-sync data in case of an stale/invalid cursor value in the mined logs. If 'Fail sync' is chosen, a user will have to manually reset the connection before being able to continue syncing data. If 'Re-sync data' is chosen, Airbyte will automatically trigger a refresh but could lead to higher cloud costs and data loss. Default: "Fail sync"; must be one of ["Fail sync", "Re-sync data"]
     */
    invalidCdcCursorPositionBehavior?: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationCursorScanChangesWithUserDefinedCursor {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "user_defined"; must be "user_defined"
     */
    cursorMethod?: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationEncryption {
    /**
     * The native network encryption gives you the ability to encrypt database connections, without the configuration overhead of TCP/IP and SSL/TLS and without the need to open and listen on different ports.
     */
    nativeNetworkEncryptionNne?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationEncryptionNativeNetworkEncryptionNne>;
    /**
     * Verify and use the certificate provided by the server.
     */
    tlsEncryptedVerifyCertificate?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationEncryptionTlsEncryptedVerifyCertificate>;
    /**
     * Data transfer will not be encrypted.
     */
    unencrypted?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationEncryptionUnencrypted>;
}

export interface SourceSapHanaEnterpriseConfigurationEncryptionNativeNetworkEncryptionNne {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * This parameter defines what encryption algorithm is used. Default: "AES256"; must be one of ["AES256", "RC4_56", "3DES168"]
     */
    encryptionAlgorithm?: pulumi.Input<string>;
    /**
     * Default: "client_nne"; must be "client_nne"
     */
    encryptionMethod?: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationEncryptionTlsEncryptedVerifyCertificate {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "encrypted_verify_certificate"; must be "encrypted_verify_certificate"
     */
    encryptionMethod?: pulumi.Input<string>;
    /**
     * Privacy Enhanced Mail (PEM) files are concatenated certificate containers frequently used in certificate installations.
     */
    sslCertificate: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationEncryptionUnencrypted {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "unencrypted"; must be "unencrypted"
     */
    encryptionMethod?: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationTunnelMethod {
    /**
     * No ssh tunnel needed to connect to database
     */
    noTunnel?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationTunnelMethodNoTunnel>;
    /**
     * Connect through a jump server tunnel host using username and password authentication
     */
    passwordAuthentication?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationTunnelMethodPasswordAuthentication>;
    /**
     * Connect through a jump server tunnel host using username and ssh key
     */
    sshKeyAuthentication?: pulumi.Input<inputs.SourceSapHanaEnterpriseConfigurationTunnelMethodSshKeyAuthentication>;
}

export interface SourceSapHanaEnterpriseConfigurationTunnelMethodNoTunnel {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Default: "NO_TUNNEL"; must be "NO_TUNNEL"
     */
    tunnelMethod?: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationTunnelMethodPasswordAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_PASSWORD_AUTH"; must be "SSH_PASSWORD_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
    /**
     * OS-level password for logging into the jump server host
     */
    tunnelUserPassword: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseConfigurationTunnelMethodSshKeyAuthentication {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    sshKey: pulumi.Input<string>;
    /**
     * Hostname of the jump server host that allows inbound ssh tunnel.
     */
    tunnelHost: pulumi.Input<string>;
    /**
     * Default: "SSH_KEY_AUTH"; must be "SSH_KEY_AUTH"
     */
    tunnelMethod?: pulumi.Input<string>;
    /**
     * Port on the proxy/jump server that accepts inbound ssh connections. Default: 22
     */
    tunnelPort?: pulumi.Input<number>;
    /**
     * OS-level username for logging into the jump server host
     */
    tunnelUser: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSapHanaEnterpriseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSapHanaEnterpriseResourceAllocationJobSpecific>[]>;
}

export interface SourceSapHanaEnterpriseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSapHanaEnterpriseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSapHanaEnterpriseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSapHanaEnterpriseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSavvycalConfiguration {
    /**
     * Go to SavvyCal â†’ Settings â†’ Developer â†’ Personal Tokens and make a new token. Then, copy the private key. https://savvycal.com/developers
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSavvycalResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSavvycalResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSavvycalResourceAllocationJobSpecific>[]>;
}

export interface SourceSavvycalResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSavvycalResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSavvycalResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSavvycalResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceScryfallConfiguration {
}

export interface SourceScryfallResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceScryfallResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceScryfallResourceAllocationJobSpecific>[]>;
}

export interface SourceScryfallResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceScryfallResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceScryfallResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceScryfallResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSecodaConfiguration {
    /**
     * Your API Access Key. See <a href="https://docs.secoda.co/secoda-api/authentication">here</a>. The key is case sensitive.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSecodaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSecodaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSecodaResourceAllocationJobSpecific>[]>;
}

export interface SourceSecodaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSecodaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSecodaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSecodaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSegmentConfiguration {
    /**
     * API token to use. Generate it in Segment's Workspace settings.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The region for the API, e.g., 'api' for US or 'eu1' for EU. Default: "api"
     */
    region?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceSegmentResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSegmentResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSegmentResourceAllocationJobSpecific>[]>;
}

export interface SourceSegmentResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSegmentResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSegmentResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSegmentResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendgridConfiguration {
    /**
     * Sendgrid API Key, use <a href=\"https://app.sendgrid.com/settings/api_keys/\">admin</a> to generate this key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceSendgridResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSendgridResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSendgridResourceAllocationJobSpecific>[]>;
}

export interface SourceSendgridResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendgridResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSendgridResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSendgridResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendinblueConfiguration {
    /**
     * Your API Key. See <a href="https://developers.sendinblue.com/docs/getting-started">here</a>.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSendinblueResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSendinblueResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSendinblueResourceAllocationJobSpecific>[]>;
}

export interface SourceSendinblueResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendinblueResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSendinblueResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSendinblueResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendowlConfiguration {
    /**
     * Enter your API secret
     */
    password?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * Enter you API Key
     */
    username: pulumi.Input<string>;
}

export interface SourceSendowlResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSendowlResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSendowlResourceAllocationJobSpecific>[]>;
}

export interface SourceSendowlResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendowlResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSendowlResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSendowlResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendpulseConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
}

export interface SourceSendpulseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSendpulseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSendpulseResourceAllocationJobSpecific>[]>;
}

export interface SourceSendpulseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSendpulseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSendpulseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSendpulseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSenseforceConfiguration {
    /**
     * Your API access token. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a>. The toke is case sensitive.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Your Senseforce API backend URL. This is the URL shown during the Login screen. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: Most Senseforce backend APIs have the term 'galaxy' in their ULR)
     */
    backendUrl: pulumi.Input<string>;
    /**
     * The ID of the dataset you want to synchronize. The ID can be found in the URL when opening the dataset. See <a href="https://manual.senseforce.io/manual/sf-platform/public-api/get-your-access-token/">here</a> for more details. (Note: As the Senseforce API only allows to synchronize a specific dataset, each dataset you  want to synchronize needs to be implemented as a separate airbyte source).
     */
    datasetId: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25. Only data with "Timestamp" after this date will be replicated. Important note: This start date must be set to the first day of where your dataset provides data.  If your dataset has data from 2020-10-10 10:21:10, set the start_date to 2020-10-10 or later
     */
    startDate: pulumi.Input<string>;
}

export interface SourceSenseforceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSenseforceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSenseforceResourceAllocationJobSpecific>[]>;
}

export interface SourceSenseforceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSenseforceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSenseforceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSenseforceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSentryConfiguration {
    /**
     * Log into Sentry and then <a href="https://sentry.io/settings/account/api/auth-tokens/">create authentication tokens</a>.For self-hosted, you can find or create authentication tokens by visiting "{instance_url_prefix}/settings/account/api/auth-tokens/"
     */
    authToken: pulumi.Input<string>;
    /**
     * Fields to retrieve when fetching discover events
     */
    discoverFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Host name of Sentry API server.For self-hosted, specify your host name here. Otherwise, leave it empty. Default: "sentry.io"
     */
    hostname?: pulumi.Input<string>;
    /**
     * The slug of the organization the groups belong to.
     */
    organization: pulumi.Input<string>;
    /**
     * The name (slug) of the Project you want to sync.
     */
    project: pulumi.Input<string>;
}

export interface SourceSentryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSentryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSentryResourceAllocationJobSpecific>[]>;
}

export interface SourceSentryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSentryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSentryResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSentryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSerpstatConfiguration {
    /**
     * Serpstat API key can be found here: https://serpstat.com/users/profile/
     */
    apiKey: pulumi.Input<string>;
    /**
     * The domain name to get data for (ex. serpstat.com). Default: "serpstat.com"
     */
    domain?: pulumi.Input<string>;
    /**
     * The list of domains that will be used in streams that support batch operations
     */
    domains?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The field name by which the results should be filtered. Filtering the results will result in fewer API credits spent. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    filterBy?: pulumi.Input<string>;
    /**
     * The value of the field to filter by. Each stream has different filtering options. See https://serpstat.com/api/ for more details.
     */
    filterValue?: pulumi.Input<string>;
    /**
     * The number of data rows per page to be returned. Each data row can contain multiple data points. The max value is 1000. Reducing the size of the page will result in fewer API credits spent. Default: 10
     */
    pageSize?: pulumi.Input<number>;
    /**
     * The number of pages that should be fetched. All results will be obtained if left blank. Reducing the number of pages will result in fewer API credits spent. Default: 1
     */
    pagesToFetch?: pulumi.Input<number>;
    /**
     * The ID of a region to get data from in the form of a two-letter country code prepended with the g_ prefix. See the list of supported region IDs here: https://serpstat.com/api/664-request-parameters-v4/. Default: "g_us"
     */
    regionId?: pulumi.Input<string>;
    /**
     * The field name by which the results should be sorted. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    sortBy?: pulumi.Input<string>;
    /**
     * The value of the field to sort by. Each stream has different sorting options. See https://serpstat.com/api/ for more details.
     */
    sortValue?: pulumi.Input<string>;
}

export interface SourceSerpstatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSerpstatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSerpstatResourceAllocationJobSpecific>[]>;
}

export interface SourceSerpstatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSerpstatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSerpstatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSerpstatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceServiceNowConfiguration {
    baseUrl: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceServiceNowResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceServiceNowResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceServiceNowResourceAllocationJobSpecific>[]>;
}

export interface SourceServiceNowResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceServiceNowResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceServiceNowResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceServiceNowResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSftpBulkConfiguration {
    /**
     * Credentials for connecting to the SFTP Server
     */
    credentials: pulumi.Input<inputs.SourceSftpBulkConfigurationCredentials>;
    deliveryMethod?: pulumi.Input<inputs.SourceSftpBulkConfigurationDeliveryMethod>;
    /**
     * The directory to search files for sync. Default: "/"
     */
    folderPath?: pulumi.Input<string>;
    /**
     * The server host address
     */
    host: pulumi.Input<string>;
    /**
     * The server port. Default: 22
     */
    port?: pulumi.Input<number>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceSftpBulkConfigurationStream>[]>;
    /**
     * The server user
     */
    username: pulumi.Input<string>;
}

export interface SourceSftpBulkConfigurationCredentials {
    authenticateViaPassword?: pulumi.Input<inputs.SourceSftpBulkConfigurationCredentialsAuthenticateViaPassword>;
    authenticateViaPrivateKey?: pulumi.Input<inputs.SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey>;
}

export interface SourceSftpBulkConfigurationCredentialsAuthenticateViaPassword {
    /**
     * Password
     */
    password: pulumi.Input<string>;
}

export interface SourceSftpBulkConfigurationCredentialsAuthenticateViaPrivateKey {
    /**
     * The Private key
     */
    privateKey: pulumi.Input<string>;
}

export interface SourceSftpBulkConfigurationDeliveryMethod {
    /**
     * Copy raw files without parsing their contents. Bits are copied into the destination exactly as they appeared in the source. Recommended for use with unstructured text data, non-text and compressed files.
     */
    copyRawFiles?: pulumi.Input<inputs.SourceSftpBulkConfigurationDeliveryMethodCopyRawFiles>;
    /**
     * Recommended - Extract and load structured records into your destination of choice. This is the classic method of moving data in Airbyte. It allows for blocking and hashing individual fields or files from a structured schema. Data can be flattened, typed and deduped depending on the destination.
     */
    replicateRecords?: pulumi.Input<inputs.SourceSftpBulkConfigurationDeliveryMethodReplicateRecords>;
}

export interface SourceSftpBulkConfigurationDeliveryMethodCopyRawFiles {
    /**
     * If enabled, sends subdirectory folder structure along with source file names to the destination. Otherwise, files will be synced by their names only. This option is ignored when file-based replication is not enabled. Default: true
     */
    preserveDirectoryStructure?: pulumi.Input<boolean>;
}

export interface SourceSftpBulkConfigurationDeliveryMethodReplicateRecords {
}

export interface SourceSftpBulkConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * The number of resent files which will be used to discover the schema for this stream.
     */
    recentNFilesToReadForSchemaDiscovery?: pulumi.Input<number>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceSftpBulkConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatCsvFormat>;
    excelFormat?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatExcelFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceSftpBulkConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceSftpBulkConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceSftpBulkConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceSftpBulkConfigurationStreamFormatExcelFormat {
}

export interface SourceSftpBulkConfigurationStreamFormatJsonlFormat {
}

export interface SourceSftpBulkConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
    /**
     * Process files via an API, using the `hi_res` mode. This option is useful for increased performance and accuracy, but requires an API key and a hosted instance of unstructured.
     */
    viaApi?: pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApi>;
}

export interface SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApi {
    /**
     * The API key to use matching the environment. Default: ""
     */
    apiKey?: pulumi.Input<string>;
    /**
     * The URL of the unstructured API to use. Default: "https://api.unstructured.io"
     */
    apiUrl?: pulumi.Input<string>;
    /**
     * List of parameters send to the API
     */
    parameters?: pulumi.Input<pulumi.Input<inputs.SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApiParameter>[]>;
}

export interface SourceSftpBulkConfigurationStreamFormatUnstructuredDocumentFormatProcessingViaApiParameter {
    /**
     * The name of the unstructured API parameter to use
     */
    name: pulumi.Input<string>;
    /**
     * The value of the parameter
     */
    value: pulumi.Input<string>;
}

export interface SourceSftpBulkResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSftpBulkResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSftpBulkResourceAllocationJobSpecific>[]>;
}

export interface SourceSftpBulkResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSftpBulkResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSftpBulkResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSftpBulkResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSftpConfiguration {
    /**
     * The server authentication method
     */
    credentials?: pulumi.Input<inputs.SourceSftpConfigurationCredentials>;
    /**
     * The regular expression to specify files for sync in a chosen Folder Path. Default: ""
     */
    filePattern?: pulumi.Input<string>;
    /**
     * Coma separated file types. Currently only 'csv' and 'json' types are supported. Default: "csv,json"
     */
    fileTypes?: pulumi.Input<string>;
    /**
     * The directory to search files for sync. Default: ""
     */
    folderPath?: pulumi.Input<string>;
    /**
     * The server host address
     */
    host: pulumi.Input<string>;
    /**
     * The server port. Default: 22
     */
    port?: pulumi.Input<number>;
    /**
     * The server user
     */
    user: pulumi.Input<string>;
}

export interface SourceSftpConfigurationCredentials {
    passwordAuthentication?: pulumi.Input<inputs.SourceSftpConfigurationCredentialsPasswordAuthentication>;
    sshKeyAuthentication?: pulumi.Input<inputs.SourceSftpConfigurationCredentialsSshKeyAuthentication>;
}

export interface SourceSftpConfigurationCredentialsPasswordAuthentication {
    /**
     * OS-level password for logging into the jump server host
     */
    authUserPassword: pulumi.Input<string>;
}

export interface SourceSftpConfigurationCredentialsSshKeyAuthentication {
    /**
     * OS-level user account ssh key credentials in RSA PEM format ( created with ssh-keygen -t rsa -m PEM -f myuser_rsa )
     */
    authSshKey: pulumi.Input<string>;
}

export interface SourceSftpResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSftpResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSftpResourceAllocationJobSpecific>[]>;
}

export interface SourceSftpResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSftpResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSftpResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSftpResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSharepointEnterpriseConfiguration {
    /**
     * Credentials for connecting to the One Drive API
     */
    credentials: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationCredentials>;
    deliveryMethod?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationDeliveryMethod>;
    /**
     * Path to a specific folder within the drives to search for files. Leave empty to search all folders of the drives. This does not apply to shared items. Default: "."
     */
    folderPath?: pulumi.Input<string>;
    /**
     * Specifies the location(s) to search for files. Valid options are 'ACCESSIBLE_DRIVES' for all SharePoint drives the user can access, 'SHARED_ITEMS' for shared items the user has access to, and 'ALL' to search both. Default: "ALL"; must be one of ["ACCESSIBLE_DRIVES", "SHARED_ITEMS", "ALL"]
     */
    searchScope?: pulumi.Input<string>;
    /**
     * Url of SharePoint site to search for files. Leave empty to search in the main site. Use 'https://<tenant_name>.sharepoint.com/sites/' to iterate over all sites. Default: ""
     */
    siteUrl?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00.000000Z. Any file modified before this date will not be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Each instance of this configuration defines a <a href="https://docs.airbyte.com/cloud/core-concepts#stream">stream</a>. Use this to define which files belong in the stream, their format, and how they should be parsed and validated. When sending data to warehouse destination such as Snowflake or BigQuery, each stream is a separate table.
     */
    streams: pulumi.Input<pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStream>[]>;
}

export interface SourceSharepointEnterpriseConfigurationCredentials {
    /**
     * OAuthCredentials class to hold authentication details for Microsoft OAuth authentication.
     * This class uses pydantic for data validation and settings management.
     */
    authenticateViaMicrosoftOAuth?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationCredentialsAuthenticateViaMicrosoftOAuth>;
    /**
     * ServiceCredentials class for service key authentication.
     * This class is structured similarly to OAuthCredentials but for a different authentication method.
     */
    serviceKeyAuthentication?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationCredentialsServiceKeyAuthentication>;
}

export interface SourceSharepointEnterpriseConfigurationCredentialsAuthenticateViaMicrosoftOAuth {
    /**
     * Client ID of your Microsoft developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token of your Microsoft developer application
     */
    refreshToken?: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft SharePoint user
     */
    tenantId: pulumi.Input<string>;
}

export interface SourceSharepointEnterpriseConfigurationCredentialsServiceKeyAuthentication {
    /**
     * Client ID of your Microsoft developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * Client Secret of your Microsoft developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Tenant ID of the Microsoft SharePoint user
     */
    tenantId: pulumi.Input<string>;
    /**
     * Special characters such as a period, comma, space, and the at sign (@) are converted to underscores (_). More details: https://learn.microsoft.com/en-us/sharepoint/list-onedrive-urls
     */
    userPrincipalName: pulumi.Input<string>;
}

export interface SourceSharepointEnterpriseConfigurationDeliveryMethod {
    /**
     * Copy raw files without parsing their contents. Bits are copied into the destination exactly as they appeared in the source. Recommended for use with unstructured text data, non-text and compressed files.
     */
    copyRawFiles?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationDeliveryMethodCopyRawFiles>;
    /**
     * Sends one identity stream and one for more permissions (ACL) streams to the destination. This data can be used in downstream systems to recreate permission restrictions mirroring the original source.
     */
    replicatePermissionsAcl?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationDeliveryMethodReplicatePermissionsAcl>;
    /**
     * Recommended - Extract and load structured records into your destination of choice. This is the classic method of moving data in Airbyte. It allows for blocking and hashing individual fields or files from a structured schema. Data can be flattened, typed and deduped depending on the destination.
     */
    replicateRecords?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationDeliveryMethodReplicateRecords>;
}

export interface SourceSharepointEnterpriseConfigurationDeliveryMethodCopyRawFiles {
    /**
     * If enabled, sends subdirectory folder structure along with source file names to the destination. Otherwise, files will be synced by their names only. This option is ignored when file-based replication is not enabled. Default: true
     */
    preserveDirectoryStructure?: pulumi.Input<boolean>;
}

export interface SourceSharepointEnterpriseConfigurationDeliveryMethodReplicatePermissionsAcl {
    /**
     * This data can be used in downstream systems to recreate permission restrictions mirroring the original source. Default: true
     */
    includeIdentitiesStream?: pulumi.Input<boolean>;
}

export interface SourceSharepointEnterpriseConfigurationDeliveryMethodReplicateRecords {
}

export interface SourceSharepointEnterpriseConfigurationStream {
    /**
     * When the state history of the file store is full, syncs will only read files that were last modified in the provided day range. Default: 3
     */
    daysToSyncIfHistoryIsFull?: pulumi.Input<number>;
    /**
     * The configuration options that are used to alter how to read incoming files that deviate from the standard formatting.
     */
    format: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormat>;
    /**
     * The pattern used to specify which files should be selected from the file system. For more information on glob pattern matching look <a href="https://en.wikipedia.org/wiki/Glob_(programming)">here</a>.
     */
    globs?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The schema that will be used to validate records extracted from the file. This will override the stream schema that is auto-detected from incoming files.
     */
    inputSchema?: pulumi.Input<string>;
    /**
     * The name of the stream.
     */
    name: pulumi.Input<string>;
    /**
     * The number of resent files which will be used to discover the schema for this stream.
     */
    recentNFilesToReadForSchemaDiscovery?: pulumi.Input<number>;
    /**
     * When enabled, syncs will not validate or structure records against the stream's schema. Default: false
     */
    schemaless?: pulumi.Input<boolean>;
    /**
     * The name of the validation policy that dictates sync behavior when a record does not adhere to the stream schema. Default: "Emit Record"; must be one of ["Emit Record", "Skip Record", "Wait for Discover"]
     */
    validationPolicy?: pulumi.Input<string>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormat {
    avroFormat?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatAvroFormat>;
    csvFormat?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatCsvFormat>;
    excelFormat?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatExcelFormat>;
    jsonlFormat?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatJsonlFormat>;
    parquetFormat?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatParquetFormat>;
    /**
     * Extract text from document formats (.pdf, .docx, .md, .pptx) and emit as one record per file.
     */
    unstructuredDocumentFormat?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatUnstructuredDocumentFormat>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatAvroFormat {
    /**
     * Whether to convert double fields to strings. This is recommended if you have decimal numbers with a high degree of precision because there can be a loss precision when handling floating point numbers. Default: false
     */
    doubleAsString?: pulumi.Input<boolean>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatCsvFormat {
    /**
     * The character delimiting individual cells in the CSV data. This may only be a 1-character string. For tab-delimited data enter '\t'. Default: ","
     */
    delimiter?: pulumi.Input<string>;
    /**
     * Whether two quotes in a quoted CSV value denote a single quote in the data. Default: true
     */
    doubleQuote?: pulumi.Input<boolean>;
    /**
     * The character encoding of the CSV data. Leave blank to default to <strong>UTF8</strong>. See <a href="https://docs.python.org/3/library/codecs.html#standard-encodings" target="_blank">list of python encodings</a> for allowable options. Default: "utf8"
     */
    encoding?: pulumi.Input<string>;
    /**
     * The character used for escaping special characters. To disallow escaping, leave this field blank.
     */
    escapeChar?: pulumi.Input<string>;
    /**
     * A set of case-sensitive strings that should be interpreted as false values.
     */
    falseValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * How headers will be defined. `User Provided` assumes the CSV does not have a header row and uses the headers provided and `Autogenerated` assumes the CSV does not have a header row and the CDK will generate headers using for `f{i}` where `i` is the index starting from 0. Else, the default behavior is to use the header from the CSV file. If a user wants to autogenerate or provide column names for a CSV having headers, they can skip rows.
     */
    headerDefinition?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinition>;
    /**
     * Whether to ignore errors that occur when the number of fields in the CSV does not match the number of columns in the schema. Default: false
     */
    ignoreErrorsOnFieldsMismatch?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as null values. For example, if the value 'NA' should be interpreted as null, enter 'NA' in this field.
     */
    nullValues?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The character used for quoting CSV values. To disallow quoting, make this field blank. Default: "\""
     */
    quoteChar?: pulumi.Input<string>;
    /**
     * The number of rows to skip after the header row. Default: 0
     */
    skipRowsAfterHeader?: pulumi.Input<number>;
    /**
     * The number of rows to skip before the header row. For example, if the header row is on the 3rd row, enter 2 in this field. Default: 0
     */
    skipRowsBeforeHeader?: pulumi.Input<number>;
    /**
     * Whether strings can be interpreted as null values. If true, strings that match the null_values set will be interpreted as null. If false, strings that match the null_values set will be interpreted as the string itself. Default: true
     */
    stringsCanBeNull?: pulumi.Input<boolean>;
    /**
     * A set of case-sensitive strings that should be interpreted as true values.
     */
    trueValues?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinition {
    autogenerated?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated>;
    fromCsv?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv>;
    userProvided?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinitionAutogenerated {
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinitionFromCsv {
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatCsvFormatHeaderDefinitionUserProvided {
    /**
     * The column names that will be used while emitting the CSV records
     */
    columnNames: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatExcelFormat {
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatJsonlFormat {
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatParquetFormat {
    /**
     * Whether to convert decimal fields to floats. There is a loss of precision when converting decimals to floats, so this is not recommended. Default: false
     */
    decimalAsFloat?: pulumi.Input<boolean>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatUnstructuredDocumentFormat {
    /**
     * Processing configuration
     */
    processing?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatUnstructuredDocumentFormatProcessing>;
    /**
     * If true, skip files that cannot be parsed and pass the error message along as the _ab_source_file_parse_error field. If false, fail the sync. Default: true
     */
    skipUnprocessableFiles?: pulumi.Input<boolean>;
    /**
     * The strategy used to parse documents. `fast` extracts text directly from the document which doesn't work for all files. `ocr_only` is more reliable, but slower. `hi_res` is the most reliable, but requires an API key and a hosted instance of unstructured and can't be used with local mode. See the unstructured.io documentation for more details: https://unstructured-io.github.io/unstructured/core/partition.html#partition-pdf. Default: "auto"; must be one of ["auto", "fast", "ocr_only", "hi_res"]
     */
    strategy?: pulumi.Input<string>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatUnstructuredDocumentFormatProcessing {
    /**
     * Process files locally, supporting `fast` and `ocr` modes. This is the default option.
     */
    local?: pulumi.Input<inputs.SourceSharepointEnterpriseConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal>;
}

export interface SourceSharepointEnterpriseConfigurationStreamFormatUnstructuredDocumentFormatProcessingLocal {
}

export interface SourceSharepointEnterpriseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSharepointEnterpriseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSharepointEnterpriseResourceAllocationJobSpecific>[]>;
}

export interface SourceSharepointEnterpriseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSharepointEnterpriseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSharepointEnterpriseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSharepointEnterpriseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSharetribeConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The current access token. This field might be overridden by the connector based on the token refresh endpoint response.
     */
    oauthAccessToken?: pulumi.Input<string>;
    /**
     * The date the current access token expires in. This field might be overridden by the connector based on the token refresh endpoint response.
     */
    oauthTokenExpiryDate?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceSharetribeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSharetribeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSharetribeResourceAllocationJobSpecific>[]>;
}

export interface SourceSharetribeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSharetribeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSharetribeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSharetribeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShippoConfiguration {
    /**
     * The bearer token used for making requests
     */
    shippoToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceShippoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceShippoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceShippoResourceAllocationJobSpecific>[]>;
}

export interface SourceShippoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShippoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceShippoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceShippoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShipstationConfiguration {
    password?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceShipstationResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceShipstationResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceShipstationResourceAllocationJobSpecific>[]>;
}

export interface SourceShipstationResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShipstationResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceShipstationResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceShipstationResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShopifyConfiguration {
    /**
     * Defines what would be a date range per single BULK Job. Default: 30
     */
    bulkWindowInDays?: pulumi.Input<number>;
    /**
     * The authorization method to use to retrieve data from Shopify
     */
    credentials?: pulumi.Input<inputs.SourceShopifyConfigurationCredentials>;
    /**
     * Defines which API type (REST/BULK) to use to fetch `Transactions` data. If you are a `Shopify Plus` user, leave the default value to speed up the fetch. Default: false
     */
    fetchTransactionsUserId?: pulumi.Input<boolean>;
    /**
     * The threshold, after which the single BULK Job should be checkpointed (min: 15k, max: 1M). Default: 100000
     */
    jobCheckpointInterval?: pulumi.Input<number>;
    /**
     * If enabled, the `Product Variants` stream attempts to include `Presentment prices` field (may affect the performance). Default: true
     */
    jobProductVariantsIncludePresPrices?: pulumi.Input<boolean>;
    /**
     * The max time in seconds, after which the single BULK Job should be `CANCELED` and retried. The bigger the value the longer the BULK Job is allowed to run. Default: 7200
     */
    jobTerminationThreshold?: pulumi.Input<number>;
    /**
     * The name of your Shopify store found in the URL. For example, if your URL was https://NAME.myshopify.com, then the name would be 'NAME' or 'NAME.myshopify.com'.
     */
    shop: pulumi.Input<string>;
    /**
     * The date you would like to replicate data from. Format: YYYY-MM-DD. Any data before this date will not be replicated. Default: "2020-01-01"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceShopifyConfigurationCredentials {
    /**
     * API Password Auth
     */
    apiPassword?: pulumi.Input<inputs.SourceShopifyConfigurationCredentialsApiPassword>;
    /**
     * OAuth2.0
     */
    oAuth20?: pulumi.Input<inputs.SourceShopifyConfigurationCredentialsOAuth20>;
}

export interface SourceShopifyConfigurationCredentialsApiPassword {
    /**
     * The API Password for your private application in the `Shopify` store.
     */
    apiPassword: pulumi.Input<string>;
}

export interface SourceShopifyConfigurationCredentialsOAuth20 {
    /**
     * The Access Token for making authenticated requests.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The Client ID of the Shopify developer application.
     */
    clientId?: pulumi.Input<string>;
    /**
     * The Client Secret of the Shopify developer application.
     */
    clientSecret?: pulumi.Input<string>;
}

export interface SourceShopifyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceShopifyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceShopifyResourceAllocationJobSpecific>[]>;
}

export interface SourceShopifyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShopifyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceShopifyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceShopifyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShopwiredConfiguration {
    /**
     * Your API Key, which acts as the username for Basic Authentication. You can find it in your ShopWired account under API settings.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Your API Secret, which acts as the password for Basic Authentication. You can find it in your ShopWired account under API settings.
     */
    apiSecret: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceShopwiredResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceShopwiredResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceShopwiredResourceAllocationJobSpecific>[]>;
}

export interface SourceShopwiredResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShopwiredResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceShopwiredResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceShopwiredResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShortcutConfiguration {
    apiKey2: pulumi.Input<string>;
    /**
     * Query for searching as defined in `https://help.shortcut.com/hc/en-us/articles/360000046646-Searching-in-Shortcut-Using-Search-Operators`. Default: "title:Our first Epic"
     */
    query?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceShortcutResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceShortcutResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceShortcutResourceAllocationJobSpecific>[]>;
}

export interface SourceShortcutResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShortcutResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceShortcutResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceShortcutResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShortioConfiguration {
    domainId: pulumi.Input<string>;
    /**
     * Short.io Secret Key
     */
    secretKey: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceShortioResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceShortioResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceShortioResourceAllocationJobSpecific>[]>;
}

export interface SourceShortioResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShortioResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceShortioResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceShortioResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShutterstockConfiguration {
    /**
     * Your OAuth 2.0 token for accessing the Shutterstock API. Obtain this token from your Shutterstock developer account.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The query for image search. Default: "mountain"
     */
    queryForAudioSearch?: pulumi.Input<string>;
    /**
     * The query for catalog search. Default: "mountain"
     */
    queryForCatalogSearch?: pulumi.Input<string>;
    /**
     * The query for image search. Default: "mountain"
     */
    queryForImageSearch?: pulumi.Input<string>;
    /**
     * The Query for `videos_search` stream. Default: "mountain"
     */
    queryForVideoSearch?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceShutterstockResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceShutterstockResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceShutterstockResourceAllocationJobSpecific>[]>;
}

export interface SourceShutterstockResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceShutterstockResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceShutterstockResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceShutterstockResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSigmaComputingConfiguration {
    /**
     * The base url of your sigma organization
     */
    baseUrl: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The current access token. This field might be overridden by the connector based on the token refresh endpoint response.
     */
    oauthAccessToken?: pulumi.Input<string>;
    /**
     * The date the current access token expires in. This field might be overridden by the connector based on the token refresh endpoint response.
     */
    oauthTokenExpiryDate?: pulumi.Input<string>;
}

export interface SourceSigmaComputingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSigmaComputingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSigmaComputingResourceAllocationJobSpecific>[]>;
}

export interface SourceSigmaComputingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSigmaComputingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSigmaComputingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSigmaComputingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSignnowConfiguration {
    /**
     * Api key which could be found in API section after enlarging keys section
     */
    apiKeyId: pulumi.Input<string>;
    /**
     * The authorization token is needed for `signing_links` stream which could be seen from enlarged view of `https://app.signnow.com/webapp/api-dashboard/keys`
     */
    authToken: pulumi.Input<string>;
    /**
     * Name filter for documents stream
     */
    nameFilterForDocuments?: pulumi.Input<pulumi.Input<string>[]>;
    startDate: pulumi.Input<string>;
}

export interface SourceSignnowResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSignnowResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSignnowResourceAllocationJobSpecific>[]>;
}

export interface SourceSignnowResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSignnowResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSignnowResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSignnowResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSimfinConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceSimfinResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSimfinResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSimfinResourceAllocationJobSpecific>[]>;
}

export interface SourceSimfinResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSimfinResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSimfinResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSimfinResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSimplecastConfiguration {
    /**
     * API token to use. Find it at your Private Apps page on the Simplecast dashboard.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceSimplecastResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSimplecastResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSimplecastResourceAllocationJobSpecific>[]>;
}

export interface SourceSimplecastResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSimplecastResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSimplecastResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSimplecastResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSimplesatConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Date till when the sync should end
     */
    endDate?: pulumi.Input<string>;
    /**
     * Date from when the sync should start
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceSimplesatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSimplesatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSimplesatResourceAllocationJobSpecific>[]>;
}

export interface SourceSimplesatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSimplesatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSimplesatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSimplesatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSlackConfiguration {
    /**
     * A channel name list (without leading '#' char) which limit the channels from which you'd like to sync. Empty list means no filter.
     */
    channelFilters?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Choose how to authenticate into Slack
     */
    credentials?: pulumi.Input<inputs.SourceSlackConfigurationCredentials>;
    /**
     * Whether to read information from private channels that the bot is already in.  If false, only public channels will be read.  If true, the bot must be manually added to private channels. Default: false
     */
    includePrivateChannels?: pulumi.Input<boolean>;
    /**
     * Whether to join all channels or to sync data only from channels the bot is already in.  If false, you'll need to manually add the bot to all the channels from which you'd like to sync messages. Default: true
     */
    joinChannels?: pulumi.Input<boolean>;
    /**
     * How far into the past to look for messages in threads, default is 0 days. Default: 0
     */
    lookbackWindow?: pulumi.Input<number>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceSlackConfigurationCredentials {
    apiToken?: pulumi.Input<inputs.SourceSlackConfigurationCredentialsApiToken>;
    signInViaSlackOAuth?: pulumi.Input<inputs.SourceSlackConfigurationCredentialsSignInViaSlackOAuth>;
}

export interface SourceSlackConfigurationCredentialsApiToken {
    /**
     * A Slack bot token. See the <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> for instructions on how to generate it.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceSlackConfigurationCredentialsSignInViaSlackOAuth {
    /**
     * Slack access_token. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help generating the token.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Slack client_id. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this id.
     */
    clientId: pulumi.Input<string>;
    /**
     * Slack client_secret. See our <a href="https://docs.airbyte.com/integrations/sources/slack">docs</a> if you need help finding this secret.
     */
    clientSecret: pulumi.Input<string>;
}

export interface SourceSlackResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSlackResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSlackResourceAllocationJobSpecific>[]>;
}

export interface SourceSlackResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSlackResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSlackResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSlackResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmailyConfiguration {
    /**
     * API user password. See https://smaily.com/help/api/general/create-api-user/
     */
    apiPassword: pulumi.Input<string>;
    /**
     * API Subdomain. See https://smaily.com/help/api/general/create-api-user/
     */
    apiSubdomain: pulumi.Input<string>;
    /**
     * API user username. See https://smaily.com/help/api/general/create-api-user/
     */
    apiUsername: pulumi.Input<string>;
}

export interface SourceSmailyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSmailyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSmailyResourceAllocationJobSpecific>[]>;
}

export interface SourceSmailyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmailyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSmailyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSmailyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartengageConfiguration {
    /**
     * API Key
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSmartengageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSmartengageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSmartengageResourceAllocationJobSpecific>[]>;
}

export interface SourceSmartengageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartengageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSmartengageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSmartengageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartreachConfiguration {
    apiKey: pulumi.Input<string>;
    teamid: pulumi.Input<number>;
}

export interface SourceSmartreachResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSmartreachResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSmartreachResourceAllocationJobSpecific>[]>;
}

export interface SourceSmartreachResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartreachResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSmartreachResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSmartreachResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartsheetsConfiguration {
    credentials: pulumi.Input<inputs.SourceSmartsheetsConfigurationCredentials>;
    /**
     * If true, the source will treat the provided sheet_id as a report. If false, the source will treat the provided sheet_id as a sheet. Default: false
     */
    isReport?: pulumi.Input<boolean>;
    /**
     * A List of available columns which metadata can be pulled from.
     */
    metadataFields?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The spreadsheet ID. Find it by opening the spreadsheet then navigating to File > Properties
     */
    spreadsheetId: pulumi.Input<string>;
}

export interface SourceSmartsheetsConfigurationCredentials {
    apiAccessToken?: pulumi.Input<inputs.SourceSmartsheetsConfigurationCredentialsApiAccessToken>;
    oAuth20?: pulumi.Input<inputs.SourceSmartsheetsConfigurationCredentialsOAuth20>;
}

export interface SourceSmartsheetsConfigurationCredentialsApiAccessToken {
    /**
     * The access token to use for accessing your data from Smartsheets. This access token must be generated by a user with at least read access to the data you'd like to replicate. Generate an access token in the Smartsheets main menu by clicking Account > Apps & Integrations > API Access. See the <a href="https://docs.airbyte.com/integrations/sources/smartsheets/#setup-guide">setup guide</a> for information on how to obtain this token.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceSmartsheetsConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The API ID of the SmartSheets developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The API Secret the SmartSheets developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The key to refresh the expired access_token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The date-time when the access token should be refreshed.
     */
    tokenExpiryDate: pulumi.Input<string>;
}

export interface SourceSmartsheetsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSmartsheetsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSmartsheetsResourceAllocationJobSpecific>[]>;
}

export interface SourceSmartsheetsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartsheetsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSmartsheetsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSmartsheetsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartwaiverConfiguration {
    /**
     * You can retrieve your token by visiting your dashboard then click on My Account then click on API keys.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Default: "2017-01-24 13:12:29"
     */
    startDate?: pulumi.Input<string>;
    startDate2: pulumi.Input<string>;
}

export interface SourceSmartwaiverResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSmartwaiverResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSmartwaiverResourceAllocationJobSpecific>[]>;
}

export interface SourceSmartwaiverResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSmartwaiverResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSmartwaiverResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSmartwaiverResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSnapchatMarketingConfiguration {
    /**
     * Specifies the principle for conversion reporting. Default: "conversion"; must be one of ["conversion", "impression"]
     */
    actionReportTime?: pulumi.Input<string>;
    /**
     * Ad Account IDs of the ad accounts to retrieve
     */
    adAccountIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The Client ID of your Snapchat developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Snapchat developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Date in the format 2017-01-25. Any data after this date will not be replicated.
     */
    endDate?: pulumi.Input<string>;
    /**
     * The IDs of the organizations to retrieve
     */
    organizationIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Refresh Token to renew the expired Access Token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * Date in the format 2022-01-01. Any data before this date will not be replicated. Default: "2022-01-01"
     */
    startDate?: pulumi.Input<string>;
    /**
     * Attribution window for swipe ups. Default: "28_DAY"; must be one of ["1_DAY", "7_DAY", "28_DAY"]
     */
    swipeUpAttributionWindow?: pulumi.Input<string>;
    /**
     * Attribution window for views. Default: "1_DAY"; must be one of ["1_HOUR", "3_HOUR", "6_HOUR", "1_DAY", "7_DAY"]
     */
    viewAttributionWindow?: pulumi.Input<string>;
}

export interface SourceSnapchatMarketingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSnapchatMarketingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSnapchatMarketingResourceAllocationJobSpecific>[]>;
}

export interface SourceSnapchatMarketingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSnapchatMarketingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSnapchatMarketingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSnapchatMarketingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSnowflakeConfiguration {
    credentials?: pulumi.Input<inputs.SourceSnowflakeConfigurationCredentials>;
    /**
     * The database you created for Airbyte to access data.
     */
    database: pulumi.Input<string>;
    /**
     * The host domain of the snowflake instance (must include the account, region, cloud environment, and end with snowflakecomputing.com).
     */
    host: pulumi.Input<string>;
    /**
     * Additional properties to pass to the JDBC URL string when connecting to the database formatted as 'key=value' pairs separated by the symbol '&'. (example: key1=value1&key2=value2&key3=value3).
     */
    jdbcUrlParams?: pulumi.Input<string>;
    /**
     * The role you created for Airbyte to access Snowflake.
     */
    role: pulumi.Input<string>;
    /**
     * The source Snowflake schema tables. Leave empty to access tables from multiple schemas.
     */
    schema?: pulumi.Input<string>;
    /**
     * The warehouse you created for Airbyte to access data.
     */
    warehouse: pulumi.Input<string>;
}

export interface SourceSnowflakeConfigurationCredentials {
    keyPairAuthentication?: pulumi.Input<inputs.SourceSnowflakeConfigurationCredentialsKeyPairAuthentication>;
    oAuth20?: pulumi.Input<inputs.SourceSnowflakeConfigurationCredentialsOAuth20>;
    usernameAndPassword?: pulumi.Input<inputs.SourceSnowflakeConfigurationCredentialsUsernameAndPassword>;
}

export interface SourceSnowflakeConfigurationCredentialsKeyPairAuthentication {
    /**
     * RSA Private key to use for Snowflake connection. See the <a href="https://docs.airbyte.com/integrations/sources/snowflake#key-pair-authentication">docs</a> for more information on how to obtain this key.
     */
    privateKey: pulumi.Input<string>;
    /**
     * Passphrase for private key
     */
    privateKeyPassword?: pulumi.Input<string>;
    /**
     * The username you created to allow Airbyte to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceSnowflakeConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The Client ID of your Snowflake developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Snowflake developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Refresh Token for making authenticated requests.
     */
    refreshToken?: pulumi.Input<string>;
}

export interface SourceSnowflakeConfigurationCredentialsUsernameAndPassword {
    /**
     * The password associated with the username.
     */
    password: pulumi.Input<string>;
    /**
     * The username you created to allow Airbyte to access the database.
     */
    username: pulumi.Input<string>;
}

export interface SourceSnowflakeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSnowflakeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSnowflakeResourceAllocationJobSpecific>[]>;
}

export interface SourceSnowflakeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSnowflakeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSnowflakeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSnowflakeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSolarwindsServiceDeskConfiguration {
    /**
     * Refer to `https://documentation.solarwinds.com/en/success_center/swsd/content/completeguidetoswsd/token-authentication-for-api-integration.htm#link4`
     */
    apiKey2: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceSolarwindsServiceDeskResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSolarwindsServiceDeskResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSolarwindsServiceDeskResourceAllocationJobSpecific>[]>;
}

export interface SourceSolarwindsServiceDeskResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSolarwindsServiceDeskResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSolarwindsServiceDeskResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSolarwindsServiceDeskResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSonarCloudConfiguration {
    /**
     * Comma-separated list of component keys.
     */
    componentKeys: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * To retrieve issues created before the given date (inclusive).
     */
    endDate?: pulumi.Input<string>;
    /**
     * Organization key. See <a href="https://docs.sonarcloud.io/appendices/project-information/#project-and-organization-keys">here</a>.
     */
    organization: pulumi.Input<string>;
    /**
     * To retrieve issues created after the given date (inclusive).
     */
    startDate?: pulumi.Input<string>;
    /**
     * Your User Token. See <a href="https://docs.sonarcloud.io/advanced-setup/user-accounts/">here</a>. The token is case sensitive.
     */
    userToken: pulumi.Input<string>;
}

export interface SourceSonarCloudResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSonarCloudResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSonarCloudResourceAllocationJobSpecific>[]>;
}

export interface SourceSonarCloudResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSonarCloudResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSonarCloudResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSonarCloudResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSpacexApiConfiguration {
    id?: pulumi.Input<string>;
    options?: pulumi.Input<string>;
}

export interface SourceSpacexApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSpacexApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSpacexApiResourceAllocationJobSpecific>[]>;
}

export interface SourceSpacexApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSpacexApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSpacexApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSpacexApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSparkpostConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Default: "api"; must be one of ["api", "api.eu"]
     */
    apiPrefix?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceSparkpostResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSparkpostResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSparkpostResourceAllocationJobSpecific>[]>;
}

export interface SourceSparkpostResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSparkpostResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSparkpostResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSparkpostResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSplitIoConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceSplitIoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSplitIoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSplitIoResourceAllocationJobSpecific>[]>;
}

export interface SourceSplitIoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSplitIoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSplitIoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSplitIoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSpotlercrmConfiguration {
    /**
     * Access Token to authenticate API requests. Generate it by logging into your CRM system, navigating to Settings / Integrations / API V4, and clicking 'generate new key'.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceSpotlercrmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSpotlercrmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSpotlercrmResourceAllocationJobSpecific>[]>;
}

export interface SourceSpotlercrmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSpotlercrmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSpotlercrmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSpotlercrmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSquareConfiguration {
    /**
     * Choose how to authenticate to Square.
     */
    credentials?: pulumi.Input<inputs.SourceSquareConfigurationCredentials>;
    /**
     * In some streams there is an option to include deleted objects (Items, Categories, Discounts, Taxes). Default: false
     */
    includeDeletedObjects?: pulumi.Input<boolean>;
    /**
     * Determines whether to use the sandbox or production environment. Default: false
     */
    isSandbox?: pulumi.Input<boolean>;
    /**
     * UTC date in the format YYYY-MM-DD. Any data before this date will not be replicated. If not set, all data will be replicated. Default: "2021-01-01"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceSquareConfigurationCredentials {
    apiKey?: pulumi.Input<inputs.SourceSquareConfigurationCredentialsApiKey>;
    oauthAuthentication?: pulumi.Input<inputs.SourceSquareConfigurationCredentialsOauthAuthentication>;
}

export interface SourceSquareConfigurationCredentialsApiKey {
    /**
     * The API key for a Square application
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceSquareConfigurationCredentialsOauthAuthentication {
    /**
     * The Square-issued ID of your application
     */
    clientId: pulumi.Input<string>;
    /**
     * The Square-issued application secret for your application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * A refresh token generated using the above client ID and secret
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceSquareResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSquareResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSquareResourceAllocationJobSpecific>[]>;
}

export interface SourceSquareResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSquareResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSquareResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSquareResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSquarespaceConfiguration {
    /**
     * API key to use. Find it at https://developers.squarespace.com/commerce-apis/authentication-and-permissions
     */
    apiKey: pulumi.Input<string>;
    /**
     * Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceSquarespaceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSquarespaceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSquarespaceResourceAllocationJobSpecific>[]>;
}

export interface SourceSquarespaceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSquarespaceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSquarespaceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSquarespaceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStatsigConfiguration {
    apiKey: pulumi.Input<string>;
    endDate: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceStatsigResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceStatsigResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceStatsigResourceAllocationJobSpecific>[]>;
}

export interface SourceStatsigResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStatsigResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceStatsigResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceStatsigResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStatuspageConfiguration {
    /**
     * Your API Key. See <a href="https://developer.statuspage.io/#section/Authentication/api_key">here</a>.
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceStatuspageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceStatuspageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceStatuspageResourceAllocationJobSpecific>[]>;
}

export interface SourceStatuspageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStatuspageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceStatuspageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceStatuspageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStockdataConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Default: false
     */
    filterEntities?: pulumi.Input<boolean>;
    /**
     * Specify the industries of entities which have been identified within the article.
     */
    industries?: pulumi.Input<pulumi.Input<string>[]>;
    startDate: pulumi.Input<string>;
    symbols?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceStockdataResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceStockdataResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceStockdataResourceAllocationJobSpecific>[]>;
}

export interface SourceStockdataResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStockdataResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceStockdataResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceStockdataResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStravaConfiguration {
    /**
     * The Athlete ID of your Strava developer application.
     */
    athleteId: pulumi.Input<number>;
    /**
     * The Client ID of your Strava developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your Strava developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The Refresh Token with the activity: read_all permissions.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * UTC date and time. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceStravaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceStravaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceStravaResourceAllocationJobSpecific>[]>;
}

export interface SourceStravaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStravaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceStravaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceStravaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStripeConfiguration {
    /**
     * Your Stripe account ID (starts with 'acct_', find yours <a href="https://dashboard.stripe.com/settings/account">here</a>).
     */
    accountId: pulumi.Input<string>;
    /**
     * The number of API calls per second that you allow connector to make. This value can not be bigger than real API call rate limit (https://stripe.com/docs/rate-limits). If not specified the default maximum is 25 and 100 calls per second for test and production tokens respectively.
     */
    callRateLimit?: pulumi.Input<number>;
    /**
     * Stripe API key (usually starts with 'sk_live_'; find yours <a href="https://dashboard.stripe.com/apikeys">here</a>).
     */
    clientSecret: pulumi.Input<string>;
    /**
     * When set, the connector will always re-export data from the past N days, where N is the value set here. This is useful if your data is frequently updated after creation. The Lookback Window only applies to streams that do not support event-based incremental syncs: Events, SetupAttempts, ShippingRates, BalanceTransactions, Files, FileLinks, Refunds. More info <a href="https://docs.airbyte.com/integrations/sources/stripe#requirements">here</a>. Default: 0
     */
    lookbackWindowDays?: pulumi.Input<number>;
    /**
     * The number of worker thread to use for the sync. The performance upper boundary depends on call_rate_limit setting and type of account. Default: 10
     */
    numWorkers?: pulumi.Input<number>;
    /**
     * The time increment used by the connector when requesting data from the Stripe API. The bigger the value is, the less requests will be made and faster the sync will be. On the other hand, the more seldom the state is persisted. Default: 365
     */
    sliceRange?: pulumi.Input<number>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only data generated after this date will be replicated. Default: "2017-01-25T00:00:00Z"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceStripeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceStripeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceStripeResourceAllocationJobSpecific>[]>;
}

export interface SourceStripeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceStripeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceStripeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceStripeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSurveySparrowConfiguration {
    /**
     * Your access token. See <a href="https://developers.surveysparrow.com/rest-apis#authentication">here</a>. The key is case sensitive.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Is your account location is EU based? If yes, the base url to retrieve data will be different.
     */
    region?: pulumi.Input<inputs.SourceSurveySparrowConfigurationRegion>;
    /**
     * A List of your survey ids for survey-specific stream
     */
    surveyIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceSurveySparrowConfigurationRegion {
    euBasedAccount?: pulumi.Input<inputs.SourceSurveySparrowConfigurationRegionEuBasedAccount>;
    globalAccount?: pulumi.Input<inputs.SourceSurveySparrowConfigurationRegionGlobalAccount>;
}

export interface SourceSurveySparrowConfigurationRegionEuBasedAccount {
}

export interface SourceSurveySparrowConfigurationRegionGlobalAccount {
}

export interface SourceSurveySparrowResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSurveySparrowResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSurveySparrowResourceAllocationJobSpecific>[]>;
}

export interface SourceSurveySparrowResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSurveySparrowResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSurveySparrowResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSurveySparrowResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSurveymonkeyConfiguration {
    /**
     * The authorization method to use to retrieve data from SurveyMonkey
     */
    credentials: pulumi.Input<inputs.SourceSurveymonkeyConfigurationCredentials>;
    /**
     * Depending on the originating datacenter of the SurveyMonkey account, the API access URL may be different. Default: "USA"; must be one of ["USA", "Europe", "Canada"]
     */
    origin?: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
    /**
     * IDs of the surveys from which you'd like to replicate data. If left empty, data from all boards to which you have access will be replicated.
     */
    surveyIds?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceSurveymonkeyConfigurationCredentials {
    /**
     * Access Token for making authenticated requests. See the <a href="https://docs.airbyte.io/integrations/sources/surveymonkey">docs</a> for information on how to generate this key.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of the SurveyMonkey developer application.
     */
    clientId?: pulumi.Input<string>;
    /**
     * The Client Secret of the SurveyMonkey developer application.
     */
    clientSecret?: pulumi.Input<string>;
}

export interface SourceSurveymonkeyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSurveymonkeyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSurveymonkeyResourceAllocationJobSpecific>[]>;
}

export interface SourceSurveymonkeyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSurveymonkeyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSurveymonkeyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSurveymonkeyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSurvicateConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceSurvicateResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSurvicateResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSurvicateResourceAllocationJobSpecific>[]>;
}

export interface SourceSurvicateResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSurvicateResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSurvicateResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSurvicateResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSvixConfiguration {
    /**
     * API key or access token
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceSvixResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSvixResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSvixResourceAllocationJobSpecific>[]>;
}

export interface SourceSvixResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSvixResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSvixResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSvixResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSystemeConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceSystemeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceSystemeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceSystemeResourceAllocationJobSpecific>[]>;
}

export interface SourceSystemeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceSystemeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceSystemeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceSystemeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTaboolaConfiguration {
    /**
     * The ID associated with your taboola account
     */
    accountId: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
}

export interface SourceTaboolaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTaboolaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTaboolaResourceAllocationJobSpecific>[]>;
}

export interface SourceTaboolaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTaboolaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTaboolaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTaboolaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTavusConfiguration {
    /**
     * Your Tavus API key. You can find this in your Tavus account settings or API dashboard.
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceTavusResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTavusResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTavusResourceAllocationJobSpecific>[]>;
}

export interface SourceTavusResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTavusResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTavusResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTavusResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTeamtailorConfiguration {
    api: pulumi.Input<string>;
    /**
     * The version of the API
     */
    xApiVersion: pulumi.Input<string>;
}

export interface SourceTeamtailorResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTeamtailorResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTeamtailorResourceAllocationJobSpecific>[]>;
}

export interface SourceTeamtailorResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTeamtailorResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTeamtailorResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTeamtailorResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTeamworkConfiguration {
    password?: pulumi.Input<string>;
    /**
     * The teamwork site name appearing at the url
     */
    siteName: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceTeamworkResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTeamworkResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTeamworkResourceAllocationJobSpecific>[]>;
}

export interface SourceTeamworkResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTeamworkResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTeamworkResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTeamworkResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTempoConfiguration {
    /**
     * Tempo API Token. Go to Tempo>Settings, scroll down to Data Access and select API integration.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceTempoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTempoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTempoResourceAllocationJobSpecific>[]>;
}

export interface SourceTempoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTempoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTempoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTempoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTestrailConfiguration {
    /**
     * The unique domain name for accessing testrail
     */
    domainName: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface SourceTestrailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTestrailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTestrailResourceAllocationJobSpecific>[]>;
}

export interface SourceTestrailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTestrailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTestrailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTestrailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTheGuardianApiConfiguration {
    /**
     * Your API Key. See <a href="https://open-platform.theguardian.com/access/">here</a>. The key is case sensitive.
     */
    apiKey: pulumi.Input<string>;
    /**
     * (Optional) Use this to set the maximum date (YYYY-MM-DD) of the results. Results newer than the end_date will not be shown. Default is set to the current date (today) for incremental syncs.
     */
    endDate?: pulumi.Input<string>;
    /**
     * (Optional) The query (q) parameter filters the results to only those that include that search term. The q parameter supports AND, OR and NOT operators.
     */
    query?: pulumi.Input<string>;
    /**
     * (Optional) Use this to filter the results by a particular section. See <a href="https://content.guardianapis.com/sections?api-key=test">here</a> for a list of all sections, and <a href="https://open-platform.theguardian.com/documentation/section">here</a> for the sections endpoint documentation.
     */
    section?: pulumi.Input<string>;
    /**
     * Use this to set the minimum date (YYYY-MM-DD) of the results. Results older than the start_date will not be shown.
     */
    startDate: pulumi.Input<string>;
    /**
     * (Optional) A tag is a piece of data that is used by The Guardian to categorise content. Use this parameter to filter results by showing only the ones matching the entered tag. See <a href="https://content.guardianapis.com/tags?api-key=test">here</a> for a list of all tags, and <a href="https://open-platform.theguardian.com/documentation/tag">here</a> for the tags endpoint documentation.
     */
    tag?: pulumi.Input<string>;
}

export interface SourceTheGuardianApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTheGuardianApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTheGuardianApiResourceAllocationJobSpecific>[]>;
}

export interface SourceTheGuardianApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTheGuardianApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTheGuardianApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTheGuardianApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceThinkificConfiguration {
    /**
     * Your Thinkific API key for authentication.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The subdomain of your Thinkific URL (e.g., if your URL is example.thinkific.com, your subdomain is "example".
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceThinkificCoursesConfiguration {
    apiKey: pulumi.Input<string>;
    xAuthSubdomain: pulumi.Input<string>;
}

export interface SourceThinkificCoursesResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceThinkificCoursesResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceThinkificCoursesResourceAllocationJobSpecific>[]>;
}

export interface SourceThinkificCoursesResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceThinkificCoursesResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceThinkificCoursesResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceThinkificCoursesResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceThinkificResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceThinkificResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceThinkificResourceAllocationJobSpecific>[]>;
}

export interface SourceThinkificResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceThinkificResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceThinkificResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceThinkificResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTicketmasterConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceTicketmasterResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTicketmasterResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTicketmasterResourceAllocationJobSpecific>[]>;
}

export interface SourceTicketmasterResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTicketmasterResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTicketmasterResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTicketmasterResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTickettailorConfiguration {
    /**
     * API key to use. Find it at https://www.getdrip.com/user/edit
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceTickettailorResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTickettailorResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTickettailorResourceAllocationJobSpecific>[]>;
}

export interface SourceTickettailorResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTickettailorResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTickettailorResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTickettailorResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTiktokMarketingConfiguration {
    /**
     * The attribution window in days. Default: 3
     */
    attributionWindow?: pulumi.Input<number>;
    /**
     * Authentication method
     */
    credentials?: pulumi.Input<inputs.SourceTiktokMarketingConfigurationCredentials>;
    /**
     * The date until which you'd like to replicate data for all incremental streams, in the format YYYY-MM-DD. All data generated between start_date and this date will be replicated. Not setting this option will result in always syncing the data till the current date.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Set to active if you want to include deleted data in report based streams and Ads, Ad Groups and Campaign streams. Default: false
     */
    includeDeleted?: pulumi.Input<boolean>;
    /**
     * The Start Date in format: YYYY-MM-DD. Any data before this date will not be replicated. If this parameter is not set, all data will be replicated. Default: "2016-09-01"
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceTiktokMarketingConfigurationCredentials {
    oAuth20?: pulumi.Input<inputs.SourceTiktokMarketingConfigurationCredentialsOAuth20>;
    sandboxAccessToken?: pulumi.Input<inputs.SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken>;
}

export interface SourceTiktokMarketingConfigurationCredentialsOAuth20 {
    /**
     * Long-term Authorized Access Token.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Advertiser ID to filter reports and streams. Let this empty to retrieve all.
     */
    advertiserId?: pulumi.Input<string>;
    /**
     * The Developer Application App ID.
     */
    appId: pulumi.Input<string>;
    /**
     * The Developer Application Secret.
     */
    secret: pulumi.Input<string>;
}

export interface SourceTiktokMarketingConfigurationCredentialsSandboxAccessToken {
    /**
     * The long-term authorized access token.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Advertiser ID which generated for the developer's Sandbox application.
     */
    advertiserId: pulumi.Input<string>;
}

export interface SourceTiktokMarketingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTiktokMarketingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTiktokMarketingResourceAllocationJobSpecific>[]>;
}

export interface SourceTiktokMarketingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTiktokMarketingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTiktokMarketingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTiktokMarketingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTimelyConfiguration {
    /**
     * The Account ID for your Timely account
     */
    accountId: pulumi.Input<string>;
    /**
     * The Bearer Token for your Timely account
     */
    bearerToken: pulumi.Input<string>;
    /**
     * Earliest date from which you want to pull data from.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceTimelyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTimelyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTimelyResourceAllocationJobSpecific>[]>;
}

export interface SourceTimelyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTimelyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTimelyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTimelyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTinyemailConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceTinyemailResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTinyemailResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTinyemailResourceAllocationJobSpecific>[]>;
}

export interface SourceTinyemailResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTinyemailResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTinyemailResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTinyemailResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTmdbConfiguration {
    /**
     * API Key from tmdb account
     */
    apiKey: pulumi.Input<string>;
    /**
     * Language expressed in ISO 639-1 scheme, Mandate for required streams (Example en-US)
     */
    language: pulumi.Input<string>;
    /**
     * Target movie ID, Mandate for movie streams (Example is 550)
     */
    movieId: pulumi.Input<string>;
    /**
     * Target movie ID, Mandate for search streams
     */
    query: pulumi.Input<string>;
}

export interface SourceTmdbResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTmdbResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTmdbResourceAllocationJobSpecific>[]>;
}

export interface SourceTmdbResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTmdbResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTmdbResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTmdbResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTodoistConfiguration {
    /**
     * API authorization bearer token for authenticating the API
     */
    token: pulumi.Input<string>;
}

export interface SourceTodoistResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTodoistResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTodoistResourceAllocationJobSpecific>[]>;
}

export interface SourceTodoistResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTodoistResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTodoistResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTodoistResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTogglConfiguration {
    /**
     * Your API Token. See <a href="https://developers.track.toggl.com/docs/authentication">here</a>. The token is case sensitive.
     */
    apiToken: pulumi.Input<string>;
    /**
     * To retrieve time entries created before the given date (inclusive).
     */
    endDate: pulumi.Input<string>;
    /**
     * Your organization id. See <a href="https://developers.track.toggl.com/docs/organization">here</a>.
     */
    organizationId: pulumi.Input<number>;
    /**
     * To retrieve time entries created after the given date (inclusive).
     */
    startDate: pulumi.Input<string>;
    /**
     * Your workspace id. See <a href="https://developers.track.toggl.com/docs/workspaces">here</a>.
     */
    workspaceId: pulumi.Input<number>;
}

export interface SourceTogglResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTogglResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTogglResourceAllocationJobSpecific>[]>;
}

export interface SourceTogglResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTogglResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTogglResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTogglResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTrackPmsConfiguration {
    apiKey: pulumi.Input<string>;
    apiSecret?: pulumi.Input<string>;
    customerDomain: pulumi.Input<string>;
}

export interface SourceTrackPmsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTrackPmsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTrackPmsResourceAllocationJobSpecific>[]>;
}

export interface SourceTrackPmsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTrackPmsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTrackPmsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTrackPmsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTrelloConfiguration {
    /**
     * IDs of the boards to replicate data from. If left empty, data from all boards to which you have access will be replicated. Please note that this is not the 8-character ID in the board's shortLink (URL of the board). Rather, what is required here is the 24-character ID usually returned by the API
     */
    boardIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * Trello API key. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
     */
    key: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
    /**
     * Trello API token. See the <a href="https://developer.atlassian.com/cloud/trello/guides/rest-api/authorization/#using-basic-oauth">docs</a> for instructions on how to generate it.
     */
    token: pulumi.Input<string>;
}

export interface SourceTrelloResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTrelloResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTrelloResourceAllocationJobSpecific>[]>;
}

export interface SourceTrelloResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTrelloResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTrelloResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTrelloResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTremendousConfiguration {
    /**
     * API key to use. You can generate an API key through the Tremendous dashboard under Team Settings > Developers. Save the key once youâ€™ve generated it.
     */
    apiKey: pulumi.Input<string>;
    /**
     * must be one of ["api", "testflight"]
     */
    environment: pulumi.Input<string>;
}

export interface SourceTremendousResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTremendousResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTremendousResourceAllocationJobSpecific>[]>;
}

export interface SourceTremendousResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTremendousResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTremendousResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTremendousResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTrustpilotConfiguration {
    /**
     * The names of business units which shall be synchronized. Some streams e.g. configured_business_units or private_reviews use this configuration.
     */
    businessUnits: pulumi.Input<pulumi.Input<string>[]>;
    credentials: pulumi.Input<inputs.SourceTrustpilotConfigurationCredentials>;
    /**
     * For streams with sync. method incremental the start date time to be used
     */
    startDate: pulumi.Input<string>;
}

export interface SourceTrustpilotConfigurationCredentials {
    /**
     * The API key authentication method gives you access to only the streams which are part of the Public API. When you want to get streams available via the Consumer API (e.g. the private reviews) you need to use authentication method OAuth 2.0.
     */
    apiKey?: pulumi.Input<inputs.SourceTrustpilotConfigurationCredentialsApiKey>;
    oAuth20?: pulumi.Input<inputs.SourceTrustpilotConfigurationCredentialsOAuth20>;
}

export interface SourceTrustpilotConfigurationCredentialsApiKey {
    /**
     * The API key of the Trustpilot API application.
     */
    clientId: pulumi.Input<string>;
}

export interface SourceTrustpilotConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The API key of the Trustpilot API application. (represents the OAuth Client ID)
     */
    clientId: pulumi.Input<string>;
    /**
     * The Secret of the Trustpilot API application. (represents the OAuth Client Secret)
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The key to refresh the expired access_token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The date-time when the access token should be refreshed.
     */
    tokenExpiryDate: pulumi.Input<string>;
}

export interface SourceTrustpilotResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTrustpilotResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTrustpilotResourceAllocationJobSpecific>[]>;
}

export interface SourceTrustpilotResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTrustpilotResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTrustpilotResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTrustpilotResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTvmazeScheduleConfiguration {
    /**
     * Country code for domestic TV schedule retrieval.
     */
    domesticScheduleCountryCode: pulumi.Input<string>;
    /**
     * End date for TV schedule retrieval. May be in the future. Optional.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Start date for TV schedule retrieval. May be in the future.
     */
    startDate: pulumi.Input<string>;
    /**
     * ISO 3166-1 country code for web TV schedule retrieval. Leave blank for
     * all countries plus global web channels (e.g. Netflix). Alternatively,
     * set to 'global' for just global web channels.
     */
    webScheduleCountryCode?: pulumi.Input<string>;
}

export interface SourceTvmazeScheduleResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTvmazeScheduleResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTvmazeScheduleResourceAllocationJobSpecific>[]>;
}

export interface SourceTvmazeScheduleResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTvmazeScheduleResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTvmazeScheduleResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTvmazeScheduleResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwelveDataConfiguration {
    apiKey: pulumi.Input<string>;
    /**
     * Where instrument is traded
     */
    country?: pulumi.Input<string>;
    /**
     * Where instrument is traded
     */
    exchange?: pulumi.Input<string>;
    /**
     * Between two consecutive points in time series Supports: 1min, 5min, 15min, 30min, 45min, 1h, 2h, 4h, 1day, 1week, 1month. Default: "1day"; must be one of ["1min", "5min", "15min", "30min", "45min", "1h", "2h", "4h", "1day", "1week", "1month"]
     */
    interval?: pulumi.Input<string>;
    /**
     * Ticker of the instrument
     */
    symbol?: pulumi.Input<string>;
}

export interface SourceTwelveDataResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTwelveDataResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTwelveDataResourceAllocationJobSpecific>[]>;
}

export interface SourceTwelveDataResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwelveDataResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTwelveDataResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTwelveDataResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwilioConfiguration {
    /**
     * Twilio account SID
     */
    accountSid: pulumi.Input<string>;
    /**
     * Twilio Auth Token.
     */
    authToken: pulumi.Input<string>;
    /**
     * How far into the past to look for records. (in minutes). Default: 0
     */
    lookbackWindow?: pulumi.Input<number>;
    /**
     * UTC date and time in the format 2020-10-01T00:00:00Z. Any data before this date will not be replicated.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceTwilioResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTwilioResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTwilioResourceAllocationJobSpecific>[]>;
}

export interface SourceTwilioResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwilioResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTwilioResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTwilioResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwilioTaskrouterConfiguration {
    /**
     * Twilio Account ID
     */
    accountSid: pulumi.Input<string>;
    /**
     * Twilio Auth Token
     */
    authToken: pulumi.Input<string>;
}

export interface SourceTwilioTaskrouterResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTwilioTaskrouterResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTwilioTaskrouterResourceAllocationJobSpecific>[]>;
}

export interface SourceTwilioTaskrouterResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwilioTaskrouterResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTwilioTaskrouterResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTwilioTaskrouterResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwitterConfiguration {
    /**
     * App only Bearer Token. See the <a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0/bearer-tokens">docs</a> for more information on how to obtain this token.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The end date for retrieving tweets must be a minimum of 10 seconds prior to the request time.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Query for matching Tweets. You can learn how to build this query by reading <a href="https://developer.twitter.com/en/docs/twitter-api/tweets/search/integrate/build-a-query"> build a query guide </a>.
     */
    query: pulumi.Input<string>;
    /**
     * The start date for retrieving tweets cannot be more than 7 days in the past.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceTwitterResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTwitterResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTwitterResourceAllocationJobSpecific>[]>;
}

export interface SourceTwitterResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTwitterResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTwitterResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTwitterResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTyntecSmsConfiguration {
    /**
     * Your Tyntec API Key. See <a href="https://www.tyntec.com/docs/docs-center-sms-api-quick-start">here</a>
     */
    apiKey: pulumi.Input<string>;
    /**
     * The phone number of the SMS message sender (international).
     */
    from: pulumi.Input<string>;
    /**
     * The content of the SMS message to be sent.
     */
    message?: pulumi.Input<string>;
    /**
     * The phone number of the SMS message recipient (international).
     */
    to: pulumi.Input<string>;
}

export interface SourceTyntecSmsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTyntecSmsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTyntecSmsResourceAllocationJobSpecific>[]>;
}

export interface SourceTyntecSmsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTyntecSmsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTyntecSmsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTyntecSmsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTypeformConfiguration {
    credentials: pulumi.Input<inputs.SourceTypeformConfigurationCredentials>;
    /**
     * When this parameter is set, the connector will replicate data only from the input forms. Otherwise, all forms in your Typeform account will be replicated. You can find form IDs in your form URLs. For example, in the URL "https://mysite.typeform.com/to/u6nXL7" the form_id is u6nXL7. You can find form URLs on Share panel
     */
    formIds?: pulumi.Input<pulumi.Input<string>[]>;
    /**
     * The date from which you'd like to replicate data for Typeform API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceTypeformConfigurationCredentials {
    oAuth20?: pulumi.Input<inputs.SourceTypeformConfigurationCredentialsOAuth20>;
    privateToken?: pulumi.Input<inputs.SourceTypeformConfigurationCredentialsPrivateToken>;
}

export interface SourceTypeformConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of the Typeform developer application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret the Typeform developer application.
     */
    clientSecret: pulumi.Input<string>;
    /**
     * The key to refresh the expired access_token.
     */
    refreshToken: pulumi.Input<string>;
    /**
     * The date-time when the access token should be refreshed.
     */
    tokenExpiryDate: pulumi.Input<string>;
}

export interface SourceTypeformConfigurationCredentialsPrivateToken {
    /**
     * Log into your Typeform account and then generate a personal Access Token.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceTypeformResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceTypeformResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceTypeformResourceAllocationJobSpecific>[]>;
}

export interface SourceTypeformResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceTypeformResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceTypeformResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceTypeformResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUbidotsConfiguration {
    /**
     * API token to use for authentication. Obtain it from your Ubidots account.
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceUbidotsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceUbidotsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceUbidotsResourceAllocationJobSpecific>[]>;
}

export interface SourceUbidotsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUbidotsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceUbidotsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceUbidotsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUnleashConfiguration {
    /**
     * Your API Token (Server-Side SDK [Client]). See <a href="https://docs.getunleash.io/how-to/how-to-create-api-tokens/">here</a>. The token is case sensitive.
     */
    apiToken: pulumi.Input<string>;
    /**
     * Your API URL. No trailing slash. ex: https://unleash.host.com/api
     */
    apiUrl: pulumi.Input<string>;
    /**
     * Use this if you want to filter the API call for only one given project (can be used in addition to the "Feature Name Prefix" field). See <a href="https://docs.getunleash.io/reference/api/legacy/unleash/client/features#filter-feature-toggles">here</a>
     */
    nameprefix?: pulumi.Input<string>;
    /**
     * Use this if you want to filter the API call for only one given project (can be used in addition to the "Feature Name Prefix" field). See <a href="https://docs.getunleash.io/reference/api/legacy/unleash/client/features#filter-feature-toggles">here</a>
     */
    projectName?: pulumi.Input<string>;
}

export interface SourceUnleashResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceUnleashResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceUnleashResourceAllocationJobSpecific>[]>;
}

export interface SourceUnleashResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUnleashResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceUnleashResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceUnleashResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUppromoteConfiguration {
    /**
     * For developing your own custom integration with UpPromote, you can create an API key. This is available from Professional plan.  Simply go to Settings > Integration > API > Create API Key.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Data before this date will not be fetched.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceUppromoteResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceUppromoteResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceUppromoteResourceAllocationJobSpecific>[]>;
}

export interface SourceUppromoteResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUppromoteResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceUppromoteResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceUppromoteResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUsCensusConfiguration {
    /**
     * Your API Key. Get your key <a href="https://api.census.gov/data/key_signup.html">here</a>.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The query parameters portion of the GET request, without the api key
     */
    queryParams?: pulumi.Input<string>;
    /**
     * The path portion of the GET request
     */
    queryPath: pulumi.Input<string>;
}

export interface SourceUsCensusResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceUsCensusResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceUsCensusResourceAllocationJobSpecific>[]>;
}

export interface SourceUsCensusResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUsCensusResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceUsCensusResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceUsCensusResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUservoiceConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    subdomain: pulumi.Input<string>;
}

export interface SourceUservoiceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceUservoiceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceUservoiceResourceAllocationJobSpecific>[]>;
}

export interface SourceUservoiceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceUservoiceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceUservoiceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceUservoiceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVantageConfiguration {
    /**
     * Your API Access token. See <a href="https://vantage.readme.io/reference/authentication">here</a>.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceVantageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceVantageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceVantageResourceAllocationJobSpecific>[]>;
}

export interface SourceVantageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVantageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceVantageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceVantageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVeeqoConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceVeeqoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceVeeqoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceVeeqoResourceAllocationJobSpecific>[]>;
}

export interface SourceVeeqoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVeeqoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceVeeqoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceVeeqoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVercelConfiguration {
    /**
     * Access token to authenticate with the Vercel API. Create and manage tokens in your Vercel account settings.
     */
    accessToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceVercelResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceVercelResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceVercelResourceAllocationJobSpecific>[]>;
}

export interface SourceVercelResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVercelResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceVercelResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceVercelResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVismaEconomicConfiguration {
    /**
     * Identifier for the grant issued by an agreement
     */
    agreementGrantToken: pulumi.Input<string>;
    /**
     * Identification token for app accessing data
     */
    appSecretToken: pulumi.Input<string>;
}

export interface SourceVismaEconomicResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceVismaEconomicResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceVismaEconomicResourceAllocationJobSpecific>[]>;
}

export interface SourceVismaEconomicResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVismaEconomicResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceVismaEconomicResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceVismaEconomicResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVitallyConfiguration {
    /**
     * Basic Auth Header
     */
    basicAuthHeader?: pulumi.Input<string>;
    /**
     * Provide only the subdomain part, like https://{your-custom-subdomain}.rest.vitally.io/.  Keep empty if you don't have a subdomain.
     */
    domain: pulumi.Input<string>;
    /**
     * sk_live_secret_token
     */
    secretToken: pulumi.Input<string>;
    /**
     * Status of the Vitally accounts. One of the following values; active, churned, activeOrChurned. must be one of ["active", "churned", "activeOrChurned"]
     */
    status: pulumi.Input<string>;
}

export interface SourceVitallyResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceVitallyResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceVitallyResourceAllocationJobSpecific>[]>;
}

export interface SourceVitallyResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVitallyResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceVitallyResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceVitallyResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVwoConfiguration {
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceVwoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceVwoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceVwoResourceAllocationJobSpecific>[]>;
}

export interface SourceVwoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceVwoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceVwoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceVwoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWaiteraidConfiguration {
    /**
     * Your WaiterAid API key, obtained from API request with Username and Password
     */
    authHash: pulumi.Input<string>;
    /**
     * Your WaiterAid restaurant id from API request to getRestaurants
     */
    restid: pulumi.Input<string>;
    /**
     * Start getting data from that date.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceWaiteraidResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWaiteraidResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWaiteraidResourceAllocationJobSpecific>[]>;
}

export interface SourceWaiteraidResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWaiteraidResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWaiteraidResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWaiteraidResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWasabiStatsApiConfiguration {
    /**
     * The API key format is `AccessKey:SecretKey`
     */
    apiKey: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceWasabiStatsApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWasabiStatsApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWasabiStatsApiResourceAllocationJobSpecific>[]>;
}

export interface SourceWasabiStatsApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWasabiStatsApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWasabiStatsApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWasabiStatsApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWatchmodeConfiguration {
    /**
     * Your API key for authenticating with the Watchmode API. You can request a free API key at https://api.watchmode.com/requestApiKey/.
     */
    apiKey: pulumi.Input<string>;
    /**
     * The name value for search stream. Default: "Terminator"
     */
    searchVal?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceWatchmodeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWatchmodeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWatchmodeResourceAllocationJobSpecific>[]>;
}

export interface SourceWatchmodeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWatchmodeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWatchmodeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWatchmodeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWeatherstackConfiguration {
    /**
     * API access key used to retrieve data from the Weatherstack API.(https://weatherstack.com/product)
     */
    accessKey: pulumi.Input<string>;
    /**
     * This is required for enabling the Historical date API with format- (YYYY-MM-DD). * Note, only supported by paid accounts
     */
    historicalDate: pulumi.Input<string>;
    /**
     * A location to query such as city, IP, latitudeLongitude, or zipcode. Multiple locations with semicolon seperated if using a professional plan or higher. For more info- (https://weatherstack.com/documentation#query_parameter)
     */
    query: pulumi.Input<string>;
}

export interface SourceWeatherstackResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWeatherstackResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWeatherstackResourceAllocationJobSpecific>[]>;
}

export interface SourceWeatherstackResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWeatherstackResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWeatherstackResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWeatherstackResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWebScrapperConfiguration {
    /**
     * API token to use. Find it at https://cloud.webscraper.io/api
     */
    apiToken: pulumi.Input<string>;
}

export interface SourceWebScrapperResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWebScrapperResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWebScrapperResourceAllocationJobSpecific>[]>;
}

export interface SourceWebScrapperResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWebScrapperResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWebScrapperResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWebScrapperResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWebflowConfiguration {
    /**
     * The version of the Webflow API to use. See https://developers.webflow.com/#versioning
     */
    acceptVersion?: pulumi.Input<string>;
    /**
     * The API token for authenticating to Webflow. See https://university.webflow.com/lesson/intro-to-the-webflow-api
     */
    apiKey: pulumi.Input<string>;
    /**
     * The id of the Webflow site you are requesting data from. See https://developers.webflow.com/#sites
     */
    siteId: pulumi.Input<string>;
}

export interface SourceWebflowResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWebflowResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWebflowResourceAllocationJobSpecific>[]>;
}

export interface SourceWebflowResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWebflowResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWebflowResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWebflowResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWhenIWorkConfiguration {
    /**
     * Email of your when-i-work account
     */
    email: pulumi.Input<string>;
    /**
     * Password for your when-i-work account
     */
    password: pulumi.Input<string>;
}

export interface SourceWhenIWorkResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWhenIWorkResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWhenIWorkResourceAllocationJobSpecific>[]>;
}

export interface SourceWhenIWorkResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWhenIWorkResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWhenIWorkResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWhenIWorkResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWhiskyHunterConfiguration {
}

export interface SourceWhiskyHunterResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWhiskyHunterResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWhiskyHunterResourceAllocationJobSpecific>[]>;
}

export interface SourceWhiskyHunterResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWhiskyHunterResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWhiskyHunterResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWhiskyHunterResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWikipediaPageviewsConfiguration {
    /**
     * If you want to filter by access method, use one of desktop, mobile-app or mobile-web. If you are interested in pageviews regardless of access method, use all-access.
     */
    access: pulumi.Input<string>;
    /**
     * If you want to filter by agent type, use one of user, automated or spider. If you are interested in pageviews regardless of agent type, use all-agents.
     */
    agent: pulumi.Input<string>;
    /**
     * The title of any article in the specified project. Any spaces should be replaced with underscores. It also should be URI-encoded, so that non-URI-safe characters like %, / or ? are accepted.
     */
    article: pulumi.Input<string>;
    /**
     * The ISO 3166-1 alpha-2 code of a country for which to retrieve top articles.
     */
    country: pulumi.Input<string>;
    /**
     * The date of the last day to include, in YYYYMMDD or YYYYMMDDHH format.
     */
    end: pulumi.Input<string>;
    /**
     * If you want to filter by project, use the domain of any Wikimedia project.
     */
    project: pulumi.Input<string>;
    /**
     * The date of the first day to include, in YYYYMMDD or YYYYMMDDHH format. Also serves as the date to retrieve data for the top articles.
     */
    start: pulumi.Input<string>;
}

export interface SourceWikipediaPageviewsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWikipediaPageviewsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWikipediaPageviewsResourceAllocationJobSpecific>[]>;
}

export interface SourceWikipediaPageviewsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWikipediaPageviewsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWikipediaPageviewsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWikipediaPageviewsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWoocommerceConfiguration {
    /**
     * Customer Key for API in WooCommerce shop
     */
    apiKey: pulumi.Input<string>;
    /**
     * Customer Secret for API in WooCommerce shop
     */
    apiSecret: pulumi.Input<string>;
    /**
     * The name of the store. For https://EXAMPLE.com, the shop name is 'EXAMPLE.com'.
     */
    shop: pulumi.Input<string>;
    /**
     * The date you would like to replicate data from. Format: YYYY-MM-DD
     */
    startDate: pulumi.Input<string>;
}

export interface SourceWoocommerceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWoocommerceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWoocommerceResourceAllocationJobSpecific>[]>;
}

export interface SourceWoocommerceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWoocommerceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWoocommerceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWoocommerceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWordpressConfiguration {
    /**
     * The domain of the WordPress site. Example: my-wordpress-website.host.com
     */
    domain: pulumi.Input<string>;
    /**
     * Placeholder for basic HTTP auth password - should be set to empty string. Default: "x"
     */
    password?: pulumi.Input<string>;
    /**
     * Minimal Date to Retrieve Records when stream allow incremental.
     */
    startDate: pulumi.Input<string>;
    /**
     * Placeholder for basic HTTP auth username - should be set to empty string. Default: "x"
     */
    username?: pulumi.Input<string>;
}

export interface SourceWordpressResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWordpressResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWordpressResourceAllocationJobSpecific>[]>;
}

export interface SourceWordpressResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWordpressResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWordpressResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWordpressResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkableConfiguration {
    /**
     * Your Workable account subdomain, e.g. https://your_account_subdomain.workable.com.
     */
    accountSubdomain: pulumi.Input<string>;
    /**
     * Your Workable API Key. See <a href="https://workable.readme.io/reference/generate-an-access-token">here</a>.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Get data that was created since this date (format: YYYYMMDDTHHMMSSZ).
     */
    startDate: pulumi.Input<string>;
}

export interface SourceWorkableResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWorkableResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWorkableResourceAllocationJobSpecific>[]>;
}

export interface SourceWorkableResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkableResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWorkableResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWorkableResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkdayConfiguration {
    /**
     * Report Based Streams and REST API Streams use different methods of Authentication. Choose streams type you want to sync and provide needed credentials for them.
     */
    credentials: pulumi.Input<inputs.SourceWorkdayConfigurationCredentials>;
    host: pulumi.Input<string>;
    tenantId: pulumi.Input<string>;
}

export interface SourceWorkdayConfigurationCredentials {
    reportBasedStreams?: pulumi.Input<inputs.SourceWorkdayConfigurationCredentialsReportBasedStreams>;
    restapiStreams?: pulumi.Input<inputs.SourceWorkdayConfigurationCredentialsRestapiStreams>;
}

export interface SourceWorkdayConfigurationCredentialsReportBasedStreams {
    password: pulumi.Input<string>;
    /**
     * Report IDs can be found by clicking the three dots on the right side of the report > Web Service > View URLs > in JSON url copy everything between Workday tenant/ and ?format=json.
     */
    reportIds: pulumi.Input<pulumi.Input<string>[]>;
    username: pulumi.Input<string>;
}

export interface SourceWorkdayConfigurationCredentialsRestapiStreams {
    /**
     * Follow the instructions in the "OAuth 2.0 in Postman - API Client for Integrations" article in the Workday community docs to obtain access token.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Rows after this date will be synced, default 2 years ago.
     */
    startDate?: pulumi.Input<string>;
}

export interface SourceWorkdayResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWorkdayResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWorkdayResourceAllocationJobSpecific>[]>;
}

export interface SourceWorkdayResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkdayResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWorkdayResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWorkdayResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkflowmaxConfiguration {
    /**
     * The account id for workflowmax
     */
    accountId: pulumi.Input<string>;
    apiKey2: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceWorkflowmaxResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWorkflowmaxResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWorkflowmaxResourceAllocationJobSpecific>[]>;
}

export interface SourceWorkflowmaxResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkflowmaxResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWorkflowmaxResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWorkflowmaxResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkrampConfiguration {
    /**
     * The id of the Academy
     */
    academyId: pulumi.Input<string>;
    /**
     * The API Token for Workramp
     */
    apiKey: pulumi.Input<string>;
}

export interface SourceWorkrampResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWorkrampResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWorkrampResourceAllocationJobSpecific>[]>;
}

export interface SourceWorkrampResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWorkrampResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWorkrampResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWorkrampResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWrikeConfiguration {
    /**
     * Permanent access token. You can find documentation on how to acquire a permanent access token  <a href="https://developers.wrike.com/oauth-20-authorization/">here</a>
     */
    accessToken: pulumi.Input<string>;
    /**
     * UTC date and time in the format 2017-01-25T00:00:00Z. Only comments after this date will be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * Wrike's instance such as `app-us2.wrike.com`. Default: "app-us2.wrike.com"
     */
    wrikeInstance?: pulumi.Input<string>;
}

export interface SourceWrikeResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWrikeResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWrikeResourceAllocationJobSpecific>[]>;
}

export interface SourceWrikeResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWrikeResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWrikeResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWrikeResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWufooConfiguration {
    /**
     * Your Wufoo API Key. You can find it by logging into your Wufoo account, selecting 'API Information' from the 'More' dropdown on any form, and locating the 16-digit code.
     */
    apiKey: pulumi.Input<string>;
    /**
     * Your account subdomain/username for Wufoo.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceWufooResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceWufooResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceWufooResourceAllocationJobSpecific>[]>;
}

export interface SourceWufooResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceWufooResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceWufooResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceWufooResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceXkcdConfiguration {
    /**
     * Specifies the comic number in which details are to be extracted, pagination will begin with that number to end of available comics. Default: "2960"
     */
    comicNumber?: pulumi.Input<string>;
}

export interface SourceXkcdResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceXkcdResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceXkcdResourceAllocationJobSpecific>[]>;
}

export interface SourceXkcdResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceXkcdResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceXkcdResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceXkcdResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceXsollaConfiguration {
    /**
     * Go to Xsolla Dashboard and from company setting get the api_key
     */
    apiKey: pulumi.Input<string>;
    /**
     * You can find this parameter in your Publisher Account next to the name of the project . Example: 44056
     */
    projectId: pulumi.Input<number>;
}

export interface SourceXsollaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceXsollaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceXsollaResourceAllocationJobSpecific>[]>;
}

export interface SourceXsollaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceXsollaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceXsollaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceXsollaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYahooFinancePriceConfiguration {
    /**
     * The interval of between prices queried. must be one of ["1m", "5m", "15m", "30m", "90m", "1h", "1d", "5d", "1wk", "1mo", "3mo"]
     */
    interval?: pulumi.Input<string>;
    /**
     * The range of prices to be queried. must be one of ["1d", "5d", "7d", "1mo", "3mo", "6mo", "1y", "2y", "5y", "ytd", "max"]
     */
    range?: pulumi.Input<string>;
    /**
     * Comma-separated identifiers for the stocks to be queried. Whitespaces are allowed.
     */
    tickers: pulumi.Input<string>;
}

export interface SourceYahooFinancePriceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYahooFinancePriceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYahooFinancePriceResourceAllocationJobSpecific>[]>;
}

export interface SourceYahooFinancePriceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYahooFinancePriceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYahooFinancePriceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYahooFinancePriceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYandexMetricaConfiguration {
    /**
     * Your Yandex Metrica API access token
     */
    authToken: pulumi.Input<string>;
    /**
     * Counter ID
     */
    counterId: pulumi.Input<string>;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DD". If not provided will sync till most recent date.
     */
    endDate?: pulumi.Input<string>;
    /**
     * Starting point for your data replication, in format of "YYYY-MM-DD".
     */
    startDate: pulumi.Input<string>;
}

export interface SourceYandexMetricaResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYandexMetricaResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYandexMetricaResourceAllocationJobSpecific>[]>;
}

export interface SourceYandexMetricaResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYandexMetricaResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYandexMetricaResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYandexMetricaResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYotpoConfiguration {
    /**
     * Access token recieved as a result of API call to https://api.yotpo.com/oauth/token (Ref- https://apidocs.yotpo.com/reference/yotpo-authentication)
     */
    accessToken: pulumi.Input<string>;
    /**
     * App key found at settings (Ref- https://settings.yotpo.com/#/general_settings)
     */
    appKey: pulumi.Input<string>;
    /**
     * Email address registered with yotpo. Default: "example@gmail.com"
     */
    email?: pulumi.Input<string>;
    /**
     * Date time filter for incremental filter, Specify which date to extract from.
     */
    startDate: pulumi.Input<string>;
}

export interface SourceYotpoResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYotpoResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYotpoResourceAllocationJobSpecific>[]>;
}

export interface SourceYotpoResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYotpoResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYotpoResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYotpoResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYouNeedABudgetYnabConfiguration {
    apiKey: pulumi.Input<string>;
}

export interface SourceYouNeedABudgetYnabResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYouNeedABudgetYnabResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYouNeedABudgetYnabResourceAllocationJobSpecific>[]>;
}

export interface SourceYouNeedABudgetYnabResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYouNeedABudgetYnabResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYouNeedABudgetYnabResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYouNeedABudgetYnabResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYouniumConfiguration {
    /**
     * Legal Entity that data should be pulled from
     */
    legalEntity: pulumi.Input<string>;
    /**
     * Account password for younium account API key
     */
    password: pulumi.Input<string>;
    /**
     * Property defining if connector is used against playground or production environment. Default: false
     */
    playground?: pulumi.Input<boolean>;
    /**
     * Username for Younium account
     */
    username: pulumi.Input<string>;
}

export interface SourceYouniumResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYouniumResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYouniumResourceAllocationJobSpecific>[]>;
}

export interface SourceYouniumResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYouniumResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYouniumResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYouniumResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYousignConfiguration {
    /**
     * API key or access token
     */
    apiKey: pulumi.Input<string>;
    /**
     * Limit for each response objects. Default: "10"
     */
    limit?: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
    /**
     * The subdomain for the Yousign API environment, such as 'sandbox' or 'api'. Default: "api"; must be one of ["api-sandbox", "api"]
     */
    subdomain?: pulumi.Input<string>;
}

export interface SourceYousignResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYousignResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYousignResourceAllocationJobSpecific>[]>;
}

export interface SourceYousignResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYousignResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYousignResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYousignResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYoutubeAnalyticsConfiguration {
    credentials: pulumi.Input<inputs.SourceYoutubeAnalyticsConfigurationCredentials>;
}

export interface SourceYoutubeAnalyticsConfigurationCredentials {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The Client ID of your developer application
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret of your developer application
     */
    clientSecret: pulumi.Input<string>;
    /**
     * A refresh token generated using the above client ID and secret
     */
    refreshToken: pulumi.Input<string>;
}

export interface SourceYoutubeAnalyticsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYoutubeAnalyticsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYoutubeAnalyticsResourceAllocationJobSpecific>[]>;
}

export interface SourceYoutubeAnalyticsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYoutubeAnalyticsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYoutubeAnalyticsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYoutubeAnalyticsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYoutubeDataConfiguration {
    apiKey: pulumi.Input<string>;
    channelIds: pulumi.Input<pulumi.Input<string>[]>;
}

export interface SourceYoutubeDataResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceYoutubeDataResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceYoutubeDataResourceAllocationJobSpecific>[]>;
}

export interface SourceYoutubeDataResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceYoutubeDataResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceYoutubeDataResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceYoutubeDataResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZapierSupportedStorageConfiguration {
    /**
     * Secret key supplied by zapier
     */
    secret: pulumi.Input<string>;
}

export interface SourceZapierSupportedStorageResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZapierSupportedStorageResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZapierSupportedStorageResourceAllocationJobSpecific>[]>;
}

export interface SourceZapierSupportedStorageResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZapierSupportedStorageResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZapierSupportedStorageResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZapierSupportedStorageResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZapsignConfiguration {
    /**
     * Your static API token for authentication. You can find it in your ZapSign account under the 'Settings' or 'API' section. For more details, refer to the [Getting Started](https://docs.zapsign.com.br/english/getting-started#how-do-i-get-my-api-token) guide.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The signer ids for signer stream
     */
    signerIds?: pulumi.Input<pulumi.Input<string>[]>;
    startDate: pulumi.Input<string>;
}

export interface SourceZapsignResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZapsignResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZapsignResourceAllocationJobSpecific>[]>;
}

export interface SourceZapsignResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZapsignResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZapsignResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZapsignResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskChatConfiguration {
    credentials?: pulumi.Input<inputs.SourceZendeskChatConfigurationCredentials>;
    /**
     * The date from which you'd like to replicate data for Zendesk Chat API, in the format YYYY-MM-DDT00:00:00Z.
     */
    startDate: pulumi.Input<string>;
    /**
     * The unique subdomain of your Zendesk account (without https://). <a href=\"https://support.zendesk.com/hc/en-us/articles/4409381383578-Where-can-I-find-my-Zendesk-subdomain\">See the Zendesk docs to find your subdomain</a>.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceZendeskChatConfigurationCredentials {
    accessToken?: pulumi.Input<inputs.SourceZendeskChatConfigurationCredentialsAccessToken>;
    oAuth20?: pulumi.Input<inputs.SourceZendeskChatConfigurationCredentialsOAuth20>;
}

export interface SourceZendeskChatConfigurationCredentialsAccessToken {
    /**
     * The Access Token to make authenticated requests.
     */
    accessToken: pulumi.Input<string>;
}

export interface SourceZendeskChatConfigurationCredentialsOAuth20 {
    /**
     * Access Token for making authenticated requests.
     */
    accessToken?: pulumi.Input<string>;
    /**
     * The Client ID of your OAuth application
     */
    clientId?: pulumi.Input<string>;
    /**
     * The Client Secret of your OAuth application.
     */
    clientSecret?: pulumi.Input<string>;
    /**
     * Refresh Token to obtain new Access Token, when it's expired.
     */
    refreshToken?: pulumi.Input<string>;
}

export interface SourceZendeskChatResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZendeskChatResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZendeskChatResourceAllocationJobSpecific>[]>;
}

export interface SourceZendeskChatResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskChatResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZendeskChatResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZendeskChatResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskSunshineConfiguration {
    credentials?: pulumi.Input<inputs.SourceZendeskSunshineConfigurationCredentials>;
    /**
     * The date from which you'd like to replicate data for Zendesk Sunshine API, in the format YYYY-MM-DDT00:00:00Z.
     */
    startDate: pulumi.Input<string>;
    /**
     * The subdomain for your Zendesk Account.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceZendeskSunshineConfigurationCredentials {
    apiToken?: pulumi.Input<inputs.SourceZendeskSunshineConfigurationCredentialsApiToken>;
    oAuth20?: pulumi.Input<inputs.SourceZendeskSunshineConfigurationCredentialsOAuth20>;
}

export interface SourceZendeskSunshineConfigurationCredentialsApiToken {
    /**
     * API Token. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk_sunshine">docs</a> for information on how to generate this key.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The user email for your Zendesk account
     */
    email: pulumi.Input<string>;
}

export interface SourceZendeskSunshineConfigurationCredentialsOAuth20 {
    /**
     * Long-term access Token for making authenticated requests.
     */
    accessToken: pulumi.Input<string>;
    /**
     * The Client ID of your OAuth application.
     */
    clientId: pulumi.Input<string>;
    /**
     * The Client Secret of your OAuth application.
     */
    clientSecret: pulumi.Input<string>;
}

export interface SourceZendeskSunshineResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZendeskSunshineResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZendeskSunshineResourceAllocationJobSpecific>[]>;
}

export interface SourceZendeskSunshineResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskSunshineResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZendeskSunshineResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZendeskSunshineResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskSupportConfiguration {
    /**
     * Zendesk allows two authentication methods. We recommend using `OAuth2.0` for Airbyte Cloud users and `API token` for Airbyte Open Source users.
     */
    credentials?: pulumi.Input<inputs.SourceZendeskSupportConfigurationCredentials>;
    /**
     * The number of worker threads to use for the sync. The performance upper boundary is based on the limit of your Zendesk Support plan. More info about the rate limit plan tiers can be found on Zendesk's API <a href="https://developer.zendesk.com/api-reference/introduction/rate-limits/#zendesk-support-plan-limits">docs</a>. Default: 3
     */
    numWorkers?: pulumi.Input<number>;
    /**
     * The UTC date and time from which you'd like to replicate data, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate?: pulumi.Input<string>;
    /**
     * This is your unique Zendesk subdomain that can be found in your account URL. For example, in https://MY_SUBDOMAIN.zendesk.com/, MY_SUBDOMAIN is the value of your subdomain.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceZendeskSupportConfigurationCredentials {
    apiToken?: pulumi.Input<inputs.SourceZendeskSupportConfigurationCredentialsApiToken>;
    oAuth20?: pulumi.Input<inputs.SourceZendeskSupportConfigurationCredentialsOAuth20>;
}

export interface SourceZendeskSupportConfigurationCredentialsApiToken {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The value of the API token generated. See our <a href="https://docs.airbyte.com/integrations/sources/zendesk-support#setup-guide">full documentation</a> for more information on generating this token.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The user email for your Zendesk account.
     */
    email: pulumi.Input<string>;
}

export interface SourceZendeskSupportConfigurationCredentialsOAuth20 {
    /**
     * The OAuth access token. See the <a href="https://developer.zendesk.com/documentation/ticketing/working-with-oauth/creating-and-using-oauth-tokens-with-the-api/">Zendesk docs</a> for more information on generating this token.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The OAuth client's ID. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
     */
    clientId?: pulumi.Input<string>;
    /**
     * The OAuth client secret. See <a href="https://docs.searchunify.com/Content/Content-Sources/Zendesk-Authentication-OAuth-Client-ID-Secret.htm#:~:text=Get%20Client%20ID%20and%20Client%20Secret&text=Go%20to%20OAuth%20Clients%20and,will%20be%20displayed%20only%20once.">this guide</a> for more information.
     */
    clientSecret?: pulumi.Input<string>;
}

export interface SourceZendeskSupportResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZendeskSupportResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZendeskSupportResourceAllocationJobSpecific>[]>;
}

export interface SourceZendeskSupportResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskSupportResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZendeskSupportResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZendeskSupportResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskTalkConfiguration {
    /**
     * Zendesk service provides two authentication methods. Choose between: `OAuth2.0` or `API token`.
     */
    credentials?: pulumi.Input<inputs.SourceZendeskTalkConfigurationCredentials>;
    /**
     * The date from which you'd like to replicate data for Zendesk Talk API, in the format YYYY-MM-DDT00:00:00Z. All data generated after this date will be replicated.
     */
    startDate: pulumi.Input<string>;
    /**
     * This is your Zendesk subdomain that can be found in your account URL. For example, in https://{MY_SUBDOMAIN}.zendesk.com/, where MY_SUBDOMAIN is the value of your subdomain.
     */
    subdomain: pulumi.Input<string>;
}

export interface SourceZendeskTalkConfigurationCredentials {
    apiToken?: pulumi.Input<inputs.SourceZendeskTalkConfigurationCredentialsApiToken>;
    oAuth20?: pulumi.Input<inputs.SourceZendeskTalkConfigurationCredentialsOAuth20>;
}

export interface SourceZendeskTalkConfigurationCredentialsApiToken {
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
     */
    apiToken: pulumi.Input<string>;
    /**
     * The user email for your Zendesk account.
     */
    email: pulumi.Input<string>;
}

export interface SourceZendeskTalkConfigurationCredentialsOAuth20 {
    /**
     * The value of the API token generated. See the <a href="https://docs.airbyte.com/integrations/sources/zendesk-talk">docs</a> for more information.
     */
    accessToken: pulumi.Input<string>;
    /**
     * Parsed as JSON.
     */
    additionalProperties?: pulumi.Input<string>;
    /**
     * Client ID
     */
    clientId?: pulumi.Input<string>;
    /**
     * Client Secret
     */
    clientSecret?: pulumi.Input<string>;
}

export interface SourceZendeskTalkResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZendeskTalkResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZendeskTalkResourceAllocationJobSpecific>[]>;
}

export interface SourceZendeskTalkResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZendeskTalkResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZendeskTalkResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZendeskTalkResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZenefitsConfiguration {
    /**
     * Use Sync with Zenefits button on the link given on the readme file, and get the token to access the api
     */
    token: pulumi.Input<string>;
}

export interface SourceZenefitsResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZenefitsResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZenefitsResourceAllocationJobSpecific>[]>;
}

export interface SourceZenefitsResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZenefitsResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZenefitsResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZenefitsResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZenloopConfiguration {
    /**
     * Zenloop API Token. You can get the API token in settings page <a href="https://app.zenloop.com/settings/api">here</a>
     */
    apiToken: pulumi.Input<string>;
    /**
     * Zenloop date_from. Format: 2021-10-24T03:30:30Z or 2021-10-24. Leave empty if only data from current data should be synced
     */
    dateFrom?: pulumi.Input<string>;
    /**
     * Zenloop Survey Group ID. Can be found by pulling All Survey Groups via SurveyGroups stream. Leave empty to pull answers from all survey groups
     */
    surveyGroupId?: pulumi.Input<string>;
    /**
     * Zenloop Survey ID. Can be found <a href="https://app.zenloop.com/settings/api">here</a>. Leave empty to pull answers from all surveys
     */
    surveyId?: pulumi.Input<string>;
}

export interface SourceZenloopResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZenloopResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZenloopResourceAllocationJobSpecific>[]>;
}

export interface SourceZenloopResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZenloopResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZenloopResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZenloopResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoAnalyticsMetadataApiConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * Default: "com"; must be one of ["com", "eu", "in", "com.au", "com.cn", "jp"]
     */
    dataCenter?: pulumi.Input<string>;
    orgId: pulumi.Input<number>;
    refreshToken: pulumi.Input<string>;
}

export interface SourceZohoAnalyticsMetadataApiResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoAnalyticsMetadataApiResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoAnalyticsMetadataApiResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoAnalyticsMetadataApiResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoAnalyticsMetadataApiResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoAnalyticsMetadataApiResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoAnalyticsMetadataApiResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoBiginConfiguration {
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The data center where the Bigin account's resources are hosted. Default: "com"; must be one of ["com", "com.au", "eu", "in", "com.cn", "jp"]
     */
    dataCenter?: pulumi.Input<string>;
    moduleName: pulumi.Input<string>;
}

export interface SourceZohoBiginResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoBiginResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoBiginResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoBiginResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoBiginResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoBiginResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoBiginResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoBillingConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    refreshToken: pulumi.Input<string>;
    /**
     * must be one of ["com", "eu", "in", "com.cn", "com.au", "jp", "sa", "ca"]
     */
    region: pulumi.Input<string>;
}

export interface SourceZohoBillingResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoBillingResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoBillingResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoBillingResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoBillingResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoBillingResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoBillingResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoBooksConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    refreshToken: pulumi.Input<string>;
    /**
     * The region code for the Zoho Books API, such as 'com', 'eu', 'in', etc. must be one of ["com", "eu", "in", "com.cn", "com.au", "jp", "sa", "ca"]
     */
    region: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceZohoBooksResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoBooksResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoBooksResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoBooksResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoBooksResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoBooksResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoBooksResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoCampaignConfiguration {
    clientId2: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret2: pulumi.Input<string>;
    /**
     * must be one of ["com", "eu", "in", "com.au", ".jp", ".com.cn"]
     */
    dataCenter: pulumi.Input<string>;
}

export interface SourceZohoCampaignResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoCampaignResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoCampaignResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoCampaignResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoCampaignResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoCampaignResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoCampaignResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoCrmConfiguration {
    /**
     * OAuth2.0 Client ID
     */
    clientId: pulumi.Input<string>;
    /**
     * OAuth2.0 Client Secret
     */
    clientSecret: pulumi.Input<string>;
    /**
     * Please choose the region of your Data Center location. More info by this <a href="https://www.zoho.com/crm/developer/docs/api/v2/multi-dc.html">Link</a>. must be one of ["US", "AU", "EU", "IN", "CN", "JP"]
     */
    dcRegion: pulumi.Input<string>;
    /**
     * Choose your Edition of Zoho CRM to determine API Concurrency Limits. Default: "Free"; must be one of ["Free", "Standard", "Professional", "Enterprise", "Ultimate"]
     */
    edition?: pulumi.Input<string>;
    /**
     * Please choose the environment. must be one of ["Production", "Developer", "Sandbox"]
     */
    environment: pulumi.Input<string>;
    /**
     * OAuth2.0 Refresh Token
     */
    refreshToken: pulumi.Input<string>;
    /**
     * ISO 8601, for instance: `YYYY-MM-DD`, `YYYY-MM-DD HH:MM:SS+HH:MM`
     */
    startDatetime?: pulumi.Input<string>;
}

export interface SourceZohoCrmResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoCrmResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoCrmResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoCrmResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoCrmResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoCrmResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoCrmResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoDeskConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    includeCustomDomain?: pulumi.Input<boolean>;
    refreshToken: pulumi.Input<string>;
    tokenRefreshEndpoint: pulumi.Input<string>;
}

export interface SourceZohoDeskResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoDeskResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoDeskResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoDeskResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoDeskResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoDeskResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoDeskResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoExpenseConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The domain suffix for the Zoho Expense API based on your data center location (e.g., 'com', 'eu', 'in', etc.). Default: "com"; must be one of ["com", "in", "jp", "ca", "com.cn", "sa", "com.au", "eu"]
     */
    dataCenter?: pulumi.Input<string>;
    refreshToken: pulumi.Input<string>;
}

export interface SourceZohoExpenseResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoExpenseResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoExpenseResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoExpenseResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoExpenseResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoExpenseResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoExpenseResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoInventoryConfiguration {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * The domain suffix for the Zoho Inventory API based on your data center location (e.g., 'com', 'eu', 'in', etc.). Default: "com"; must be one of ["com", "in", "jp", "eu", "com.au", "ca", "com.cn", "sa"]
     */
    domain?: pulumi.Input<string>;
    refreshToken: pulumi.Input<string>;
    startDate: pulumi.Input<string>;
}

export interface SourceZohoInventoryResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoInventoryResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoInventoryResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoInventoryResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoInventoryResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoInventoryResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoInventoryResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoInvoiceConfiguration {
    clientId: pulumi.Input<string>;
    clientRefreshToken: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    /**
     * To be provided if a user belongs to multiple organizations
     */
    organizationId?: pulumi.Input<string>;
    /**
     * must be one of ["com", "eu", "in", "com.cn", "com.au", "jp", "sa", "ca"]
     */
    region: pulumi.Input<string>;
}

export interface SourceZohoInvoiceResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZohoInvoiceResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZohoInvoiceResourceAllocationJobSpecific>[]>;
}

export interface SourceZohoInvoiceResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZohoInvoiceResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZohoInvoiceResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZohoInvoiceResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZonkaFeedbackConfiguration {
    /**
     * Auth token to use. Generate it by navigating to Company Settings > Developers > API in your Zonka Feedback account.
     */
    authToken: pulumi.Input<string>;
    /**
     * The identifier for the data center, such as 'us1' or 'e' for EU. must be one of ["us1", "e"]
     */
    datacenter: pulumi.Input<string>;
}

export interface SourceZonkaFeedbackResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZonkaFeedbackResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZonkaFeedbackResourceAllocationJobSpecific>[]>;
}

export interface SourceZonkaFeedbackResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZonkaFeedbackResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZonkaFeedbackResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZonkaFeedbackResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZoomConfiguration {
    /**
     * The account ID for your Zoom account. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
     */
    accountId: pulumi.Input<string>;
    /**
     * Default: "https://zoom.us/oauth/token"
     */
    authorizationEndpoint?: pulumi.Input<string>;
    /**
     * The client ID for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
     */
    clientId: pulumi.Input<string>;
    /**
     * The client secret for your Zoom app. You can find this in the Zoom Marketplace under the "Manage" tab for your app.
     */
    clientSecret: pulumi.Input<string>;
}

export interface SourceZoomResourceAllocation {
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    default?: pulumi.Input<inputs.SourceZoomResourceAllocationDefault>;
    jobSpecifics?: pulumi.Input<pulumi.Input<inputs.SourceZoomResourceAllocationJobSpecific>[]>;
}

export interface SourceZoomResourceAllocationDefault {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface SourceZoomResourceAllocationJobSpecific {
    /**
     * enum that describes the different types of jobs that the platform runs. must be one of ["get_spec", "check_connection", "discover_schema", "sync", "reset_connection", "connection_updater", "replicate"]
     */
    jobType?: pulumi.Input<string>;
    /**
     * optional resource requirements to run workers (blank for unbounded allocations)
     */
    resourceRequirements?: pulumi.Input<inputs.SourceZoomResourceAllocationJobSpecificResourceRequirements>;
}

export interface SourceZoomResourceAllocationJobSpecificResourceRequirements {
    cpuLimit?: pulumi.Input<string>;
    cpuRequest?: pulumi.Input<string>;
    ephemeralStorageLimit?: pulumi.Input<string>;
    ephemeralStorageRequest?: pulumi.Input<string>;
    memoryLimit?: pulumi.Input<string>;
    memoryRequest?: pulumi.Input<string>;
}

export interface WorkspaceNotifications {
    /**
     * Configures a notification.
     */
    connectionUpdate?: pulumi.Input<inputs.WorkspaceNotificationsConnectionUpdate>;
    /**
     * Configures a notification.
     */
    connectionUpdateActionRequired?: pulumi.Input<inputs.WorkspaceNotificationsConnectionUpdateActionRequired>;
    /**
     * Configures a notification.
     */
    failure?: pulumi.Input<inputs.WorkspaceNotificationsFailure>;
    /**
     * Configures a notification.
     */
    success?: pulumi.Input<inputs.WorkspaceNotificationsSuccess>;
    /**
     * Configures a notification.
     */
    syncDisabled?: pulumi.Input<inputs.WorkspaceNotificationsSyncDisabled>;
    /**
     * Configures a notification.
     */
    syncDisabledWarning?: pulumi.Input<inputs.WorkspaceNotificationsSyncDisabledWarning>;
}

export interface WorkspaceNotificationsConnectionUpdate {
    /**
     * Configures an email notification.
     */
    email?: pulumi.Input<inputs.WorkspaceNotificationsConnectionUpdateEmail>;
    /**
     * Configures a webhook notification.
     */
    webhook?: pulumi.Input<inputs.WorkspaceNotificationsConnectionUpdateWebhook>;
}

export interface WorkspaceNotificationsConnectionUpdateActionRequired {
    /**
     * Configures an email notification.
     */
    email?: pulumi.Input<inputs.WorkspaceNotificationsConnectionUpdateActionRequiredEmail>;
    /**
     * Configures a webhook notification.
     */
    webhook?: pulumi.Input<inputs.WorkspaceNotificationsConnectionUpdateActionRequiredWebhook>;
}

export interface WorkspaceNotificationsConnectionUpdateActionRequiredEmail {
    enabled?: pulumi.Input<boolean>;
}

export interface WorkspaceNotificationsConnectionUpdateActionRequiredWebhook {
    enabled?: pulumi.Input<boolean>;
    url?: pulumi.Input<string>;
}

export interface WorkspaceNotificationsConnectionUpdateEmail {
    enabled?: pulumi.Input<boolean>;
}

export interface WorkspaceNotificationsConnectionUpdateWebhook {
    enabled?: pulumi.Input<boolean>;
    url?: pulumi.Input<string>;
}

export interface WorkspaceNotificationsFailure {
    /**
     * Configures an email notification.
     */
    email?: pulumi.Input<inputs.WorkspaceNotificationsFailureEmail>;
    /**
     * Configures a webhook notification.
     */
    webhook?: pulumi.Input<inputs.WorkspaceNotificationsFailureWebhook>;
}

export interface WorkspaceNotificationsFailureEmail {
    enabled?: pulumi.Input<boolean>;
}

export interface WorkspaceNotificationsFailureWebhook {
    enabled?: pulumi.Input<boolean>;
    url?: pulumi.Input<string>;
}

export interface WorkspaceNotificationsSuccess {
    /**
     * Configures an email notification.
     */
    email?: pulumi.Input<inputs.WorkspaceNotificationsSuccessEmail>;
    /**
     * Configures a webhook notification.
     */
    webhook?: pulumi.Input<inputs.WorkspaceNotificationsSuccessWebhook>;
}

export interface WorkspaceNotificationsSuccessEmail {
    enabled?: pulumi.Input<boolean>;
}

export interface WorkspaceNotificationsSuccessWebhook {
    enabled?: pulumi.Input<boolean>;
    url?: pulumi.Input<string>;
}

export interface WorkspaceNotificationsSyncDisabled {
    /**
     * Configures an email notification.
     */
    email?: pulumi.Input<inputs.WorkspaceNotificationsSyncDisabledEmail>;
    /**
     * Configures a webhook notification.
     */
    webhook?: pulumi.Input<inputs.WorkspaceNotificationsSyncDisabledWebhook>;
}

export interface WorkspaceNotificationsSyncDisabledEmail {
    enabled?: pulumi.Input<boolean>;
}

export interface WorkspaceNotificationsSyncDisabledWarning {
    /**
     * Configures an email notification.
     */
    email?: pulumi.Input<inputs.WorkspaceNotificationsSyncDisabledWarningEmail>;
    /**
     * Configures a webhook notification.
     */
    webhook?: pulumi.Input<inputs.WorkspaceNotificationsSyncDisabledWarningWebhook>;
}

export interface WorkspaceNotificationsSyncDisabledWarningEmail {
    enabled?: pulumi.Input<boolean>;
}

export interface WorkspaceNotificationsSyncDisabledWarningWebhook {
    enabled?: pulumi.Input<boolean>;
    url?: pulumi.Input<string>;
}

export interface WorkspaceNotificationsSyncDisabledWebhook {
    enabled?: pulumi.Input<boolean>;
    url?: pulumi.Input<string>;
}
